{
    "content": [{
                "id": "QAa7U_oQuhLB3oRFyUHYuw",
                "title": "[RxSwift - Take note về RxSwift] - Các lưu ý dễ mắc phải (phần 1)",
                "content": "## [RxSwift - Take note về RxSwift] - Các lưu ý dễ mắc phải (phần 1)\r\n\r\n###1. Vấn đề về liên quan đến hot/ cold Observables: \r\n\r\nThực tế, khi **mới** nghiên cứu về Hot-Cold Observables, các bạn đừng để ý gì về việc 1 dòng Stream hay nhiều dòng Stream. Với kiến thức hiện tại của mình tại lúc này, mình chỉ quan tâm: các driver UI như UIButton tap hay text UITextField có Hot Observable. Còn các Observable khác là mỗi khi có ai đó subscribe, nó mới emit. (khi nào cần đưa nó thành Hot thì trigger nó)\r\n####a. Ví dụ 1: \r\n\r\n```\r\n\tlet stringTest01: Driver\u003cString?\u003e = imageButton.flatMapLatest { image in\r\n      print(\"[Debug] [stringTest01] day la image VM ne`\\(image)\")\r\n      return RollcallService.uploadImage(withUid: Constant.currentUid ?? \"\", image: image!).asDriver(onErrorJustReturn: \"\")\r\n    }\r\n    \r\n    let stringTest02: Driver\u003cString?\u003e = imageButton.flatMapLatest { image in\r\n      print(\"[Debug] [stringTest02] day la image VM ne`\\(image)\")\r\n      return RollcallService.uploadImage(withUid: Constant.currentUid ?? \"\", image: image!).asDriver(onErrorJustReturn: \"\")\r\n    }\r\n    \r\n    stringTest01.drive(onNext: { resultString in\r\n      print(\"[Debug] [atViewModel] Result string tai man hinh View Model \\(resultString)\")\r\n    })\r\n```\r\n\r\nKhi run lên thì chuyện gì xảy ra, chỉ có `[Debug] [stringTest01]` được in ra cùng với `[Debug] [atViewModel]`, còn stringTest02 không có ai subscribe nên nó không phát ra tín hiệu.\r\n\r\n####b. Ví dụ 2:\r\n```\r\nlet allTextConditions = Driver.combineLatest(nameTextField, emailTextField, passwordTextField, descriptionTextField, positionTextField) { (name, email, password, descriptionUser, position) -\u003e (Users) in\r\n      print(\"[Debug] [allTextConditions] User is \\(Users(name: name, email: email, password: password, descriptionUser: descriptionUser, position: position))\")\r\n      return Users(name: name, email: email, password: password, descriptionUser: descriptionUser, position: position)\r\n    }\r\n  \r\n ```\r\n `combineLatest` chỉ là update mỗi lần có sự thay đổi của các text inside. Còn phần bên trong completion handler là chỉ khi nào có ai đó subscribe, nó mới gọi ra các công việc trong này.\r\n \r\n###2. Lỗi khi không subscribe/ drive được các Observables/ Drivers:\r\n \r\n Cái lỗi này khiến mình bực mình nhất. Xem đoạn code sau:\r\n \r\n ```\r\n profileViewModel.signUpResult.drive { result in\r\n      print(\"Ket qua la result \\(result)\")\r\n    }\r\n ```\r\n Sau khi có được tín hiệu từ ViewModel, mình chuyển qua bên View Controller, cái mà mình nhận được, lúc thì không có gì (lúc này chẳng hiểu vì sao), lúc thì nó ra cái định nghĩa của Driver (nhờ lúc này mới biết là mình thiếu onNext). Cho nên, các bạn cẩn thận nha:\r\n \r\n ```\r\n profileViewModel.signUpResult.drive(onNext: { result in\r\n      print(\"Ket qua la result \\(result)\")\r\n    })\r\n ```\r\n \r\n###3. Lưu ý về disposeBag và dispose: \r\n Các bạn phải lưu ý cần thận việc này, đôi khi nhiều bạn cứ code như sau:\r\n ```\r\n profileViewModel.signUpResult.drive(onNext: { result in\r\n      print(\"Ket qua la result \\(result)\")\r\n    }).dispose()\r\n ```\r\n Vì nếu mà dispose ở đó, tức là nó chỉ lắng nghe 1 lần rồi thôi, stop, ko observer nữa. Mà một khi ko có ai observe nó sẽ stop. Mọi thay đổi tiếp đó, mình sẽ không có kết quả gì. Dùng disposeBag sẽ giữ được sự lắng nghe cho đến khi dealloc màn hình hiện tại. \r\n \r\n Như vậy, mình đã take note lỗi của mình. Hi vọng các bạn đọc được rồi rút kn cho bản thân."
                }, {
                "id": "QOcGF4OtfTFUlyleBO-Jpg",
                "title": "Swift - Test-Driven Development (TDD) - Chapter 2 - Planning /Structuring App",
                "content": "## Swift - Test-Driven Development (TDD) - Chapter 2 - Planning and Structuring Your Test-Driven iOS App\r\n\r\nỞ phần này, ta sẽ vận dụng kiến thức có được từ writing test sang driving development. Ta sẽ thiết kế 1 app đơn giản như sau: \r\n- The task list view\r\n- The task detail view\r\n- The task input view\r\n\r\nBên cạnh đó cũng sẽ đề cập hướng planning và structure của một app. Mình sẽ xây dựng bài viết kiểu như đưa ra user story rồi mình phân tích như thế nào cho hợp lí.\r\n\r\n###**1. The task list view**\r\n####**a. First user story**\r\n\u003e User stories:\r\n- As a user, I want to see the list of to-do items when I open the app\r\n- As a user, I want to add to-do items to the list\r\n\r\nNhư vậy, từ user stories, ta phân tích:\r\n- App gồm list of to-do items (UITableView). \r\n- Item trong list gồm title, optional location và due date.\r\n- New item có thể được added vào list bằng add (+) button nằm ở navigation bar.\r\n\t![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7m9ojl6ddn_Screen%20Shot%202018-05-04%20at%209.41.14%20AM.png)\r\n    \r\n####**b. Second user story**\r\n\r\n\u003e User stories:\r\n- As a user, I want to check a to-do item to mark it as finished\r\n- As a user, I want to see all the checked items following the unchecked items\r\n- As a user, I want to uncheck a to-do item\r\n- As a user, I want to delete all the to-do items\r\n\r\nNhư vậy, từ user stories, ta phân tích:\r\n- Tại mỗi item, slide left sẽ có 1 Button để check hoặc uncheck, như sau: \r\n \t![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/om0iwb7myk_Screen%20Shot%202018-05-04%20at%209.40.59%20AM.png)\r\n- Item nào được mark là checked sẽ được đẩy xuống Finished section.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gs86x9oyj1_Screen%20Shot%202018-05-04%20at%209.41.57%20AM.png)\r\n- Tại Finished section, có thể xoá item nếu cần\r\n- Tap vào Item, thì detail of Item hiển thị. \r\n\r\n###**2. The task detail view**\r\n\u003e User stories:\r\n- As a user, given that I have tapped a to-do item in the list, I want to see its details\r\n- As a user, I want to check a to-do item from its details view\r\n\r\nNhư vậy, từ user stories, ta phân tích:\r\n- Màn hình detail show hết các thông tin của item. \r\n- Thông tin gồm title, due date, location (name and address) và description.\r\n-  Nếu có address, map sẽ hiển thị address. \r\n-  Ta cũng có thể bấm finish ở màn hình này.\r\n\r\nDesign như hình dưới đây:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/x4qhkup5o3_Screen%20Shot%202018-05-04%20at%2010.00.10%20AM.png)\r\n###**3. The task input view**\r\n\u003e User stories:\r\n- As a user, given that I tapped the add (+) button in the item list, I want to see a form to put in the details (title, optional date, optional location name, optional address, and optional description) of a to-do item\r\n- As a user, I want to add a to-do item to the list of to-do items by tapping on the Save button\r\n\r\nNhư vậy, từ user stories, ta phân tích:\r\n- Bấm vào add (+) button ở list view, task input view hiển thị. \r\n- User có thể add thông tin nhưng chỉ có title là required. \r\n- The Save button chỉ available và selected sau khi đã điền title.\r\n- Nút Cancel button dismiss view. \r\n\r\nDesign như hình dưới đây\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lqyjt7eaxc_Screen%20Shot%202018-05-04%20at%209.54.09%20AM.png)\r\n\r\nLưu ý:  \r\n\u003e\r\n- Lưu ý là ta sẽ không test UI. Unit test không thể biết được app trông đẹp như thế nào, nó chỉ có thể test features phần mà ít liên quan đến presentation.\r\n- Về nguyên tắc, thì có thể viết được test vị trí màu sắc của UI nhưng nó kiểu không phải là mục đích chính của cái này.\r\n- Cái ta cần test là UI có present hay không, hay có input được không.\r\n\r\n###**4. The structure of the app**\r\nCả ba phần trên có thể hiểu là the planning của app. Bây giờ ta sẽ đến phần structure của app. Các bạn nhìn vào hình sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/xpvbjp8cat_Screen%20Shot%202018-05-04%20at%2010.36.09%20AM.png)\r\n\r\n####**a. The table view controller, the delegate, and the data source**\r\n\r\nCái hay của TableView thì ai cũng thấy rồi, tuy nhiên thường có 1 tình huống mà nó đảm nhận quá nhiều việc: presenting the view, navigating đến view controllers khác, quản lý presentation của data (reload, update, v..v)\r\n\r\nĐôi khi, ta nên chia nhỏ ra thành nhiều lớp con, đảm nhiệm nhiều nhiệm vụ khác nhau. Vì vậy, ta sẽ sử dụng helper class để giúp phần data source và delegate. Phần giao tiếp giữa helper và table view controller ta dùng protocol.  \r\n\r\nProtocol sẽ define inferface của một class trông như thế nào. Nó có 1 ưu điểm là nếu ta cần replace 1 implementation với phiên bản tốt hơn, ta chỉ cần dev dựa trên 1 interface rõ ràng rồi, những phần trước đó hay bên trong ta không quan tâm.\r\n\r\n####**b. The table view cells**\r\nItem có 1 title, có optional date và location name. Phần table view cells này chỉ hiển thị phần data. Ta chỉ cần code trên custom table view cell của ta.\r\n\r\n####**c. The model**\r\nThe model của application chứa to-do item, location, item manager (cái mà cho phép thêm/ sửa/ xoá items và chịu trách nhiệm quản lý items). Vì vậy, controller sẽ gửi yêu cầu đến item manager về vấn đề hiển thị item lên cell. Ngoài ra item manager cũng sẽ đảm nhiệm lưu trữ items lên disc.\r\n\r\nĐối với những người mới bắt đầu thường có xu hướng quản lý object model bên trong viewController. Sau đó controller có 1 reference đến collection of items, và việc thêm bớt sẽ thực hiện trực tiếp trên đó luôn. Điều này không được recommend bởi vì nếu chúng ta muốn thay đổi việc lưu trữ của items (ví dụ như khi dùng Core Data), việc thêm/ xoá này sẽ phải được thực hiện ở bên trong controller. Thật khó để có 1 cái nhìn tổng quan về một lớp như vậy.\r\n\r\nSẽ dễ dàng hơn nếu có 1 interface rõ ràng nối controller với lớp model. Bởi vì nếu ta cần thay đổi cách model được quản lý, View Controller vẫn được giữ nguyên. Ta thậm chí có thể complete lớp model nếu giữ lớp interface như cũ. Chúng ta sẽ thấy việc tách rời ra giúp code dễ dàng hơn như thế nào.\r\n\r\n####**d. Other view controllers**\r\nMình còn 2 view controllers khác là task detail view controller và 1 view controller cho input task\r\n\r\nKhi user tap vào to-do item trong list, màn hình detail sẽ xuất hiện.\r\nNew to-do items sẽ được added vào the list thông qua việc sử dụng input view controller.\r\n\r\n####**e. The development strategy**\r\nTa sẽ xây dựng app từ trong ra ngoài. Ta sẽ bắt đầu với Model, rồi đến Controllers rồi networking, xong rồi gắn lại.\r\n\r\nThông thường, mình thích xây dựng app theo kiểu feature-by-feature hơn là TDD. Nhưng nếu chia thành các layer nhỏ ra thay vì features, nó sẽ dễ theo dõi và có cái nhìn tổng thể hơn về mọi việc. Sau này khi cần refresh memory hay những thông tin liên quan cũng dễ cho bạn hơn.\r\n\r\nOK, bây giờ ta tạo 1 cái app nhỏ như sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/jlwaa7eka7_Screen%20Shot%202018-05-04%20at%202.00.07%20PM.png)\r\n\r\nLưu ý là Xcode đã set up cái test target sao cho phần testing của implementations tương ứng với nhau mà ta sẽ viết trong application.\r\n\r\nPhần Edit Scheme..., mình đã trình bày kĩ ở bài trước. Các bạn xem ở đây nhé\r\n\r\n###**5. Setting up useful Xcode behaviors for testing**\r\n####**a. Useful build behaviors**\r\nXcode có 1 feature gọi là \"behaviors\", với việc sử dụng behaviors và tabs, Xcode có thể cho ta xem những thông tin hữu ích dựa vào trạng thái của nó. Để enable, các bạn vào Xcode -\u003e Behaviors -\u003e Edit Behaviors.\r\n\r\nXong, ta làm các thao tác như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/2x0wypffhn_Screen%20Shot%202018-05-04%20at%202.36.03%20PM.png)\r\n\r\nKhi bắt đầu build, Xcode compiles các files và links chúng với nhau. Bạn cần activate build log lên để thấy nó hoạt động như thế nào. Build và run để xem thử Behaviors như thế nào ^^\r\n\r\n####**b. Testing behaviors**\r\nTa setup như sau cho dễ nhìn: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/v48kmuxzd3_Screen%20Shot%202018-05-04%20at%202.39.57%20PM.png)\r\n\r\nKhi các test cases bắt đầu run, ta vẫn muốn thấy code editor nữa. Nên add 1 behavior để show Coding tab. Ngoài ra, ta cũng muốn thấy thêm Test Navigator và debugger với console view.\r\n\r\nKhi các test case thành công, thì Xcode sẽ show 1 bảng bezel để thông báo các tests đã thành công. Ta cũng có thể hide cái navigator và debugger để tập trung refactor hoặc viết code.\r\n\r\n###**6. Summary**\r\nTrong bài này, ta đã có cái nhìn tổng quát về app mà mình sẽ viết ở những bài sau. Trong các bài viết sắp tới, mình sẽ viết lớp data model của app sử dụng TDD. `Mình sẽ sử dụng struct để tạo model bởi vì models được represented tốt nhất trong Swift bởi value types.`\r\nMình cũng sẽ dùng Equatable protocol để so sánh các model dễ dàng hơn"
                }, {
                "id": "e4TyzAqA150w0VKyLCvGLg",
                "title": "Swift - Test-Driven Development (TDD) - Chapter 1 - Part 3 - Các lưu ý với Xcode",
                "content": "## Swift - Test-Driven Development (TDD) - Chapter 1 - Part 3 - Các lưu ý với Xcode\r\n\r\n###**1. Các lưu ý cơ bản**\r\n- Navigate đến phần test, các bạn bấm zô cái button như trong hình:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/iyspdfejae_Screen%20Shot%202018-05-03%20at%202.45.18%20PM.png)\r\n\r\n- Chỉ xem test failed, không xem test pass, bấm zô cái button như trong hình: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/s7yyb1euuj_Screen%20Shot%202018-05-03%20at%202.45.30%20PM.png)\r\n\r\n- Xem kết quả, chi tiết bấm zô cái button sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/h5ermwn9di_Screen%20Shot%202018-05-03%20at%202.48.33%20PM.png)\r\n\r\n- Để xem kết quả cụ thể từng test case, bấm vào lần run đó, nhìn qua bên phải: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/9nxadxgp6s_Screen%20Shot%202018-05-03%20at%202.48.50%20PM.png)\r\n\r\n- Để run tất cả test cases: Command + U, Product -\u003e Test, hoặc click biểu tượng màu xanh chỗ class\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/g8r8ohhk4q_Screen%20Shot%202018-05-03%20at%202.53.39%20PM.png)\r\n\r\n- Để run 1 specific test case: Tương tự, click vào cái ô phía trước mỗi test case hoặc ở bên trái, chỗ xem kết quả, click vào biểu tượng màu xanh/ đỏ nếu failed:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/cskj2xnw2n_Screen%20Shot%202018-05-03%20at%202.54.44%20PM.png)\r\n\r\n- Để run 1 nhóm test cases, các bạn làm theo như trong hình sau: \r\nBấm vào scheme trên toolbar (biểu tượng giống cái compa ấy)\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/8n8hcgvn9c_Screen%20Shot%202018-05-03%20at%202.58.45%20PM.png)\r\nBấm tiếp vào Edit Scheme... -\u003e Chọn Test\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/msu8tnb8aj_Screen%20Shot%202018-05-03%20at%202.59.53%20PM.png)\r\nBấm và chọn các test cases mong muốn, mặc định là selected all:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/fhuhvvxccb_Screen%20Shot%202018-05-03%20at%203.00.32%20PM.png)\r\n\r\n###**2. setUp() and tearDown() methods**\r\nChúng ta đã thấy setUp() and tearDown() methods ở trước đó. Trong ví dụ trước, ta đã thấy được setUp() để init ViewControllerViewController. Trước mỗi test case nó sẽ được khởi tạo để dùng cho việc run. Những gì ta thay đổi ở mỗi test case riêng biệt không ảnh hưởng đến những test case khác. \r\n\r\ntearDown() method được chạy sau mỗi lần gọi. Sử dụng tearDown() để cleanup hoặc việc gì đấy tương tự. \r\n\r\n###**2. Debugging tests**\r\nChắc cũng có lúc bạn sẽ cần debug phần code tests. Cách debug cũng như bình thường vậy. Ta chỉnh sửa code 1 chút để fail như sau:\r\n```\r\n   func test_MakeHeadline_ReturnsStringWithEachWordStartCapital2() {\r\n     let input           = \"Here is another Example\"\r\n     let expectedOutput  = \"Here iS Another Example\"\r\n     let headline = viewController.makeHeadline(from: input)\r\n     XCTAssertEqual(headline, expectedOutput)\r\n   }\r\n```\r\nĐặt breakpoint ở dòng XCTAssertEqual. Và xem thử: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mu2ndizmbi_Screen%20Shot%202018-05-03%20at%203.28.04%20PM.png)\r\n\r\npo tức là print object\r\n\r\n###**3. Breakpoint làm dừng test failure**\r\nXcode có 1 cách để breakpoint. Một khi cái breakpoint này được set, test sẽ dừng lại ở nơi nó bị failed, và 1 debug section sẽ run lên. \r\nThông thường đây không phải là cái mình muốn ở TDD, vì failing tests xảy ra là bình thường và mình cũng không cần biết nguyên do. Chỉ nên dùng khi đã xong refactor và chạy lại regression.\r\n\r\n- Bước 1: Bấm vào icon như trong hình\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/f45ngb2v5q_Screen%20Shot%202018-05-03%20at%203.35.09%20PM.png)\r\n- Bước 2: Ở phía dưới\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/botehf5dzr_Screen%20Shot%202018-05-03%20at%203.35.19%20PM.png)\r\n\r\nKết quả sau khi run lên bạn sẽ thấy, thanh kết quả tạm dừng\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/q7eja0t3kg_Screen%20Shot%202018-05-03%20at%203.38.19%20PM.png)\r\n\r\nvà phần breakpoint hiển thị ở phần sai:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/vbrngu7wvt_Screen%20Shot%202018-05-03%20at%203.37.52%20PM.png)\r\n\r\nĐể run lại thì cũng có nhiều cách, mình giới thiệu một cách: \r\nProduct -\u003e Perform Action -\u003e Test \"test_MakeHeadline_ReturnsStringWithEachWordStartCapital2()\" Again hoặc ctrl + option + command + G\r\n"
                }, {
                "id": "Rt1xhV0WKeoJ_AcNG5VdOg",
                "title": "Swift - Test-Driven Development (TDD) - Chapter 1 - Part 2b - Understanding TDD",
                "content": "## Swift - Test-Driven Development (TDD) - Chapter 1 - Part 2b - Understanding TDD\n\nPhần 2b này, chúng ta sẽ đi qua một ví dụ khác để có cái nhìn rõ hơn về cấu trúc cũng như quy tắc của TDD. \n\n###**Ví dụ 2**\n####**1. Red**\nNhư đã đề cập ở phần trước, ta cần 1 cái test khác, bởi vì production code chỉ work với 1 input cụ thể. Feature của mình cần phải work với tất cả các input. Add vào phần test, đoạn code sau: \n```\nfunc test_MakeHeadline_ReturnsStringWithEachWordStartCapital2() {\n     let string = \"Here is another Example\"\n     let headline = viewController.makeHeadline(from: string)\n     XCTAssertEqual(headline, \"Here Is Another Example\")\n   }\n```\nXong rồi Run test nào. Đương nhiên là nó fail gòy. Fail này là do XCAssert. Không phải do phần code, cho nên ta coi như đã xong phần Red. Qua phần Green nào.\n\n####**2. Green**\nBây giờ quay trở lại phần code production và thay dòng hard-code bằng đoạn code sau: \n```\nfunc makeHeadline(from string: String) -\u003e String {\n    let words = string.components(separatedBy: \" \")\n    var headline = \"\"\n    for var word in words {\n      let firstCharacter = word.remove(at: word.startIndex)\n      headline += \"\\(String(firstCharacter).uppercased())\\(word) \"\n    }\n    headline.remove(at: headline.index(before: headline.endIndex))\n    return headline\n  }\n```\nMình sẽ phân tích từng phần:\n- `let words = string.components(separatedBy: \" \")` đoạn này lấy từng từ trong string truyền vào\n- trong vòng lặp for, lấy từng từ một. Lấy kí tự đầu tiên ra bằng dòng `let firstCharacter = word.remove(at: word.startIndex)`\n- viết hoa nó lên `String(firstCharacter).uppercased()` xong rồi ghép nó với khúc phía sau `\"\\(String(firstCharacter).uppercased())\\(word) \"` -\u003e để ý có space ở đây để cách với từ tiếp theo.\n- ghép từng từ lại thành 1 câu trở lại `headline += \"\\(String(firstCharacter).uppercased())\\(word) \"`\n- xoá space sau cùng `headline.remove(at: headline.index(before: headline.endIndex))` và return lại kết quả.\n\nRun test và kết quả pass hết. Phần tiếp theo chính là Refactor. \n\n\u003e Lưu ý phần refactor cần phải có. Nếu bạn thấy mình không có gì để refactor tức là bạn vẫn chưa xong.\n\n####**3. Refactor**\nNhìn vào 2 đoạn code mà bạn vừa viết dưới đây: \n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/llnsnx8lic_Screen%20Shot%202018-05-03%20at%201.44.39%20PM.png)\n\nNhìn vào, thật sự mình chả hiểu input là gì? Output là gì? Mặc dù chính mình vừa mới viết xong ^^ Ta refactor như sau: \n```\nfunc test_MakeHeadline_ReturnsStringWithEachWordStartCapital() {\n     let input           = \"this is A test headline\"\n     let expectedOutput  = \"This Is A Test Headline\"\n     let headline = viewController.makeHeadline(from: input)\n     XCTAssertEqual(headline, expectedOutput)\n   }\n \nfunc test_MakeHeadline_ReturnsStringWithEachWordStartCapital2() {\n     let input           = \"Here is another Example\"\n     let expectedOutput  = \"Here Is Another Example\"\n     let headline = viewController.makeHeadline(from: input)\n     XCTAssertEqual(headline, expectedOutput)\n   }\n```\n\nCác bạn đã thấy nó chia ra rõ ràng, input là gì? expectedOutput là gì? dòng nào thực hiện hàm v.v. Nó tuân theo cấu trúc logic mà mình đã bàn ở phần một: precondition, invocation, and assertion.\n\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/qhd6e53ml_Screen%20Shot%202018-05-03%20at%201.49.40%20PM.png)\n\n####**4. Check test code**\nVề cơ bản, những lần thay đổi code ở phần test không cần phải được tested. Nhưng làm sao ta biết được liệu những test case này có được update kịp thời không? Hay là vẫn test như trước đó ? Tốt nhất là nên thử rằng tests ok. Có nghĩa là ta làm nó fail đi. Comment dòng code sau cùng trong production code đi: \n```\n// headline.remove(at: headline.index(before: headline.endIndex))\n```\nNhư vậy, string được trả về sẽ dư 1 space. Run nào. Oh Yeahhh Fail cả hai. Như vậy là ok.\n\n\u003e Note: Nếu bạn để ý, 1 test failed sẽ không làm dừng lại quá trình test. Nhìn chung là vậy, nhưng bạn cũng có thể thay đổi continueAfterFailure thành false in setUp().\n\nTrước khi kết bài, mình nhìn lại production code một chút. Nhìn nó như kiểu Objective-C translate qua Swift vậy. Mình cho nó nhìn dễ thương như Swift một chút, như sau: \n```\nfunc makeHeadline(from string: String) -\u003e String {\n     let words = string.components(separatedBy: \" \")\n     let headlineWords = words.map { (word) -\u003e String in\n       var mutableWord = word\n       let first = mutableWord.remove(at: mutableWord.startIndex)\n       return String(first).uppercased() + mutableWord\n       }\n     return headlineWords.joined(separator: \" \")\n   }\n```\nCó hai sự khác biệt là dùng map thay cho for và joined, tức là kết hợp các phần tử riêng lại. Run lại thì thấy ok, test pass hết. \n\n####**5. Tổng kết**\nQua hai phần này, mặc dù các ví dụ đơn giản nhưng ít nhiều mình cũng đã biết thêm về TDD workflowworkflow như thế nào. Hi vọng những bài tới sẽ tốt thêm. "
                }, {
                "id": "4jx7GuXld2oHE0X8rtWeEA",
                "title": "Swift - Test-Driven Development (TDD) - Chapter 1 - Part 2 - Understanding TDD",
                "content": "## Swift - Test-Driven Development (TDD) - Chapter 1 - Part 2 - Understanding TDD\r\n\r\nQua hai phần Part 1a, Part 1b ở bài trước, mình đã hiểu unit test là gì, chúng có ích như thế nào. Tiếp theo, chúng ta sẽ tìm hiểu tiếp về TDD. Rất xin lỗi các bạn nếu khi các bạn đọc vào thấy bỡ ngỡ, mình cũng chưa rõ phải trình bày như thế nào để dễ hiểu nhất. Sau khi get được nhiều kiến thức, mình sẽ sắp xếp or bổ sung thêm.\r\n\r\n### **1. The TDD workflow - red, green, refactor**\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/aow5og0f9_tdd-circle-of-life.png)\r\n#### **a. Red**\r\nBạn bắt đầu bằng cách viết 1 test failed. Nó được dùng được kiểm tra các feature mà chưa được element hay những edge case mà bạn muốn đi qua để cover hết. \r\nMột điều quan trọng là phần test sẽ được viết trước trong lúc này **sẽ bị fail**. Nếu không thì bạn sẽ không thể đảm bảo là test có được không hay nó có thực sự test những feature mà mình mong muốn element hay không. \r\n\r\n#### **b. Green**\r\nTrong giai đoạn Green, mình chỉ cần viết 1 đoạn code đơn giản nhất có thể để test pass. Code xấu, cùi bắp gì cũng được, miễn làm cho test pass là được. Điều quan trọng nhất là bạn cần viết code thật đơn giản, mà implement được phần code của mình. Nói vậy thôi chứ đừng nhớp quá. Dễ đọc, dễ hiểu, dễ thay đổi là được. Đằng nào thì 1 dev muốn lên trình phải viết code cho dễ đọc chứ\r\nThông thường những implement đơn giản thì sẽ không đủ những tính năng mong muốn mặc dù vẫn đủ làm tất cả các test cases pass. **Có nghĩa là bạn cần thêm những test failed khác để đưa đến việc phát triển xa hơn của tính năng đó**\r\n\r\n#### **c. Refactor**\r\nNhư mình đã nói trong phần green, mình chỉ cần viết code đơn giản để cho tất cả các tests pass là được. Đến phần refactor này, là nơi để mình improve code. Remove duplication, xem xét các giá trị common v..v. Refactor code hết mức có thể. Phần test này giúp bạn không bị hư hỏng code trước đó trong khi refactor\r\n\r\n\u003e Đừng bỏ qua phần này. Cố gắng tìm cách improve hết mức có thể sau khi đã implemented 1 feature. Làm như vậy sẽ giúp code clean, dễ maintain và đẹp đẽ.\r\n \r\nSau mỗi lần refactor, bạn có thể chỉ tốn vài dòng code, cho nên việc thay đổi này không tốn nhiều thời gian cho lắm.\r\n\r\n### **2. TDD trong Xcode**\r\nTrong năm 2013, unit testing xuất hiện trong Xcode 5 với việc giới thiệu XCTest. Với XCTest, Apple cho các tính năng cho testing như running 1 vài test mà mình muốn, tìm test fail nhanh, get overview. Ta sẽ đi qua phần testing user interface in Xcode sau. Trước hết, ta sẽ xem qua thử TDD trong Xcode hoạt động như thế nào.\r\n\r\n#### **a. Ví dụ về TDD**\r\n##### **a.1 Nhẩm trước những rule**\r\nTa sẽ lấy app ở part 1, giả sử ta đang làm 1 app blog. Khi viết 1 post mới, phải có title. Mình muốn tất cả các từ ở phần headline phải viết hoa chữ đầu. Để bắt đầu TDD workflow, ta bắt đầu 1 failing test. Ta cần tuân thủ các rule sau:\r\n\r\n\u003e Precondition: Trạng thái ban đầu của hệ thống trước khi gọi hàm là gì ?\r\n\u003e Invocation: Tín hiệu vào và tín hiệu ra như thế nào ?\r\nAssertion: Mong muốn kết quả như thế nào ?\r\n\r\nĐối với ví dụ của mình: \r\n\r\nPrecondition: Không có gì.\r\nInvocation: Input là string và output cũng vậy. Tên method nên là makeHeadline\r\nAssertion: Viết hoa chữ đầu.\r\n\r\nVậy là đã xong, bây giờ ta đi vào hầm 1: Red\r\n\r\n##### **a.2 Red**\r\n**Bước 1**: Add đoạn code sau vào file Test và build:\r\n```\r\nfunc test_MakeHeadline_ReturnsStringWithEachWordStartCapital() {\r\n    let viewController = ViewController()\r\n    let string = \"this is A test headline\"\r\n    let headline = viewController.makeHeadline(from: string)\r\n  }\r\n``` \r\nVà ta sẽ bị lỗi như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gebgukxbb8_Screen%20Shot%202018-05-03%20at%209.42.03%20AM.png)\r\n\r\nĐoạn code này chưa làm được gì, và đương nhiên các bạn cũng thấy error. \r\nTheo như TDD workflow, ta cần thêm code cho đến khi compiler không in ra lỗi nữa. Nên nhớ code không compile được trong 1 test tức là test đang bị fail. Và 1 failing test nghĩa là mình cần code lại đến khi không fail nữa (nghe hơi ngớ ngẩn).\r\n\r\nTa thêm đoạn code sau ở ViewController: \r\n```\r\nfunc makeHeadline(from string: String) -\u003e String {\r\n    return \"\"\r\n  }\r\n```\r\n\r\nVà run lại, thì ok. Đôi khi lỗi vẫn show ra là vì Xcode quên remove errors cũ. Bạn cũng đừng lo, miễn build success là được. Đến lúc này, vẫn bị warning, đó là vì `Một khi đã có test thì phải có XCTAssert`.Thêm vào thôi: \r\n`XCTAssertEqual(headline, \"This Is A Test Headline\")` và build lại.\r\n\r\nCác bạn được như sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/78ez5tqcdg_Screen%20Shot%202018-05-03%20at%2010.09.47%20AM.png)\r\n\r\n- Các bạn có thấy cái fail ở trên không, đừng để ý vì đó do Xcode bị khùng.\r\n- Bởi vì headline ở dưới đã trả về \"\", đúng như bên ViewController, tức là nó có gọi được\r\n-  Như vậy đã đủ để compile. Run test lên -\u003e fail. Nhưng lần này, fail là do Assert chứ không phải do code mình viết sai. Như vậy là đã đáp ứng được yêu cầu của Red. Xong bây giờ qua hầm 2: Green.\r\n\r\n##### **a.3 Green**\r\nNhư đã nói, lỗi do empty string không bằng \"This Is A Test Headline\". Theo như TDD workflow, ta cần back lại phần implementation và add 1 dòng code đơn giản nhất để làm cho nó pass.\r\n\r\nQua bên ViewController, thay makeHeadline(from:) như sau:\r\n```\r\n   func makeHeadline(from string: String) -\u003e String {\r\n     return \"This Is A Test Headline\"\r\n}\r\n```\r\nHard-code, đương nhiên chẳng ai làm vậy nhưng nó làm cho test pass. Từ nó mình cần thêm những test khác. Ok, Run test lại, kết quả như sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/nho229ht6j_Screen%20Shot%202018-05-03%20at%2010.19.24%20AM.png)\r\n\r\nHầm hai này có vẻ dễ ta. Qua hầm cuối: Refactor.\r\n\r\n##### **a.4 Refactor**\r\nTrước khi viết thêm test cases, ta cần refactor những thằng tồn tại đã. Trong phần **production code (tức là code ở trong ViewController)**, không có gì để refactor, ko thể đơn giản hơn. Trong phần **test code (tức là code trong phần test)**, ta để ý có 2 test case và lặp lại `let viewController = ViewController()` -\u003e có việc để làm rồi!!\r\n\r\nTại nơi khai báo property của Test class, ta khai báo: `var viewController: ViewController!`\r\n\r\nNhớ lại phần đầu mình có nói, setUp() method được gọi mỗi một test được executed. Đây là nơi lý tưởng để initialize property viewController\r\n```\r\n   override func setUp() {\r\n     super.setUp()\r\n     viewController = ViewController()\r\n}\r\n```\r\nBây giờ ta có thể remove `let viewController = ViewController()` khỏi mỗi test cases"
                }, {
                "id": "v2qDv7JCK3bnMWUdx-jusA",
                "title": "Swift - Test-Driven Development (TDD) - Chapter 1 - Part 1b - Unit Test",
                "content": "## Swift - Test-Driven Development (TDD) - Chapter 1 - Part 1b - Unit Test\r\n\r\nTrong phần 1b này, mình sẽ đi qua các XCTAssert 1 chút. Trước hết, ta ôn lại phần 1a một chút. Để check result thì ta sử dụng `XCTAssertEqual(_, _)` để check đúng không ạ? Vậy thì XCTAssert còn gì hay nữa không? \r\n\r\n### **3. Những built-in assert quan trọng:**\r\n#### **a. Các XCTAssert**\r\n- XCTAssertTrue(_:_:file:line:): Assert trả về true\r\n- XCTAssertFalse(_:_:file:line:): Assert trả về true\r\n- XCTAssertEqual(_:_:_:file:line:): Assert so sánh bằng\r\n- XCTAssertEqualWithAccuracy(_:_:accuracy:_:file:line:): Assert so sánh 2 biểu thức như nhau hay không, có tính đến độ chính xác được defined trong parameter\r\n- XCTAssertNotEqual(_:_:_:file:line:): So sánh hai vế không bằng\r\n- XCTAssertNil(_:_:file:line:): Assert trả về nil\r\n- XCTAssertNotNil(_:_:file:line:): Assert trả về không phải là nil\r\n- XCTFail(_:file:line:): Assert luôn fail\r\n\r\n#### **b. Lưu ý khi sử dụng:**\r\nLưu ý rằng khi sử dụng các Assert thì ta có rất nhiều sự lựa chọn nhưng bạn nên **sử dụng các assertions càng rõ ràng càng tốt**. Lý dó là log khi bạn fail sẽ nó cho bạn chính xác cái gì đã xảy ra. Để mình ví dụ nha: \r\n```\r\nXCTAssertEqual(2, 1, \"DuyBui\")\r\n   // Output:\r\n   // XCTAssertEqual failed: (\"2\") is not equal to (\"1\") - foo\r\n``` \r\n```\r\nXCTAssertTrue(2 == 1, \"DuyBui\")\r\n   // Output:\r\n   // XCTAssertTrue failed - bar\r\n```\r\n\r\nTrong 2 trường hợp, trường hợp 1 là ta nhìn vào biết tại sao nó fail luôn, còn trường hợp 2 thì không. Lưu ý, tham số thứ 3 của 2 trường hợp đều là Optional.\r\nNếu code của bạn đã quá clear rồi, bạn không cần phải thêm phần message này.\r\n#### **c. Log và debug:**\r\nTrong trường hợp fail ở part 1, ta xem phần log của nó như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/crevbamaop_Screen%20Shot%202018-05-02%20at%205.30.58%20PM.png)\r\n\r\nOutput đã chỉ ra file và line mà test case bị failed. Đó là; `/Users/duybui/Desktop/AccessControl/TestDriver(TDD)/TestDriver(TDD)Tests/TestDriver_TDD_Tests.swift` và `18`. Ta có thể điều chỉnh để cho log dễ nhìn hơn như sau: \r\n\r\n```\r\nXCTAssertEqual(numberOfVowels, 3,\r\n\"should find 3 vowels in BuiKhanhDuy\", \r\nfile: \"TestDriver_TDD_Tests.swift\", \r\nline: 18)\r\n```\r\nKhi đó log cho ra sẽ dễ chịu hơn: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ev5xxetkdq_Screen%20Shot%202018-05-02%20at%205.40.10%20PM.png)\r\n\r\nOK, như vậy ta đã xong phần Unit Test, chuẩn bị qua phần tiếp theo, là trọng tâm của loạt bài này: TDD"
                }, {
                "id": "UO7aYP66tp9UKZr0_WfGXg",
                "title": "Swift - Test-Driven Development (TDD) - Chapter 1 - Part 1a - Unit Test",
                "content": "## Swift - Test-Driven Development (TDD) - Chapter 1 - Part 1a - Unit Test\r\n\r\nPhần này mục đích mình sẽ tập trung vào việc giúp mọi người làm quen với unit test. Và chắc chắn cũng có Test-Driven Development (TDD) nơi mà phần test được viết trước khi implement code. \r\n\r\n###**1. Xây dựng Automatic unit test:**\r\n\r\nAutomatic unit test giống như Automation Testing vậy. Nó execute code mà không cần navigate đến màn hình đó để test. Các bạn tạo 1 project như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hkn2dubaye_Screen%20Shot%202018-05-02%20at%202.38.02%20PM.png)\r\n\r\nRồi vào thư mục test, các bạn sẽ thấy có 2 file sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/howvad81ru_Screen%20Shot%202018-05-02%20at%202.40.13%20PM.png)\r\n\r\n####**a. Phân tích tổng thể**\r\n\r\nCái bạn thấy ở đây là 1 test case. 1 test case là 1 class bao gồm nhiều phần tests nhỏ.  Mỗi test case cần import XCTest framework. Nó sẽ define class XCTestCase và phần test assertions mà mình sẽ nói ở phần sau.\r\n\r\nDòng thứ hai import module - chính là nơi mà các bạn code ra app. \r\n\u003e Mặc định: class, struct, enum và các method là internal. \r\n\r\nĐể nắm rõ phần này, các bạn nên xem lại Access Control ở đây. Điều này có nghĩa chúng có thể được accessed bên trong module trong khi code test ở bên ngoài module. \r\n\r\nĐể có thể viết code test, các bạn thêm keyword @testable, keyword này làm cho các elements internal của module có thể truy cập được vào test case.\r\n\r\nCác bạn xem hình sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/74x7ucv7mv_Screen%20Shot%202018-05-02%20at%202.42.48%20PM.png)\r\n\r\n####**b. Phân tích bên trong code:**\r\n**b1. setUp()**\r\n```\r\noverride func setUp() {\r\n       super.setUp()\r\n       // Put setup code here. This method is called ...\r\n}\r\n```\r\nĐây là method được gọi **TRƯỚC** khi run từng test method trong class. Ở đây các bạn có thể set up những code nên run trước khi chạy mỗi test-case\r\n\r\n**b2. tearDown()**\r\n```\r\noverride func tearDown() {\r\n       // Put teardown code here. This method is called ...\r\n       super.tearDown()\r\n}\r\n```\r\nNgược lại với setUp, đây là method được gọi **SAU** khi run từng test method trong class. Ở đây các bạn có thể set up những code nên run sau khi chạy mỗi test-case như clean up data hay gì đó.\r\n\r\n**b3. testExample()**\r\n```\r\nfunc testExample() {\r\n       // This is an example of a functional test case.\r\n       // Use XCTAssert and related functions to verify your ...\r\n}\r\n```\r\nĐây là method để test bình thường, mình sẽ đi sâu method này rất nhiều.\r\n\r\n**b4. testPerformanceExample**\r\n```\r\nfunc testPerformanceExample() {\r\n       // This is an example of a performance test case.\r\n       self.measure {\r\n         // Put the code you want to measure the time of here.\r\n       }\r\n}\r\n```\r\nĐây là method về performance. Nó được sử dụng để test method hay function mà liên quan đến thời gian tối đa cho phép (time-critical computations). Code mà bạn để trong `self.measure` sẽ được gọi 10 lần và thời gian trung bình sẽ được tính toán. Performance test có thể hữu ích khi ta implement hay improve một thuật toán phức tạp nào đó và đảm bảo là performance của nó không bị giảm.\r\n\r\n###**2. Implement Test đầu tiên:**\r\n\u003e Điều trước tiên các bạn cần nhớ là phải có prefix `text`, nếu không Swift sẽ không tìm thấy chúng. Đây cũng là một trong những cách disable test, remove prefix `text` này, bên cạnh những cách khác sẽ đề cập sau.\r\n\r\n**Bước 1:**\r\nChèn đoạn code sau vào ViewController như trong hình: \r\n```\r\nfunc numberOfVowels(in string: String) -\u003e Int {\r\n     let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\",\r\n                                \"A\", \"E\", \"I\", \"O\", \"U\"]\r\n     var numberOfVowels = 0\r\n     for character in string {\r\n       if vowels.contains(character) {\r\n         numberOfVowels += 1\r\n\t\t} \r\n\t}\r\n\treturn numberOfVowels\r\n}\r\n```\r\nMình chỉ note 1 chút là ta cần có [Character], nếu không sẽ bị lầm sang [String]. Còn logic code chắc mọi người đọc cũng dễ hiểu. \r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/rpa6eox2ii_Screen%20Shot%202018-05-02%20at%204.03.52%20PM.png)\r\n\r\n**Bước 2:**\r\nQua bên file Test.swift, add 1 func như sau: \r\n```\r\nfunc test_NumberOfVowels_WhenPassedBuiKhanhDuy_ReturnsFour() {\r\n     let viewController = ViewController()\r\n     let string = \"BuiKhanhDuy\"\r\n     let numberOfVowels = viewController.numberOfVowels(in: string)\r\n     XCTAssertEqual(numberOfVowels, 4,\r\n                    \"should find 4 vowels in BuiKhanhDuy\")\r\n}\r\n```\r\nỞ đây, mình đã tạo một instance của ViewController và define 1 chuỗi string để dùng test\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/p4q8zm9wh5_Screen%20Shot%202018-05-02%20at%204.08.16%20PM.png)\r\n\r\n**Bước 3:**\r\nVào Product/ Test hoặc Command+U, nếu pass, các bạn sẽ thấy kiểu như: \r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ru69khtn5i_Screen%20Shot%202018-05-02%20at%204.11.48%20PM.png)\r\n\r\nCó check mark màu xanh ở phía trước. Ngoài ra, các bạn để ý time: 0.000 sec của phần performanceTest, nó tính toán thời gian trung bình thực hiện phần bên trong `self.measure` (hiện tại chẳng có gì) rồi chia cho 10 ra được kết quả.\r\n\r\nNếu fail thì sao:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/bnp33gdsen_Screen%20Shot%202018-05-02%20at%204.14.46%20PM.png)\r\n\r\nThì như trên, nó sẽ báo testcase nào bị fail, nguyên nhân thất bại và ý nghĩa lịch sử ^^ (đùa chút)\r\n\r\nTrước khi mình qua phần tiếp, mình refactor code 1 chút: \r\nThay đoạn code numberOfVowels(in:) bằng đoạn code sau: \r\n```\r\nfunc numberOfVowels(in string: String) -\u003e Int {\r\n     let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\",\r\n                                \"A\", \"E\", \"I\", \"O\", \"U\"]\r\n     return string.characters.reduce(0) {\r\n       $0 + (vowels.contains($1) ? 1 : 0)\r\n\t} \r\n}\r\n```\r\nTheo định nghĩa của Apple, phần reduce được khai báo như sau:\r\n`func reduce\u003cResult\u003e(_ initialResult: Result, _ nextPartialResult: (Result, Character) throws -\u003e Result) rethrows -\u003e Result`\r\nĐoạn refactor này cũng khá dễ hiểu, cho nên mình không giải thích nhiều. Nếu bạn nào thắc mắc thì comment nha.\r\n\r\nNhư vậy, Product/ Test lại nó sẽ work như bình thường. \r\n\r\nTài liệu tham khảo: Ebook test-driven-ios-development-swift-4-3rd.pdf\r\n"
                }, {
                "id": "TUnt-VHNswAsq3kMaH3rgA",
                "title": "Swift - Custom operators - Part 2",
                "content": "## Swift - Custom operators - Part 2\r\n\r\nỞ Part 1: https://kipalog.com/posts/Swift---Custom-operators---Part-1, mình đã giới thiệu cơ bản về operator và cách custom nó. Trong phần 2 này mình sẽ đi sau tìm hiểu thêm 1 số phần khác nâng cao hơn chút. \r\n\r\n**1. Generic Operators**\r\nBây giờ mình muốn phép luỹ thừa apply cho toàn bộ các loại Integer. Code như sau, cũng khá dễ hiểu: \r\n```\r\nfunc **\u003cT: Integer\u003e(lhs: T, rhs: Int) -\u003e T {\r\n  var result = lhs\r\n  for _ in 2...rhs {\r\n    result *= lhs\r\n  }\r\n  return result\r\n}\r\nfunc **=\u003cT: Integer\u003e(lhs: inout T, rhs: Int) {\r\n  lhs = lhs ** rhs\r\n}\r\n```\r\nChú ý đến Integer type constrain. Cái ràng buộc cần có bởi vì dòng code: có operator *= không phải loại nào cũng dùng được, phải conform Integer Type mới dùng được. Bây giờ ta test thử với các loại Integer khác nhau: \r\n```\r\nlet unsignedBase: UInt = 2\r\nlet unsignedResult = unsignedBase ** exponent\r\n\r\nlet base8: Int8 = 2\r\nlet result8 = base8 ** exponent\r\n\r\nlet unsignedBase8: UInt8 = 2\r\nlet unsignedResult8 = unsignedBase8 ** exponent\r\n\r\nlet base16: Int16 = 2\r\nlet result16 = base16 ** exponent\r\n\r\nlet unsignedBase16: UInt16 = 2\r\nlet unsignedResult16 = unsignedBase16 ** exponent\r\n\r\nlet base32: Int32 = 2\r\nlet result32 = base32 ** exponent\r\n\r\nlet unsignedBase32: UInt32 = 2\r\nlet unsignedResult32 = unsignedBase32 ** exponent\r\n\r\nlet base64: Int64 = 2\r\nlet result64 = base64 ** exponent\r\n```\r\n\r\nNhư vậy, nó đúng cho tất cả các loại integer: Int, UInt, Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64 and UInt64. Int/ UInt/ Int8 là gì các bạn tự tìm hiểu thêm nha. \r\n\r\n**2. Precedence and associativity**\r\nNếu chỉ có 2 giá trị thì khá đơn giản nhưng nếu là đoạn code sau thì sao: \r\n```\r\n2 * 2 ** 3 ** 3 // không thể compile\r\n```\r\n\r\nSwift không thể compile được nếu thiếu các thông tin sau đây: \r\n- Độ ưu tiên (precedence): Phép nào trước phép nào, nhân trước hay luỹ thừa trước.\r\n- Độ kết hợp (associativity): Từ trái qua phải trước hay từ phải qua trái trước.\r\n\r\nNếu không có 2 thông tin trên thì có 1 cách duy nhất để Swift hiểu và compile, đó là quăng vào dấu ngoặc đơn: \r\n```\r\n 2 * (2 ** (3 ** 2))\r\n```\r\n\r\nĐể tránh khỏi sự phiền hà, ta chỉ cần define ra precedence group như sau: \r\n```\r\nprecedencegroup ExponentiationPrecedence {\r\n  associativity: right\r\n  higherThan: MultiplicationPrecedence\r\n}\r\ninfix operator **: ExponentiationPrecedence\r\n```\r\nCái mà mình define ở trên là ưu tiên phép luỹ thừa trên phép nhân (**MultiplicationPrecedence**), và phép tính sẽ là từ phải sang trái (**associativity: right**). Bây giờ thì Swift có thể compile mà không cần thêm gì nữa. \r\n\r\nNhư vậy, qua 2 phần, mình đã giới thiệu thêm cho các bạn cụ thể về Custom Operators. Hi vọng các bạn có thêm được phần kiến thức bổ ích cho mình. "
                }, {
                "id": "cAEuiZC3LzctODWRv8m7wA",
                "title": "Swift - Custom operators - Part 1",
                "content": "##Swift - Custom operators - Part 1\r\n\r\nTrong phần này, các bạn sẽ được tự chế tạo operator cho riêng mình. Nó sẽ biểu diễn cho 1 loạt function phức tạp lặp đi lặp lại nhiều lần. Ví dụ nếu bạn có phép tính 2 nhân 2 nhân 2 v..v thì tại sao không có phép tính luỹ thừa cho gọn. Trước tiên, mình nên làm 1 type cố định rồi khi nào quen rồi mình mở rộng bằng cách dùng generic. \r\n\r\n**1. Lý thuyết về các loại toán tử:**\r\n\r\na. Toán tử một ngôi (unary): được dùng với duy nhất 1 toán hạng hay một tiền tố. Chỗ này mình phân tích thêm chút, nó bao gồm:\r\n+ Postfix: Những toán tử đứng sau, hay gặp nhất là a!, b?\r\n+ Prefix: Những toán tử đứng trước ví dụ như !true, ++a\r\n\r\nb. Toán tử hai ngôi (binary): được dùng với 2 toán hạng. Các toán tử +, -, x , % , hay toán tử so sánh ==, !== hay logic \u0026\u0026, || đều thuộc về phần này.\r\n+ Infix là một tên gọi khác của toán tử 2 ngôi này, vì nó nằm giữa.\r\n\r\nc. Toán tử ba ngôi (ternary): được dùng với 3 toán hạng. Chắc các bạn còn nhớ đến toán tử điều kiện ? chứ. ví dụ: (a == b ? true : false). \r\n\r\n1.Ví dụ: Toán tử luỹ thừa\r\nĐặt toán tử luỹ thừa là dạng toán từ mà mình tự custom, nên ta chọn đặt tên thoải mái. Cách đặt thường là sẽ kết hợp các ký tự đặt biết mà phải có ý nghĩa 1 chút. Ví dụ, luỹ thừa là nhiều phép nhân, nên ta đặt: ** hoặc các bạn đặt là ^ cũng được. \r\n\r\n\u003e Swift không cho phép ta custom ternary operator\r\n\r\nCái ta có thể custom là các phần còn lại như prefix, postfix, infix. Phép luỹ thừa là cần đến 2 toán hạng nên ta dùng infix. Code như sau:\r\n```\r\ninfix operator **\r\n\r\nfunc **(lhs: Int, rhs: Int) -\u003e Int {\r\n  var result = lhs\r\n  for _ in 2...rhs {\r\n    result *= lhs\r\n  }\r\n  return result\r\n}\r\n```\r\n\r\ninfix: dạng type của operator cần custom\r\noperator: keyword\r\n**: cái mình muốn tạo ra\r\ntiếp theo là func mà mình muốn định nghĩa cho phép nhân đó. Một lưu ý các bạn để ý đến đoạn result *= lhs, cũng là một phép nhân rồi gắn, kiểu kiểu như custom operator nhưng được Swift tạo ra trước đó. \r\n\r\nNote: Mình sẽ dùng wildcard pattern để discard những giá trị loop bằng kỹ thuật \"Pattern Matching\". Các bạn xem thêm ở đây.\r\n\r\nBây giờ, test thử code:\r\n```\r\nlet base = 2\r\nlet exponent = 2\r\nlet result = base ** exponent\r\n```\r\n\r\n**2. Toán tử kết hợp với phép gắn:**\r\nNhư mình đã lưu ý ở phần trên, thì mọi operator mình làm thì thường phải có thêm phần compound assignment (kết hợp luôn phép gắn). Xem phần code sau:\r\n```\r\ninfix operator **=\r\nfunc **=(lhs: inout Int, rhs: Int) {\r\n  lhs = lhs ** rhs\r\n}\r\n```\r\nMột trong những phần hay mình sẽ phân tích ở đây. Nếu như mình làm bình thường sẽ như ở trên, tức là var result -\u003e xử lý code -\u003e gán lại cho result. Nhưng ở đây mình sẽ dùng inout keyword. Inout là gì, cách dùng như thế nào, các bạn xem [ở đây](https://kipalog.com/posts/Swift--Cach-su-dung-Inout). \r\n\r\nNhư vậy, bằng việc dùng inout, ta lấy được giá trị sau cùng. Func sẽ thay đổi inout parameter trực tiếp bởi vì nó được truyền thông qua reference.\r\n\r\nĐây là thành quả:\r\n```\r\n var number = 2\r\nnumber **= exponent\r\n```\r\n\r\n**3. Thách đố nhỏ**\r\n\r\nBây giờ mình muốn tạo 1 operator mà 2 argument truyền vào là string và số lần. Qua phép nhân đó, sẽ nhân số string lên n lần. Ví dụ: \r\n```\r\nlet baseString = \"abc\"\r\nlet times = 5\r\nvar multipliedString = baseString ** times\r\n```\r\n\r\nGiúp mình với nhé ;) \r\n\r\nTiếp theo mình sẽ đi qua phần hai, những phần Advance hơn về Custom Operator. \r\nPart 2: https://kipalog.com/posts/Swift---Custom-operators---Part-2\r\n\r\nTài liệu tham khảo: Ebook Swift_Apprentice_v2.0"
                }, {
                "id": "oCQx2yLs50KFti7BWRM78A",
                "title": "Swift: Cách sử dụng Inout ",
                "content": "## Swift: Cách sử dụng Inout \n\n**1.Mở đầu**\nNhư các bạn đã biết về cách sử dụng return function, ví dụ:  cho 2 tham số, trả về tổng của chúng. \nThông thường, mình không muốn 1 hàm thay đổi các tham số của nó, bởi vì nếu làm vậy, bạn có thể không nắm chắc được giá trị của parameters và sẽ làm sai lệch các logic code của bạn trong hàm, dẫn đến data output bị sai. \n\nTuy nhiên, đôi khi bạn cũng muốn 1 function thay đổi các parameter trực tiếp, đó là phần Inout (hay copy-in copy-out).\n\n**2.Cách dùng**\nCác bạn code như sau:\n```\nfunc incrementAndPrint(_ value: inout Int) {\n  value += 1\n  print(value)\n}\n```\nfunc code như bình thường nhưng thêm Inout trước phần mà các bạn khai báo Type. Và khi gọi ra thì nó cũng có 1 chút khác biệt khi truyền vào argument:\n```\nvar value = 5\nincrementAndPrint(\u0026value)\nprint(value)\n```\n\nYeah, đó là thêm \u0026 trước arguments, cái này sẽ làm rõ việc gọi lúc đó là các bạn đang dùng copy-in copy-outout. Kết quả là 6 như expected.\n\nSử dụng Inout sẽ giữ lại giá trị đã thay đổi sau khi func kết thúc. Trong nhiều điều kiện nhất định, compliler có thể đơn giản hoá việc sao chép này thông qua tham chiếu (pass-by-reference). \n\n\u003e Argument sẽ không được copied vào parameter. Thay vào đó, parameter sẽ chỉ giữ tham chiếu đến ô nhớ của giá trị gốc. Việc tối ưu hoá này sẽ đáp ứng những yêu cầu của việc sao chép trong khi việc xoá bỏ giá trị cũ cần phải tạo những bản sao. \n\nĐể thấy thêm những ví dụ cụ thể khác, và những tình huống áp dụng khác. Các bạn xem thêm ở đây."
                }, {
                "id": "8CRedu4K-1ZVPymaJzdd-g",
                "title": "Autolayout và lifecycle trong IOS",
                "content": "## Autolayout và lifecycle trong IOS\r\n\r\n### **1. Lý thuyết:**\r\n\r\nTrước hết, mình xin nói về một vài life-cycle trong swift để mọi người nhớ lại. Một câu hỏi phổ biến là **khi nào** ghi override viewDidLayoutSubviews, viewDidLoad và viewWillAppear. \r\n\r\n#### **a. viewDidLoad:**\r\n\r\n- viewDidLoad được gọi sau khi View Controller đã load cấu trúc cơ bản (hierarchy) vào bộ nhớ từ XIB hay Storyboard\r\n-  **khi phần viewDidLoad được gọi, bạn hiểu là các IBOutlet, IBAction đã được kết nối, ngoài ra view chưa được vẽ trong lúc này**\r\n- viewDidLoad sẽ không được gọi lại một khi đã load lên và add vào trong 1 navigation stack.\r\n- viewDidLoad được dùng để configure những gì mà bạn không configure trong XIB hoặc trong Storyboard.\r\n\r\n#### **b. viewWillAppear:**\r\n- viewWillAppear được gọi để báo rằng viewController đã sẵn sàng cho việc hiển thị lên màn hình. \r\n- override method khi bạn muốn **setup những func mà bạn muốn VC thực hiện mỗi lần nó hiển thị, ví dụ như là deselected row v..v**\r\n\r\n#### **c. viewDidLayoutSubviews:**\r\n- Khi thay đổi bounds (ví dụ như thay đổi kích cỡ simulator hay xoay dọc/ ngang), **method này sẽ được gọi sau khi có tín hiệu báo là vị trí (position) và kích cỡ (size) của subviews đã thay đổi.**\r\n- Đây là nơi mà ta sẽ setup layout lại cho subviews, trước khi nó xuất hiện trên màn hình\r\n- **Bất cứ điều gì phụ thuộc vào bounds cần được thực hiện ở viewDidLayoutSubviews**\r\n- Bởi vì frame và bounds của 1 view sẽ không được finalized cho đến khi AutoLayout làm xong hết việc layout cho view và subviews.\r\n\r\n#### **d. Tổng kết**\r\n\u003e\r\nTóm lại: Quy trình như sau: \r\n1. Nó sẽ tạo ra các connections\r\n2. Nó tô màu, tạo các tính chất cho UI\r\n3. Autolayout các UI\r\n4. Check thử các bounds có bị khác so với khi thiết kế không,\r\nnếu có thì co giãn theo design\r\n\r\n### **2. Tình huống thực tế:**\r\na. Tình huống 1:\r\nGiả sử mình có 1 button. Width/ Height = 50 trên Regular, và 25 trên Compact. Sẽ dùng code để cho Button thành hình tròn. \r\n\r\nMình đi theo 2 bước: \r\n1. Autolayout trên storyboard\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/p9v71wgk7o_Screen-Shot-2015-09-28-at-9.33.01-PM.png)\r\n2. Code thành hình tròn: \r\n\r\n`func configureButton()\r\n    {\r\n       \t editButton.layer.cornerRadius = 0.5 * editButton.bounds.size.width\r\n        editButton.layer.borderWidth = 2.0\r\n        editButton.clipsToBounds = true\r\n    }`\r\n\r\nFunc này chỉ được gọi 1 khi mà bounds của button được biết. Nếu để func này ở viewDidLoad hay viewWillAppear thì sẽ không hiển thị hình tròn mà chỉ có width height được design. **Vì code đã được gọi trước khi bounds được set**. Chỉ khi để func trong viewDidLayoutSubViews()\r\n\r\nb. Tính huống 2: \r\nKhi sử dụng CollectionView, mình thường có các func điều chỉnh Edge để tránh các tính trạng Padding Bottom hay Padding Top. \r\nNếu đặt func trong các viewDidLoad hay viewWillAppear thì nó sẽ được apply/ work đúng trên các màn hình lớn hơn màn hình thiết kế. Khi đưa xuống các màn hình nhỏ hơn nó sẽ bị sai lệch đi. Với các lý do đã phân tích ở trên, ta nên để các func điểu chỉnh liên quan đến Edge, Bounds ở viewDidLayoutSubViews().\r\n\r\nNguồn: \r\nhttp://www.iosinsight.com/override-viewdidlayoutsubviews/\r\n\r\nhttps://stackoverflow.com/questions/36125101/when-the-autolayout-constraints-set-frames-during-view-controller-life-cycle\r\n\r\nhttps://iosprogrammingknowledge.blogspot.com/2016/03/van-e-autolayout-chua-uoc-load-o.html"
                }, {
                "id": "c5VxGgqIAEtJZlodt966yg",
                "title": "Swift - Closure: Bài 2: CallBack/ Completion (Part 2)",
                "content": "## Swift - Closure: Bài 2: CallBack/ Completion (Part 2)\r\n\r\n***3. Closure with arguments***\r\nDữ liệu của ta thường là các kiểu của Networking service, không phải kiểu đơn giản load file local json như bài 1, mà là nhận API, rồi lấy data từ đó, mặc dù nói chung vẫn trả về kiểu json tương tự. \r\nChúng ta bắt đầu pass data ở đây thông qua completion của ta. Ta có thể cho thêm arguments vào bên trong completion closure. Và ta thêm như sau: \r\n```\r\n  func getPeople(completion: (Bool, Any?, Error?) -\u003e Void) {\r\n    guard let path = Bundle.main.path(forResource: \"someJson\", ofType: \"json\") else { return }\r\n    let url = URL(fileURLWithPath: path)\r\n    do {\r\n      let data = try Data(contentsOf: url)\r\n      let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers)\r\n      guard let array = json as? [[String: Any]] else { return }\r\n      var names = [String]()\r\n      for user in array {\r\n        guard let name = user[\"name\"] as? String else { continue }\r\n        names.append(name)\r\n      }\r\n//      print(names)\r\n      completion(true, names, nil)\r\n    } catch {\r\n      print(error)\r\n      completion(false, nil, error)\r\n    }\r\n  }\r\n```\r\nĐể ý dòng code đầu, `getPeople(completion: (Bool, Any?, Error?) -\u003e Void)`, biến đầu tiên sẽ là Bool, biến thứ hai sẽ là Any? và cuối cùng là Error? - cũng là 1 optional. Tức là khi bạn gọi completion, bạn phải truyền giá trị vào cho mỗi chú, bắt buộc. VÌ không thể gọi 1 function mà không truyền giá trị tương ứng.\r\n\r\nTrong đoạn chỗ **do**, ta chắc chắn khi nó load phần này thì nó đã thành công, và ta sẽ đặt true, và thông tin ta cần pass đến nơi mà gọi function này là mảng names, cho nên ta đặt names, và đương nhiên như đã nói ở trên, phần này không có error, nên ta trả về nil.\r\n\r\nTa làm tương tự cho phần dưới, trong catch block, nó sẽ false và ta chẳng có data nào muốn chuyển trong phần nào cả, cái thông tin ta cần lấy ở đây chính là error mà được gen automatically bởi catch block nào. Bây giờ comment getPeople đang có hiện tại và type getPeople, bạn sẽ thấy như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/237l3jd05p_Screen%20Shot%202018-02-25%20at%2010.47.41%20PM.png)\r\n\r\nBấm ok, thì nó sẽ ra code bên trong với các argument name, ta rename lại chúng và sử dụng chúng, đặt tên gì cũng được hết, nên ta đặt như sau: \r\n```\r\ngetPeople { (success, response, error) in\r\n      \r\n    }\r\n```\r\nThực ra bạn đặt gì cũng được nhưng đây là general practice, nên làm theo, h ta cần làm là nếu success == true thì nhận/ xử lý data, không thì xem error là gì\r\n```\r\ngetPeople { (success, response, error) in\r\n      if success {\r\n        guard let names = response as? [String] else { return }\r\n        print(names)\r\n      } else {\r\n        if let error = error {\r\n          print(error)\r\n        }\r\n      }\r\n```\r\nNhìn dễ hiểu hơn đúng không mọi người, ta sử dụng những values ở đây dựa trên cái mà được chuyển đến.\r\nĐối với success, the response chính là names array mà ta vừa chuyển đến, là String array, nhưng mà ta rõ ràng ta vẫn không biết vì ta ném nó vào completion handler, do đó nó là Any Object, muốn dùng thì phải down cast nó xuống.\r\nĐối với error thì đó là error từ khối catch block mà ta đã có được. Lưu ý ở đây cả hai phần response, error đều đang là optional nên ta unwrap nó bằng cách chaining. Bạn có thể nil-coalescing hoặc force.\r\n\r\nNhư đã nói, phần getPeople này sẽ nằm ở phần khác chứ không phải ngay chính VC này, nên tất cả những thông tin này sẽ được xử lý và ném qua completion handler"
                }, {
                "id": "rOxl8A2XINbi4hrj8ciNxA",
                "title": "RxSwift: cách truy cập giá trị trước và sau khi biến đổi bằng flatMap",
                "content": "Sử dụng `flatMap`, ta có thể sử dụng được các giá trị đã qua phép biến đổi:\n```swift\nfunc getAfterObservable(before: Int) -\u003e Observable\u003cInt\u003e {\n    return Observable.of(before + 1)\n}\n\nlet before = 1\nlet bag = DisposeBag()\n\nObservable.of(before)\n    .flatMap { getAfterObservable(before: $0) }\n    .subscribe( onNext: { after in\n        print(\"after: \\(after)\")\n    })\n    .disposed(by: bag)\n```\nOutput:\n```\nafter: 2\n```\n\nMuốn dùng cả giá trị trước phép biến đổi, sửa lại như sau:\n```swift\nObservable.of(before)\n    .flatMap { before in getAfterObservable(before: before).map { after in (before, after) } }\n    .subscribe( onNext: { before, after in\n        print(\"before: \\(before)\")\n        print(\"after: \\(after)\")\n    })\n    .disposed(by: bag)\n```\nOutput:\n```\nbefore: 1\nafter: 2\n```\n\nỨng dụng: trong trường hợp muốn xử lý cả request và response của API cùng một lúc...\n\n13thang08 20-04-2018"
                }, {
                "id": "zWVNF8_XPU5LECQn-9lBBg",
                "title": "Swift - Closure: Bài 2: CallBack/ Completion (Part 1)",
                "content": "## Swift - Closure: Bài 2: CallBack/ Completion (Part 1)\r\n\r\nTrước khi mình vào bài này mình xin giới thiệu các bài 1 nguồn học Swift cực kì hay, đó là Kilo loco youtuber. Các bạn có thể search.\r\n\r\n**1. Đặt chủ đề**\r\nVào chủ đề, callback functions trong Swift và cách sử dụng chúng khi làm việc ở background thread. Mình sẽ nói rõ toàn bộ callback functions (completion handlers) hoạt động như thế nào và tại sao nên dùng chúng, cách đảm bảo completion handler được hoạt động trên main thread.\r\n\r\nCallbacks là phần chính khi làm việc với networking như URLSession hay Alamofire v..v, nhưng bạn cần có 1 vài kiến thức về cách hoạt động của các thread và tại sao trả về main queue lại quan trọng. Mình sẽ tạo 1 app khá đơn giản, load dữ liệu data lên tableView. Note trước, mình sẽ tạo 1 file JSON với data JSON tự tạo, các bạn tự tạo 1 file JSON nhé, có id, name, vài thuộc tính nhỏ nhỏ.\r\n\r\n**2. Callback/ Completion không tham số**\r\nBước 1: Để đi nhanh, mình tạo tableView và setup cell cho nó dựa trên 1 mảng String. Phần này dễ mình không đề cập nhiều. Các bạn có thể xem sơ qua:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/8i7ltw48l7_Screen%20Shot%202018-02-25%20at%206.05.43%20PM.png)\r\nBây giờ ta cần load dữ liệu từ data lên, phần load JSON mình cũng đã có viết rất nhiều cách load json. Các bạn có thể vào facebook Chia Sẻ Swift để xem kĩ hơn.\r\n\r\nBước 2: Load dữ liệu từ file JSON lên, phần này mình chỉ show lại code:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/taizm2piuv_Screen%20Shot%202018-02-25%20at%206.27.20%20PM.png)\r\n\r\nNào bây giờ run thử và ta thấy dữ liệu json đã được trả về:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/x7td7jsq7e_Screen%20Shot%202018-02-25%20at%206.28.53%20PM.png)\r\n\r\nBây giờ ta chỉ muốn lấy name của các phần tử trong list json trả về, code như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/f7384n4qhr_Screen%20Shot%202018-02-25%20at%206.47.05%20PM.png)\r\n\r\nKết quả sẽ là: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ycmk9ufna5_Screen%20Shot%202018-02-25%20at%206.47.27%20PM.png)\r\n\r\n**OK BẮT ĐẦU**\r\nBây giờ ta vào phần callback, callback là gì? Đó là một closure, được dùng như một parameter trong main function của bạn. Khi bạn gọi closure đó bên trong function của bạn, nó cho phép bạn viết nhiều code hơn tại nơi bạn thực sự sử dụng nó. Bạn thấy rối chưa chứ mình thấy rối rồi đó. Mình sẽ giải thích rõ hơn khi code. \r\n\r\nTa muốn có những cái tên này được truyền qua qua đây (tại VC này) đến mảng names của mình. Nhưng vấn đề là thường đoạn này không nằm bên trong VC này như đoạn code này. *Xin lỗi mọi người, đây là 1 bad practice nếu xử lý networking, coi như mình nợ, mình sẽ có practice tốt hơn ở bài 3.* Thường đoạn xử lý code này thường nằm ở file khác (thường là Service or ViewModel) mà ta không có ở đây. Thông thường, bạn sẽ dùng callback, **callback thì nó cũng kiểu như completion, nếu các bạn thấy trong phần networking mà có completion thì các bạn hiểu đó là callback**\r\n\r\nNên ta sẽ cứ làm theo những gì các tiền bối đã làm, same thing, same pattern, và truyền vào hàm getPeople() một parameter là 1 closure, đặt tên là completion như sau: \r\n```\r\nfunc getPeople(completion: () -\u003e Void) {\r\n    guard let path = Bundle.main.path(forResource: \"someJson\", ofType: \"json\") else { return }\r\n    let url = URL(fileURLWithPath: path)\r\n    do {\r\n      let data = try Data(contentsOf: url)\r\n      let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers)\r\n      guard let array = json as? [[String: Any]] else { return }\r\n      var names = [String]()\r\n      for user in array {\r\n        guard let name = user[\"name\"] as? String else { continue }\r\n        names.append(name)\r\n      }\r\n//      print(names)\r\n      completion()\r\n    } catch {\r\n      print(error)\r\n    }\r\n  }\r\n```\r\nCác bạn để ý 2 dòng code sau:\r\n\u003e func getPeople(completion: () -\u003e Void)\r\n\r\nvà\r\n\u003e //      print(names)\r\n      completion()\r\n\r\nCái ta sẽ làm ở đây là truyền vào 1 hàm và không cần trả lại gì hết (chỉ cần print ra thôi). Bây giờ ta call completion() bên trong hàm chính của mình. Và ta gọi lại hàm getPeople ở viewDidLoad(). Lúc ta, viết rara, thì ta có thể thấy nó hiển thị ở autocompletion: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/45jo4aoral_Screen%20Shot%202018-02-25%20at%208.07.19%20PM.png)\r\n\r\nViệc tiếp theo là ta in ra đại 1 chữ gì đó, và xem thử completion working như thế nào: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/dqv0rt9qwo_Screen%20Shot%202018-02-25%20at%208.07.44%20PM.png)\r\n\r\nNó hiển thị Hello world. Ok, mình xin tóm tắt lại như sau: \r\n\r\n\u003eClosure là 1 function được dùng như 1 parameter trong 1 function lớn hơn, mà khi ta dùng function lớn hơn đó, ta có thể code thêm tuỳ ý tại nơi mà ta gọi function lớn đó nhờ vào closure. \r\nỞ ví dụ này, function lớn là getPeople(), nó làm các việc bên trong + completion(). Và khi mình gọi function lớn là getPeople() ở viewDidLoad thì ngoài việc thực các việc bên trong, mình còn có thể thông qua closure completion này để thông báo/ làm cái gì đó (cụ thể là báo pass or fail)\r\n\r\nCó vẻ như hơi nhiều, mình sẽ để phần tiếp theo qua bài 3.\r\n "
                }, {
                "id": "GY8jDAnP_-go_EkoVCNcoA",
                "title": "Swift - Closure: Bài 1: Closure cơ bản",
                "content": "## Swift - Closure: Bài 1: Closure cơ bản\r\n\r\nHôm nay, mình xin đổi gió một chút, để nhân tiện ôn lại phần closure. \r\n\r\n***Closure cơ bản***\r\n**1. Đặt vấn đề**\r\nClosure là gì? Định nghĩa các kiểu thì mình không đề cập nhiều nữa, trên mạng có rồi. Mình sẽ dựa vào những ví dụ thực tế để giải thích ý nghĩa. Tất nhiên mọi thứ mình trình bày là dưới góc nhìn một newbie.\r\n\r\nCác bạn xem ví dụ sau: \r\n```\r\nvar listOfPlayers: [String] = [\"Ozil\",\"Santi\",\"Wilshere\",\"Ramsey\",\"Welbeck\"]\r\nfunc takePenalty(_ player: String) {\r\n    var isReady = false\r\n    isReady = arc4random() % 2 == 0 ? true:false\r\n    if isReady { print(\"Goal of: \\(player)\") }\r\n    else { print(\"Nooo\") }\r\n}\r\nwhile(listOfPlayers.count\u003e0) {\r\n    takePenalty(listOfPlayers.removeFirst())\r\n}\r\n```\r\n\r\nMình làm một ví dụ sau, giả sử trọng tài có 1 phút chuẩn bị (kiểu như kiểm tra lưới, bóng v..v). Nếu trọng tài chuẩn bị xong, mới cho cầu thủ lên thực hiện sút. Như vậy nhìn vào dòng code while(), mình thấy nếu như chuẩn bị xong rồi cầu thủ lên sút, sút xong đi chỗ khác để người tiếp theo lên (removeFirst()). Khá hợp lí, xem kết quả thử:\r\n```\r\nGoal of: Ozil\r\nGoal of: Santi\r\nGoal of: Wilshere\r\nNooo\r\nNooo\r\n```\r\n\r\nNhư vậy sai rồi, các bạn thấy chỗ sai chưa? Mình thấy goài, do listOfPlayers nó cắt phần tử ra, sau đó mới thấy thực hiện phần tử đó trong hàm takePenalty. Nên dù true hay false nó vẫn sẽ cho qua, rồi lấy tiếp phần tử tiếp theo.\r\n\r\n**2. Fix**\r\nBây giờ, các bạn thử đoạn code sau:\r\n```\r\nvar listOfPlayers: [String] = [\"Ozil\",\"Santi\",\"Wilshere\",\"Ramsey\",\"Welbeck\"]\r\nfunc takePenalty(_ player: () -\u003e String) {\r\n    var isReady = false\r\n    isReady = arc4random() % 2 == 0 ? true:false\r\n    if isReady { print(\"Goal of: \\(player())\") }\r\n    else { print(\"Nooo\") }\r\n}\r\nwhile(listOfPlayers.count\u003e0) {\r\n    takePenalty({()-\u003eString in\r\n        listOfPlayers.removeFirst()}\r\n     )\r\n}\r\n```\r\nCác bước như sau: \r\n1.Nếu listOfPlayer lớn hơn không thì thực hiện hàm takePenalty\r\n\r\n2.Trong hàm takePenalty, ta đợi trọng tài chuẩn bị. Đến đây có hai trường hợp:\r\n\r\n+Nếu chuẩn bị xong (true), nó thì hiện print -\u003e trong print có cái closure -\u003e nó thực hiện cái closure này -\u003e xuống closure ta thấy nó cắt giá trị đầu tiền ra để trả về (như vậy ta có cái tên đầu tiên) -\u003e xong ghép vào \"Goal of Ozil\" chẳng hạn.\r\n\r\n+Nếu chuẩn bị chưa xong (false), nó sẽ chuyển qua else, mà như các bạn thấy, trong phần else ko có closure -\u003e không cắt phần tử đầu tiên ra mà in thẳng chữ Noo. Sau khi xong phần Noo này, nó xong nhiệm vụ mà phần tử đầu tiên vẫn được giữ lại.\r\n\r\n3.Quay lại vòng lặp\r\n\r\nKết quả sẽ là:\r\n```\r\nNooo\r\nGoal of: Ozil\r\nNooo\r\nNooo\r\nGoal of: Santi\r\nGoal of: Wilshere\r\nNooo\r\nNooo\r\nGoal of: Ramsey\r\nGoal of: Welbeck\r\n```\r\n\r\nSự khác biệt là gì? Ở phần đầu tiên, ta thấy ta gọi cầu thủ lên trước khi trọng tài kiểm tra. Kiểm tra xong có true/ false gì cũng bảo cầu thủ đó đi chỗ khác. Phần sau, vẫn vòng lặp đó nhưng trọng tài muốn kiểm tra xong, nếu đúng mới gọi cầu thủ kia lên, không thì thôi. \r\n\r\n\u003e Tóm lại, closure mình hiểu nó kiểu như function, như ví dụ trên, mình truyền vào nó 1 function lấy tên người đầu tiên, và mình muốn khi nào true mới gọi function thực hiện việc đó. \r\n\r\n**3. Autoclosure**\r\nNhân tiện mình nói thêm 1 chút về Autoclosure, refactor đoạn code như sau:\r\n```\r\nvar listOfPlayers: [String] = [\"Ozil\",\"Santi\",\"Wilshere\",\"Ramsey\",\"Welbeck\"]\r\nfunc takePenalty(_ player: @autoclosure () -\u003e String) {\r\n    var isReady = false\r\n    isReady = arc4random() % 2 == 0 ? true:false\r\n    if isReady { print(\"Goal of: \\(player())\") }\r\n    else { print(\"Nooo\") }\r\n}\r\nwhile(listOfPlayers.count\u003e0) {\r\n    takePenalty(listOfPlayers.removeFirst()})\r\n}\r\n```\r\n\r\nNhìn đẹp hơn đúng không mọi người, function work như bình thường. Các bạn để ý closure của mình là một dạng () -\u003e String, hay tổng quát hơn là () -\u003e Any. **Không có argument trong function và trả về 1 kiểu bất kì**. Thì khi đó takePenalty() sẽ hiểu là cái này sẽ thực hiện cái gì đó và chắc chắn là trả về kiểu String cho mình.\r\n\r\nNên mình sử dụng autoclosure để khỏi cần gõ () -\u003e String in v..v. Qua phần tiếp mình sẽ ứng dụng closure vào 1 phần rất hay đó là callback/ completion."
                }, {
                "id": "27J_aXK20Pe-Q6DrJ5wqsA",
                "title": "RxSwift: Bài 6: RxCocoa (Part 5) - Disposing with RxCocoa",
                "content": "## RxSwift: Bài 6: RxCocoa (Part 5) - Disposing with RxCocoa\r\n\r\n***1. Giới thiệu***\r\nPhần này chủ yếu là lý thuyết. Như đã giải thích, có 1 cái bag ở bên trong Main View Controller mà giữ trách nhiệm sẽ xử lý tất cả các subscriptions khi VC bị released. Nhưng cả 1 loạt bài này, bạn không hề thấy weak hay unowned trong các closures. Why?\r\nBởi vì app của mình đang là single view controller, cho nên nó lúc nào cũng hiển thị khi app đang chạy, do đó không cần lo chuyện retain cycles hay leak memory.\r\n\r\n***2. unowned and weak với RxCocoa***\r\nKhi xử lý với RxCocoa hay RxSwift, khá khó hiểu khi nào dùng weak, khi nào dùng unowned. Bạn muốn sử dụng weak khi bạn có 1 closure có thể được gọi tại lúc nào đó trong tương laikhi mà đối tượng self hiện tại của nó đã bị release. Cũng vì lý do này, self trở thành Optional.\r\n\r\nunowned được dùng để tránh Optional self. Nhưng code phải đảm bảo chắc chắn 100% là object sẽ không bị released trước khi closure được gọi, nếu không thì app sẽ bị crash.\r\n\r\nTrong RxSwiftRxSwift, đặc biệt RxCocoa, có 1 vài mẹo để chọn khi nào không cần làm gì, khi nào dùng weak, khi nào dùng unowned: \r\nIn RxSwift – and especially with RxCocoa – there are some good guidelines to follow when choosing to use weak, unowned or nothing at all:\r\n• không làm gì: khi ở bên trong 1 singletons hay ở tỏng 1 VC mà không bao giờ bị release (e.g. the root view controller).\r\n• unowned: Inside all view controllers which are released after the closure task is performed. Bên trong tất cả các view controllers mà bị released sau khi closure task được performed.\r\n• weak: Những trường hợp khác.\r\n\r\nNhững rule này để chống lỗi kinh điển EXC_BAD_ACCESS. Nếu bạn làm theo những rule này thì gần như bạn sẽ không gặp bất kì vấn đề về memory management\r\n\r\n***3. Extending object lifetime***\r\n\r\nExtend object lifetime bằng cách sử dụng the **[weak self]** và **guard let strongSelf = self else { return }**. [weak self] được ưu tiên hơn [unowned self], nơi mà nó không cần phải xét ngay lập tức rằng nó sống lâu hơn closure. Explicitly extending lifetime được ưu tiên hơn là optional unwrapping. Xem ví dụ sau:\r\n```\r\nresource.request().onComplete { [weak self] response in\r\n  guard let strongSelf = self else {\r\n    return\r\n  }\r\n  let model = strongSelf.updateModel(response)\r\n  strongSelf.updateUI(model)\r\n}\r\n```"
                }, {
                "id": "_OShwldezuRNzuG3pSjTmg",
                "title": "RxSwift: Bài 6: RxCocoa (Part 4) - Units",
                "content": "## RxSwift: Bài 6: RxCocoa (Part 4) - Units\r\n\r\n***1. Khái niệm chung***\r\nRxCocoa cung cấp nhiều tính năng mới để làm việc với Cocoa và UIKit 1 cách dễ dàng hơn. Ngoài bindTo, nó cũng đưa ra 1 implementation đặc biệt của observables mà được tạo ra để sử dụng với UI: **Units**. Units là 1 nhóm các lớp có các observables đặc biệt cho phép người dùng dễ dàng viết và code đơn giản hơn, đặc biệt là khi làm việc với UI. \r\n\r\n***2. ControlProperty and Driver là gì?***\r\nKhi bạn binding observables đến UI, rõ ràng bạn cần phải luôn subscribe trên main thread để update UI, thường xuyên cần share subscriptions để bind đến nhiều thành phần UI components, và chắc chắn không hề muốn bị error hay break UI. \r\n\r\nVới những mong muốn đó, những tính năng thực sự của Units là: \r\n+ Units sẽ không thể bị lỗi\r\n+ Units được quan sát và lắng nghe trên main scheduler\r\n+ Units share những ảnh hưởng phụ\r\n\r\nNhững thằng này xuất hiện để đảm bảo UI luôn hiển thị 1 cái gì đó và data hiển thị luôn luôn được sử dụng phù hợp sao cho UI có thể handle được nó. Có hai phần chính của framework Units như sau: \r\n\r\n• ControlProperty and ControlEvent \r\n• Driver\r\n\r\nControlProperty không mới, mình đã đề cập ở những phần trước đó rồi, dùng để bind data đến UI tương ứng mà sử dụng rx riêng biệt.\r\n\r\nControlEvent được sử dụng để lắng nghe những sự kiện chắc chắn, như là bấm \"Return\" button trên bàn phím trong khi đang edit text field. 1 control event được xem là đang available (hoạt động) nếu các component sử dụng UIControlEvents để theo dõi trạng thái hiện tại của nó.\r\n\r\nDriver là 1 special observable với những ràng buộc tương tự đã giải thích trước đó, cho nên nó không thể bị lỗi. Tất cả các tiến trình đều được đảm bảo để có thể execute trên main thread tránh làm cho UI thay đổi trên background threads.\r\n\r\nNhìn chung, units chỉ là phần optional, không quá cần thiết. Nếu bạn pro observable và subject và hiểu mình làm task nào trên scheduler nào. \r\nNhưng nếu bạn muốn 1 việc check của compiler đẹp hơn, điều kiện cho UI hợp lí hơn thì Unit rất mạnh. Đơn cử nếu không dùng Units, rất dễ quên dòng code .observeOn(MainScheduler.instance) thành ra mình đang update UI ở background thread. Thế là chết.\r\n\r\n***3. Áp dụng Driver và ControlProperty***\r\nBây giờ ta apply vào app, đảm bảo rằng tất cả các task được thực hiện đúng thread và không có gì bị lỗi cả và dừng subscriptions từ delivering results.\r\n\r\nBước đầu tiên là chuyển weather data observable thành driver, tìm biến search trong viewDidLoad(), và thay bằng dòng code này: \r\n\r\n```\r\nlet search = searchCityName.rx.text\r\n  .filter { ($0 ?? \"\").characters.count \u003e 0 }\r\n  .flatMapLatest { text in\r\n    return ApiController.shared.currentWeather(city: text ?? \"Error\")\r\n        .catchErrorJustReturn(ApiController.Weather.empty)\r\n  }\r\n  .asDriver(onErrorJustReturn: ApiController.Weather.empty)\r\n```\r\nĐoạn code chính ở đây chính là 1 trong những dòng ở dưới asDriver(...). **Đây là method mà convert observable của bạn thành Driver**. Cái parameter onErrorJustReturn chỉ ra 1 giá trị default, giá trị này được sử dụng trong trường hợp Observable bị lỗi. Nó sẽ loại bỏ khả năng Driver phát ra 1 error.\r\n\r\nBạn có thể để ý là AutoCompletion cũng cung cấp cho mình nhiều variants khác cũng tương tự như asDriver(onErrorJustReturn:):\r\n\r\n• asDriver(onErrorDriveWith:) với hàm này, mình có thể xử lý error manually, và return 1 sequence mới, mà sequence này được sử dụng duy nhất khi nó bị lỗi.\r\n\r\n• asDriver(onErrorRecover:) để ý thì thấy (onErrorRecover được dùng thay cho onErrorDrive) được sử dụng cùng với Driver đang tồn tại khác. Cái này sẽ được dùng để recover cái driver mà bị lỗi ấy.\r\n\r\nTiếp theo, có 1 function tương tự bind(to: ) tên là drive, bạn chỉ cần thay các dòng code có tên là bind(to:) thành drive cho các subscriptions:\r\n```\r\nsearch.map { \"\\($0.temperature)° C\" }\r\n  .drive(tempLabel.rx.text)\r\n  .dispose(by: bag)\r\n\r\nsearch.map { $0.icon }\r\n  .drive(iconLabel.rx.text)\r\n  .dispose(by: bag)\r\n\r\nsearch.map { \"\\($0.humidity)%\" }\r\n  .drive(humidityLabel.rx.text)\r\n  .dispose(by: bag)\r\n\r\nsearch.map { $0.cityName }\r\n  .drive(cityNameLabel.rx.text)\r\n\t .dispose(by: bag)\r\n```\r\nĐiều này sẽ restore behavior của UI 1 cách chính xác trong khi đang sử dụng Driver. Driver works khá giống như bind(to: ), sự khác nhau ở đây là cái tên nghe hợp lí hơn so với Units\r\n\r\nĐến lúc này, cái app tận dụng khá nhiều ưu điểm của RxCocoa, tuy nhiên vẫn còn 1 vài thứ mình có thể refactor để improve. \r\nApp sử dụng rất nhiều resources và quá nhiều API requests (do mỗi lần mình gõ 1 chữ thì app lại request 1 lần).\r\n\r\nthrottle có thể là 1 ý hay nhưng vẫn sẽ nảy sinh ra nhưng requests không cần thiết. 1 cách khác là dùng ControlProperty of UITextField và bắn ra request chỉ khi user hits Search Button trên keyboard.\r\n\r\nTìm dòng này: \r\n```\r\nlet search = searchCityName.rx.text\r\n```\r\n Và thay bằng: \r\n```\r\nlet search =\r\nsearchCityName.rx.controlEvent(.editingDidEndOnExit).asObservable()\r\n  .map { self.searchCityName.text }\r\n```\r\n\r\nTa vẫn càn phải make sure input valid, nên bạn cần skip emty string thông qua filter (count \u003e 0), xong rồi tiếp tục: \r\n```\r\n.flatMap { text in\r\n  return ApiController.shared.currentWeather(city: text ?? \"Error\")\r\n}\r\n.asDriver(onErrorJustReturn: ApiController.Weather.empty)\r\n```\r\n\r\nBây giờ app chỉ send api request chỉ khi người dùng hits Search Button. Không còn những requests vô ích nữa, code được control tại thời điểm compile bởi Units. Ta cũng đã remove catchErrorJustReturn(:)  đến observable, cái mà được trả về bởi currentWeather(city:). \r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ga9n9zsaek_Screen%20Shot%202018-02-22%20at%204.07.33%20PM.png)\r\n\r\nLược đồ gốc đã sử dụng một single observable mà được updated đến toàn bộ UI, thông qua cái rẽ nhánh của multiple blocks, bạn đã chuyển sang subscribe để bind và sử dụng lại những observables tương tự thông qua view controller. Cách tiếp cận này làm cho code có khả năng reusable và dễ nhìn.\r\n\r\nVí dụ, nếu giờ mình add thêm parameter áp suất đến UI, mình chỉ cần add property này vào model, map với JSON value rồi map property đó đến new label áp suất mới tạo. Eassssy!\r\n\r\n"
                }, {
                "id": "nIB9skicEGpXyhjXpaGk-g",
                "title": "RxSwift: Bài 6: RxCocoa (Part 3) - Binding Observables",
                "content": "## RxSwift: Bài 6: RxCocoa (Part 3) - Binding Observables\r\n\r\nMột điều quan trọng cần biết ở đây là trong RxCocoa, binding là một luồng dữ liệu đơn hướng (unidirectional stream of data). Điều này làm đơn giản hóa lưu lượng dữ liệu trong ứng dụng vì vậy bạn sẽ không cần lo đến các ràng buộc hai chiều (bi- directional bindings) ở đây.\r\n\r\n***1. What are binding observables?***\r\nHãy tưởng tượng mối quan hệ của radio, máy phát và nhận tín hiệu: \r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/9d4vfdsazp_Screen%20Shot%202018-02-22%20at%209.20.47%20AM.png)\r\n\r\n1 producer giống như là máy phát tín hiệu, 1 receiver sẽ xử lý giá trị từ producer.\r\n\r\n**Điều quan trọng nhất: 1 receiver không trả về bất kì dạng nào, đây là luật chung khi sử dụng bindings của RxSwift**\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/15cu02nhqy_Screen%20Shot%202018-02-22%20at%209.23.06%20AM.png)\r\n\r\nHàm chính của binding chính là hàm bind(to:). Để bind 1 observable đến 1 thực thể khác, receiver phải comform ObserverType. Thực thể này đã nói ở phần trước: đó là 1 Subject có thể xử lý tín hiệu lẫn nhập dữ liệu cho nó. Subject rất quan trọng khi làm việc với những phần bắt buộc của Cocoa, kiểu như những component quen thuộc như UILabel, UITextField, UIImageView có data thay đổi có thể set hoặc truy xuất.\r\n\r\nThực ra, bind(to:) cũng có thể được sử dụng cho các mục đích khác chứ không riêng gì bind UI với data ở dưới. Ví dụ, bạn có thể sử dụng bind(to:) để tạo ra các dependent processes (các tiến trình hỗ trợ), từ đó observable này sẽ có thể trigger 1 subject để làm một vài background tasks mà không hiển thị bất kì cái gì lên trên màn hình.\r\n\r\nNói chung, bind(to: ) là 1 phiên bản đặc biệt và dễ chịu của subscribe(to: ), không có ảnh hưởng phụ hay trường hợp đặc biệt khi call bind(to: )\r\n\r\n***2. Using binding observables to display data***\r\nSau khi tìm hiểu bindings là gì, bạn có thể bắt đầu tích hợp chúng vào trong app. Bạn sẽ thấy code dễ nhìn hơn và có thể dùng lại được.\r\n\r\nTrước hết, ta refactor đoạn code cũ này, nó gắn data đến những label tương ứng thông qua subscribe(onNext:): \r\n```\r\n// code cũ\r\nsearchCityName.rx.text\r\n  .filter { ($0 ?? \"\").characters.count \u003e 0 }\r\n  .flatMap { text in \r\nreturn ApiController.shared.currentWeather(city: text ?? \"Error\")\r\n    .catchErrorJustReturn(ApiController.Weather.empty)\r\n}\r\n```\r\nVào trong viewDidLoad() và thay thế đoạn code sau:\r\n```\r\nlet search = searchCityName.rx.text\r\n  .filter { ($0 ?? \"\").characters.count \u003e 0 }\r\n  .flatMapLatest { text in\r\n    return ApiController.shared.currentWeather(city: text ?? \"Error\")\r\n        .catchErrorJustReturn(ApiController.Weather.empty)\r\n  }\r\n  .observeOn(MainScheduler.instance)\r\n```\r\nTrong phần thay đổi này, đặc biết là flatMapLatest, giúp kết quả search có thể được sử dụng nhiều lần và chuyển từ data sử dụng 1 lần thành 1 Observable sử dụng nhiều lần. Bạn sẽ thấy sự khác biệt khi bước qua phần MVVM nhưng hiện tại bây giờ, bạn chỉ cần thấy observables là một reusable entities rất mạnh trong Rx. Nó chính xác là một mô hình có thể chuyển 1 Observer dùng 1 lần, khó đọc dài ngoằng thành 1 observer dễ hiểu, dễ dùng và dễ đọc.\r\n\r\nĐây là mô hình nó sẽ hoạt động: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/pyn9i8j9vo_Screen%20Shot%202018-02-22%20at%2010.29.35%20AM.png)\r\n\r\nVới chỉ 1 cái thay đổi nhỏ này, nó có thể xử lý mọi parameter từ 1 subscription, sau đó map giá trị cần thiết để hiển thị. Ví dụ, để lấy giá trị nhiệt độ từ 1 chuỗi string ra khỏi data source observable: \r\n\r\n```\r\n search.map { \"\\($0.temperature)° C\" }\r\n```\r\n\r\nDòng code này sẽ tạo 1 observable mà trả lại 1 required string để display cái temperature. Thử tạo binding đầu tiên bằng cách sử dụng bind(to: ) để kết nối data source đến temperature label, thêm dòng code sau: \r\n```\r\nsearch.map { \"\\($0.temperature)° C\" }\r\n  .bindTo(tempLabel.rx.text)\r\n  .addDisposableTo(bag)\r\n```\r\nBuild và run thử, kết quả sẽ là: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/xvt7lh78wk_Screen%20Shot%202018-02-22%20at%2010.42.15%20AM.png)\r\n\r\nApp bây giờ chỉ hiển thị mỗi nhiệt độ nhưng bạn có thể lưu lại và sử dụng func đó bằng cách áp dụng same pattern với các labels kia:\r\n```\r\nsearch.map { $0.icon }\r\n  .bindTo(iconLabel.rx.text)\r\n  .addDisposableTo(bag)\r\n\r\nsearch.map { \"\\($0.humidity)%\" }\r\n  .bindTo(humidityLabel.rx.text)\r\n  .addDisposableTo(bag)\r\n\r\nsearch.map { $0.cityName }\r\n  .bindTo(cityNameLabel.rx.text)\r\n  .addDisposableTo(bag)\r\n```\r\nBây giờ thì nó đã hiển thị data mà bạn yêu cầu từ server, sử dụng duy nhất 1 Observable tên là search và binds nhiều phần data cho từng label tương ứng trên màn hình:\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ycpat2nerq_Screen%20Shot%202018-02-22%20at%2010.50.03%20AM.png)\r\n\r\nMột điểm hay và tiện nữa đó là việc check bởi compiler để đoạn bảo việc sử dụng những loại type 1 cách chính xác. Cơ bản thì không thể có các loại khác nhau hoàn toàn mà làm crash app được. Thực sự đoạn này mình không hiểu lắm, nguyên văn trong documentation là: \r\n\u003e Another nice, clean addition is the check made by the compiler to ensure the usage of the correct kind of types. It’s basically impossible to have completely disparate types that crash the app.\r\n\r\nNote: một phần note rất quan trọng là khi binding đến 1 UIComponents, **RxCocoa sẽ check để đảm bảo việc quan sát được perform trên main thread.** Nêú không, nó sẽ gọi 1 fatalError() và application sẽ crash với message là: \r\nfatal error: Element can be bound to user interface only on MainThread."
                }, {
                "id": "65E3KgzZi6fGkwL9x1i_Fw",
                "title": "RxSwift: Bài 6: RxCocoa (Part 2)",
                "content": "## RxSwift: Bài 6: RxCocoa (Part 2)\r\n\r\n***Retrieving data from the OpenWeather API***\r\nTrong ApiController, ta thay fake data bằng đoạn code sau: \r\n```\r\nfunc currentWeather(city: String) -\u003e Observable\u003cWeather\u003e {\r\n  return buildRequest(pathComponent: \"weather\", params: [(\"q\", city)])\r\n  .map { json in\r\n    return Weather(\r\n      cityName: json[\"name\"].string ?? \"Unknown\",\r\n      temperature: json[\"main\"][\"temp\"].int ?? -1000,\r\n      humidity: json[\"main\"][\"humidity\"].int  ?? 0,\r\n      icon: iconNameToChar(icon: json[\"weather\"][0][\"icon\"].string ??\r\n\"e\")\r\n) }\r\n}\r\n```\r\nTrong này có hai function cần phân tích:\r\n\r\n1.iconNameToChar: nó nhận 1 string từ data JSON và trả về 1 string khác dưới dạng UTF-8 code của icon thời tiết có hình dạng sẽ xuất hiện trên app của bạn:\r\n\r\n```\r\npublic func iconNameToChar(icon: String) -\u003e String {\r\n    switch icon {\r\n    case \"01d\":\r\n        return \"\\u{f11b}\"\r\n      //[...]\r\n    default:\r\n        return \"E\"\r\n    }\r\n}\r\n```\r\n\r\n2.convenience function buildRequest:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/kvh4krpr80_Screen%20Shot%202018-02-21%20at%205.09.26%20PM.png)\r\n Nó dùng để tạo network requests, sử dụng RxCocoa’s wrapper đối với NSURLSession để perform như sau:\r\n- dùng URL rồi append GET (or POST) request\r\n- sử dụng API của mình để get data\r\n- đưa nội dung về dạng application/ json\r\n- chọn nhiệt độ (ở đây là Kevin)\r\n- đưa dạng json về model\r\n\r\nCuối cùng nó được kết thức bằng dòng sau: \r\n```\r\n //[...]\r\nreturn session.rx.data(request: request).map { JSON(data: $0) }\r\n```\r\nCái này dùng rx extension của RxCocoa xung quanh NSURLSession cái mà sử dụng data function. Nó lần lượt trả về 1 Observable\u003cData\u003e. Data này được dùng như là input data để map dùng chuyển từ raw data thành cấu trúc SwiftyJSON data.\r\nNhìn sơ đồ sau để hiểu rõ hơn cái gì bên trong ApiController:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ualilac1it_Screen%20Shot%202018-02-21%20at%205.23.36%20PM.png)\r\n\r\nThay đoạn code Observable.just([...]) ban đầu bằng real data. Mở OpenWeatherMap API documentation http://openweathermap.org/current, nó sẽ giải thích kĩ cách lấy get/ post, ví dụ như sau: \r\n\u003e api.openweathermap.org/data/2.5/weather?q={city name}\r\n\r\nCái request này sẽ trả về 1 JSON object, sau đó convert với những property cần thiết. Build and run và enter London, kết quả sẽ là: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/bat9rwe4e_Screen%20Shot%202018-02-21%20at%205.27.38%20PM.png)\r\n\r\nApp đã chạy rất ok, tuy nhiên nếu bạn refactor thì thử remove cái catchErrorJustReturn operator bên trong flatmap. Ngay khi nhận đc 404 error (thấy trong console ấy), app sẽ show Error như bt bởi vì mình đã xử lý nil coalescing bên trong rồi.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/foxc9yy6oc_Screen%20Shot%202018-02-21%20at%205.36.17%20PM.png)\r\n"
                }, {
                "id": "39xkfNs_DiHH0JQCp_5WDA",
                "title": "RxSwift: Bài 6: RxCocoa (Part 1)",
                "content": "## RxSwift: Bài 6: RxCocoa\r\n\r\n***1.Tổng quan***\r\nTa sẽ nghiên cứu 1 cái app lấy thời tiết ở 1 thành phố. Source code ở đây. Chúng ta sẽ dùng RxSwift, RxCocoa and SwiftyJSON để lấy data từ API. Sau này mình sẽ có 1 loạt bài viết về các cách lấy JSON trong đó có Codable.\r\n\r\nCác bạn lấy source về rồi vào phần RxCocoa như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/kozvnxq4lw_Screen%20Shot%202018-02-21%20at%202.50.16%20PM.png)\r\n\r\nRồi vào tiếp UITextField+RxRx: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/wu0chxhiaw_Screen%20Shot%202018-02-21%20at%202.53.41%20PM.png)\r\n\r\nBạn sẽ thấy là xuất hiện kiểu ControlProperty\u003cString?\u003e , vậy nó là gì? Đây là một kiểu Subject mà có thể đc lắng nghe và có thể nhận được giá trị mới. Bạn tạm hiểu như vậy đã. \r\n\r\nBây giờ mở UILabel+Rx.swift lên, bạn sẽ thấy 1 type mới đó là Binder (trước đây phiên bản cũ nó là UIBindingObserver). Cái Observer này tương tự với ControlProperty, Nó được sử dụng chủ yếu để bind UI với logic cơ bản và quan trọng nhất, nó không bind được errors (bind ở đây giống như connect, lát mình sẽ nói về đoạn này sau). \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hnaubujv3u_Screen%20Shot%202018-02-21%20at%203.04.07%20PM.png)\r\n\r\nNếu có lỗi gửi đến Binder, nó sẽ gọi fatalError() trong khi đang run ở môi trường debug, nhưng sẽ được add và error log khi run ở production. Bây giờ ta đi vào cụ thể.\r\n\r\n***2. Displaying the data using RxCocoa***\r\nỞ đây, mình không đi sâu những phần ngoài rìa (như API,v..v) mà chỉ tập trung vào RxCocoa, mong các bạn thông cảm.\r\nTrong ApiController.swift, bạn sẽ thấy 1 model dạng struct để map với JSON data. Sử dụng struct ở đây để cho code nhìn gọn hơn vì nó yêu cầu tất cả properties của nó phải có giá trị tại thời điểm khởi tạo. Trong trường hợp giá trị không hợp lệ, bạn luôn luôn có thể sử dụng \"N/A\" hoặc chuỗi tương tự:\r\n```\r\nstruct Weather {\r\n        let cityName: String\r\n        let temperature: Int\r\n        let humidity: Int\r\n        let icon: String\r\n        \r\n        static let empty = Weather(\r\n            cityName: \"Unknown\",\r\n            temperature: -1000,\r\n            humidity: 0,\r\n            icon: iconNameToChar(icon: \"e\")\r\n        )\r\n```\r\n\r\nTiếp theo ta tạo 1 func mà dùng để lấy thời tiết hiện tại ở thành phố của mình, ta fake data 1 chút: \r\n```\r\nfunc currentWeather(city: String) -\u003e Observable\u003cWeather\u003e {\r\n  // Placeholder call\r\n  return Observable.just(\r\n    Weather(\r\n      cityName: city,\r\n      temperature: 20,\r\n      humidity: 90,\r\n      icon: iconNameToChar(icon: \"01d\"))\r\n) }\r\n```\r\nFunc này trả lại 1 fake data dùng để check tạm, sau này ta dùng data lấy từ server về để hiển thị cho nó. Mục đích là để làm việc với cấu trúc data mà không cần phải dùng server.\r\n\r\nĐây là flow của ta, uni-directional data - dữ liệu đơn hướng:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hgsbgh5ttp_Screen%20Shot%202018-02-21%20at%203.29.37%20PM.png)\r\n\r\nNhư đã nói ở các bài trước, RxSwift mà cụ thể là Observables có khả năng nhận và phát data hay đưa những giá trị này để xử lý tiếp. Cho nên nơi chính xác để lắng nghe 1 observable khi đang làm việc trong 1 VC là bên trong viewDidLoad().\r\n\r\nLý do bởi vì bạn cần subscribe càng sớm càng tốt, nhưng mà phải sau khi cái view được load lên. Nếu subscribing trễ 1 chút (ví dụ như viewWillAppear thì có thể sẽ miss 1 vài events hay 1 phần UI sẽ xuất hiện trước khi mình bind data cho chúng. Vì vậy bạn cần tạo tất cả các subscription trước khi app tạo UI hay request data mà cần xử lý để hiển thị. \r\n\r\nAdd dòng code sau vào viewDidLoad():\r\n```\r\nApiController.shared.currentWeather(city: \"RxSwift\")\r\n  .observeOn(MainScheduler.instance)\r\n  .subscribe(onNext: { data in\r\n    self.tempLabel.text = \"\\(data.temperature)° C\"\r\n    self.iconLabel.text = data.icon\r\n    self.humidityLabel.text = \"\\(data.humidity)%\"\r\n    self.cityNameLabel.text = data.cityName\r\n}\r\n```\r\nBuild lên kết quả sẽ là:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/9tb4mfabfy_Screen%20Shot%202018-02-21%20at%203.53.32%20PM.png)\r\n\r\nLúc này sẽ có 1 cái warning quen thuộc, subscribe is unused. Mình sẽ nhắc lại, 1 subscription returns 1 disposable object, cái mà sẽ cancel subscription khi cần. Trong trường hợp này, subscription phải được cancel khi VC bị dismiss. Add cho nó 1 cái bag phía cuối đoạn code\r\n\r\n```\r\nApiController.shared.currentWeather(city: \"RxSwift\")\r\n  .observeOn(MainScheduler.instance)\r\n  .subscribe(onNext: { data in\r\n    self.tempLabel.text = \"\\(data.temperature)° C\"\r\n    self.iconLabel.text = data.icon\r\n    self.humidityLabel.text = \"\\(data.humidity)%\"\r\n    self.cityNameLabel.text = data.cityName\r\n  })\r\n  .dispose(by: bag)\r\n```\r\n\r\nCái này sẽ cancel và dispose cái subscription ngay khi VC được released. Thứ nhất, điều này chống lãng phí resources, thứ hai chống những events ko mong muốn hoặc những ảnh hưởng khác có thể xảy ra khi 1 subscription không được disposed. Ví dụ nha, nếu subscription của bạn dùng để lắng nghe events từ server, nếu không dispose, nó cứ phát ra events và mình cứ query qoài, dễ bị memory leak. \r\n\r\n***3. rx property***\r\nCái framework này sẽ dụng extensions của protocol và add thêm thành phần rx vào nhiều UIKit components. Bạn chỉ cần gõ rx. thì sẽ thấy các available properties và methods:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/44laxk5va7_Screen%20Shot%202018-02-21%20at%204.24.03%20PM.png)\r\n\r\nCó một property là text. Function này returns 1 observable là ControlProperty\u003cString?\u003e vừa thoả mãn ObservableType and ObserverType cho nên bạn có thể subscribe lẫn emit new value.  \r\nAdd vào viewDidLoad(): \r\n```\r\nsearchCityName.rx.text\r\n  .filter { ($0 ?? \"\").characters.count \u003e 0 }\r\n  .flatMap { text in\r\n return ApiController.shared.currentWeather(city: text ?? \"Error\")\r\n    .catchErrorJustReturn(ApiController.Weather.empty)\r\n}.observeOn(MainScheduler.instance)\r\n.subscribe(onNext: { data in\r\n  self.tempLabel.text = \"\\(data.temperature)° C\"\r\n  self.iconLabel.text = data.icon\r\n  self.humidityLabel.text = \"\\(data.humidity)%\"\r\n  self.cityNameLabel.text = data.cityName\r\n})\r\n.disposed(by: bag)\r\n```\r\nCode ở trên sẽ trả về 1 Observable với data để hiển thị. Vì currentWeather không chấp nhận nil hay empty values nên tốt nhất filter chúng từ lúc nhập cho khoẻ.\r\n\r\nSau đó, fetch cái weather data bằng cách sử dụng lớp ApiController, đến đây mình không đi quá sâu vào phần lấy data từ server, chỉ yếu focus rx\r\n\r\nMột khi bạn chuyển sang MainScheduler và main thread, bạn update tất cả control UI với dữ liệu hiện tại. Các bạn xem sơ đồ sau:\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/l0x38hlkts_Screen%20Shot%202018-02-21%20at%204.32.47%20PM.png)\r\n\r\nLúc này, bạn gõ như thế nào label được update như thế đấy, có điều vẫn đang là fake data\r\n\r\nNote: catchErrorJustReturn operator được yêu cầu để ngăn chặn việc Observable bị dispose khi mình nhận 1 error từ API. Ví dụ, 1 thành phố invalid name trả về 404 error NSURLSessionNSURLSession. Trong trường hợp nàynày, bạn nên trả về 1 empty value để app không bị dừng lại nếu có lỗi."
                }, {
                "id": "kBQo-JgX9R_yvk33RUgMmQ",
                "title": "RxSwift - Phần bổ sung - Bài 1: Hot và Cold Observables",
                "content": "## RxSwift - Phần bổ sung - Bài 1: Hot và Cold Observables\r\n\r\nĐây là loạt bài song song với loạt bài chính. Mục đích của phần này là viết những bài bổ sung thêm kiến thức mà không làm ảnh hưởng đến trục chính mình đang viết bên RxSwift kia. \r\n\r\n***1. Hot and Cold Observables***\r\n- “hot” Observable có thể bắt đầu phát ra events ngay khi nó được tạo ra và những observer mà bắt đầu subscribes có thể sẽ observer ở đâu đó đoạn giữa giữa tín hiệu. \"hot\" không cần subscribes vẫn phát được tín hiệu.\r\n-  “cold” Observable thì lại chờ đến khi có ai đó lắng nghe mới phát tín hiệu, nên người quan sát có thể yên tâm rằng mình có thể thấy toàn bộ sequence từ lúc bắt đầu. \"cold\" cần subscribe mới chịu phát tín hiệu.\r\n\r\n***2. Dấu hiệu nhận biết***\r\n- \"hot\" Observable là những thứ như **UIButton.rx.tap**, **UITextField.rx.text** mà có thể phát ra events kiểu Void khi 1 button đc tap hay kiểu String khi text field được nhập.\r\n- \"cold\" Observable là những thứ mà ta thường bỏ vào hàm Observable.create()\r\n\r\n***3. Thực tế mình gặp phải***\r\nTrước khi mình biết đến hot and cold, mình từng thắc mắc như sau: Observable sẽ không phát tín hiệu cho đến khi có ai đó subscribe nó, ví dụ: myObservable.subscribe(onNext: {}). Vậy tại sao trong đoạn code sau: \r\n\u003e // in LoginViewModel.swift\r\ninit() {\r\n    isValid = Observable.combineLatest(username.asObservable(), password.asObservable()) { (username, password) in\r\n        return !username.isEmpty \u0026\u0026 !password.isEmpty\r\n    }\r\n}\r\n// in LoginViewController.swift\r\nviewModel.isValid.bind(to: loginButton.rx.isEnabled).disposed(by: disposeBag)\r\n\r\nthì tại sao isValids có thể được observed mà không phải gọi subscribe? Tại sao ta có thể gọi bind(to:)  trong LoginViewController.swift mà không cần gọi kiểu .isValid.subscribe() ?\r\n\r\nGiải thích: \r\nVấn đề của mình là do mình hiểu sai vấn đề. Với cả, ngay trong hàm bind(to: _) nó đã có subscribe bên trong nó.\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/u999udocyp_Screen%20Shot%202018-02-21%20at%202.29.40%20PM.png)\r\n"
                }, {
                "id": "rT6FaiEkRLnjNHOCZ8hfdA",
                "title": "RxSwift: Bài 5 - Observables and Subjects in Practice (Part 3)",
                "content": "## RxSwift: Bài 5 - Observables and Subjects in Practice (Part 3)\n\n***WHICH DISPOSE BAG TO USE ?***\nNhư vậy, nhìn chung các bạn đã hiểu sơ về cách giao tiếp giữa 2 màn hình. Bây giờ, ta cần tìm hiểu thêm về dispose bags để quản lý bộ nhớ của Observable supscriptions tốt hơn. Dispose Bag rất hay trong việc cột lifetime của 1 subscription đến 1 lifetime của đối tượng khác. Câu hỏi đặt ra là đối tượng nào sẽ xác định lifetime của subscription này. \n\nCó một vấn đề bạn sẽ không để ý đó là message “completed photo selection” mà mình đã add trong subscription của dispose closure không xuất hiện. Tức là cái subscription này sẽ không bao giờ được xử lý và sẽ không giải phóng bộ nhớ của nó.\n\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/l5ac7q8793_Screen%20Shot%202018-02-17%20at%208.55.29%20AM.png)\n\nGiờ sao? Có 1 tính năng rất hay của RxSwift đó là Resources mà cho bạn số lượng allocations của observables, observers, and disposables. Mặc dù mặc định RxSwift đã disable cái này nhưng ta sẽ enable nó lên.\n\nThêm đoạn này vào trong Podfile:\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/8o6plpmaqk_Screen%20Shot%202018-02-17%20at%209.08.59%20AM.png)\n\nThực sự phần này mình chưa tìm hiểu nhiều, coi như mình xin nợ các bạn phần này. Có thời gian chắc chắn mình sẽ quay lại để tiếp tục phần này."
                }, {
                "id": "SAEB95Dc6PWN1u-PRtuguw",
                "title": "RxSwift: Bài 5 - Observables and Subjects in Practice (Part 2)",
                "content": "## RxSwift: Bài 5 - Observables and Subjects in Practice (Part 2)\r\n\r\n***Step 3: Talking to other view controllers via subjects***\r\nPhần này ta sẽ connect ViewController chính của ta với PhotosViewController, để người dùng có thể chọn ảnh tuỳ ý từ album ảnh của họ. \r\n\r\nTrước hết, ta comment phần hard-code h1.png đi, sau đó push cái PhotosViewController vào stack, khi bấm nút + sẽ chuyển qua bên PhotosViewController. \r\n\r\nNếu bạn sử dụng một cái app sử dụng pattern Cocoa, bước tiếp theo bạn sẽ dùng delegate protocol để Photo Controller có thể nói chuyện ngược lại với Main Controller (hay còn gọi là non-reactive way):\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/4weggvcirc_Screen%20Shot%202018-02-16%20at%2010.56.07%20PM.png)\r\n\r\nTuy nhiên trong RxSwift, bạn vẫn có 1 cách thông dụng để giao tiếp giữa hai classes. Đó là thông qua Observable. Không cần phải define protocol nào cả, bởi vì Observable có thể chuyển bất kì loại message nào đến 1 hoặc nhiều người quan tâm đến nó - observers\r\n\r\n***Step 4: Creating an observable out of the selected photos (Tạo một observable trong số những selected photo)***\r\nAdd 1 subject vào PhotoVC mà emit một .next event mỗi lần user taps 1 hình từ Camera Roll. Có thể bạn muốn add 1 PublishSubject ở đây để show ra hình được chọn (tức là PublishSubject sẽ vừa nhận vừa phát). Tuy nhiên, không nhất thiết phải để public, vì nó sẽ cho phép những lớp khác gọi onNext (nhập tín hiệu vào) và làm cho subject emit values. Cách này cũng được nhưng mình sẽ làm hướng khác.\r\n\r\nAdd dòng code sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/49qbefn5ed_Screen%20Shot%202018-02-16%20at%2011.21.55%20PM.png)\r\n\r\nMình xin giải thích các dòng code một chút: \r\n+ Biến private PublishSubject sẽ emit những hình được chọn\r\n+ Biến public selectedPhotos sẽ show ra cái observable của Subject\r\n+ Subscribing cái property này là cách mà ViewController có thể quan sát dòng photo sequence mà không cần phải can thiệp vào nó.\r\n\r\nPhotosViewController đã chứa đoạn code để đọc photo từ Camera Roll và hiển thị lên Collection View rồi (trong phần collectionView(_:didSelectItemAt:)). Tất cả những gì bạn cần làm là add code để phát tín hiệu khi user tap lên collection view cell\r\n\r\nTiếp theo, trong phần imageManager.requestImage(...) để lấy photo được chọn và cho bạn chọn hình và các thông số để làm việc với completion closure. Trong closure này, bạn sẽ phát ra tín hiệu .next event từ selectedPhotosSubject, trong đoạn code này, các bạn add: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7v5e08xowi_Screen%20Shot%202018-02-17%20at%207.25.15%20AM.png)\r\n\r\nMình giải thích code một chút, sử dụng info dictionary để check liệu hình là thumbnail hay full. Trong event của mình chỉ nhận full-size, nên khi có hình nào available thì bạn add thông tin vào cho nó thông qua onNext(_:) ở cái subject nhận tín hiệu của bạn và cung cấp nó với full photo.\r\n\r\nVậy đó, đây là cách nó phát ra 1 chuỗi observable sequence từ 1 màn hình VC đến VC khác. Không delegate protocol hay closure v..v. Thêm nữa, khi mà đã remove protocols, mối quan hệ giữa các controllers trở nên đơn giản hơn nhiều, các bạn xem hình sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/wuj8z3rdyn_Screen%20Shot%202018-02-17%20at%207.56.20%20AM.png)\r\n\r\n**Step5: Observing the sequence of selected photos**\r\nNhiệm vụ tiếp theo của bạn là quay lại ViewController và thêm đoạn code sau để hoàn thành cho xong phần phát-gọi, cụ thể là quan sát sequence của selected photos\r\nTại actionAdd() and thêm dòng code sau trước khi khi push controller lên trên navigation stack:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/exltjds82e_Screen%20Shot%202018-02-17%20at%208.10.27%20AM.png)\r\nTrước khi bạn push controller, subscribe cái events trên selectedPhotos observable của nó. Có 2 cái mình muốn dùng là .onNext và .onDisposed. Compiler lúc này báo warning mình khai báo self mà chưa dùng, do đó mình thêm đoạn code sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/kmlb11c855_Screen%20Shot%202018-02-17%20at%208.12.55%20AM.png)\r\n\r\nRun app và chạy thôi!\r\nÀ Mình quên note, để chạy được phần này các bạn phải cấp quyền cho app truy cập vào photo library như sau: \r\nEdit trong phần Info.list cặp key-value sau: \r\n```\r\n\u003ckey\u003eNSPhotoLibraryUsageDescription\u003c/key\u003e\r\n\u003cstring\u003ePhoto Library Access Warning\u003c/string\u003e\r\n```\r\n\r\nĐây là thành quả:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/dn8rwxivsi_Screen%20Shot%202018-02-17%20at%208.25.24%20AM.png)\r\n\r\n"
                }, {
                "id": "2u_Z3nfiJoRTnpZW0alN7A",
                "title": "RxSwift: Bài 5 - Observables and Subjects in Practice (Part 1)",
                "content": "## RxSwift: Bài 5 - Observables and Subjects in Practice (Part 1)\r\n\r\nĐến bài này, có lẽ mn đã hiểu observables và các loại subjects. Tuy nhiên thực tế để áp dụng như binding UI đến data model hay đưa ra một new controller và gán ngược output lại nó lại rất khó khăn chứ không đơn giản. \r\n\r\nBây giờ mình sẽ đi tạo project thực tế. Mình xin lỗi trước vì mình sẽ không hướng dẫn cách import RxSwift ở đây, các bạn có thể lên mạng search cách import RxSwift và RxCocoa.\r\n\r\nOk, bắt tay nào, ta dựng 1 project như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/8ofhc123ad_Screen%20Shot%202018-02-16%20at%207.17.58%20AM.png)\r\n\r\nĐây là app cắt ghép ảnh rồi dán vào chung thành 1 bức ảnh, link source code ở đây: https://github.com/christopherkmoore/Combinestagram\r\n\r\n**Step 1: Sử dụng variable trong một view controller**\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/44p295juzr_Screen%20Shot%202018-02-16%20at%208.19.28%20AM.png)\r\n\r\nMình có ba vấn đề cần nhấn mạnh ở đây: \r\n\r\n1. Bắt đầu add 1 biến Variable\u003cUIImage\u003e vào ViewController(VC) và lưu trữ những photos được chọn trong các giá trị của nó. Variable ở đây sử dụng như các variable bình thường bạn hay dùng: bạn có thể thay đổi giá trị của nó bất cứ khi nào bạn muốn (bằng cách truy xuất vào property\r\n2. Vì bag và images chỉ dùng trong lớp này, các lớp khác không dùng nên ta đặt là private, tương tự nếu class của bạn không có ai kế thừa nữa thì đặt final\r\n3. Vì disposeBag thuộc quyền sở hữu của ViewController nên ngay khi VC được giải phóng thì tất cả các observable mà được add disposeBag cũng được xử lý luôn. Bạn xem hình sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ckbo40uaac_Screen%20Shot%202018-02-16%20at%203.56.23%20PM.png)\r\nKhá dễ hiểu, điều này sẽ làm cho việc quản lý bộ nhớ của các subscription Rx dễ dàng hơn: đơn giản chỉ là ném hết bọn chúng vào một cái túi rồi chúng sẽ bị xoá khi VC bị dealloc.\r\n\r\nTuy nhiên, điều này sẽ không xảy ra với VC này, bởi vì đây là **root view controller** và nó sẽ không bị xoá trước khi app quit. Bạn sẽ thấy cơ chế dispose dựa trên dealloc ở phần sau.\r\n\r\nTiếp theo bạn nối IBAction của btnAdd, đặt tên là actionAdd() hoặc gì cũng được, và đơn giản là thêm 1 bức hình trong Assets. Sẵn tiện các bạn tạo luôn 2 action Save và Clear luôn. Tiếp theo, để add thử 1 hình vào trong Variable images, các bạn làm như sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gnbcoh8wyz_Screen%20Shot%202018-02-16%20at%204.14.38%20PM.png)\r\nĐể ý rằng bạn thay đổi giá trị hiện tại của images cũng như khi bạn làm với variable bình thường. Lớp Variable của Rx sẽ tự động sản xuất ra 1 observable sequence của tất cả những giá trị rời rạc mà bạn đã gắn cho property value của nó. (Tức là mỗi lần bạn variable.value = a là bạn đang gắn từng biến rời rạc đó, sau đó Rx sẽ đưa tất cả những giá trị rời rạc này vào dòng chảy của nó).\r\n\r\nGiá trị khởi tạo ban đầu của Variable images là 1 mảng rỗng và mỗi lần user bấm button Add (+). Cái observable sequence mà được tạo ra bởi images sẽ phát ra .next event mới với 1 mảng array mới như là 1 phần tử. (Lưu ý cứ mỗi lần mình add 1 phần từ nó sẽ trả về 1 mảng mới chứ không phải trả về mảng cũ với phần tử mới được add)\r\n\r\nĐể cho phép người dùng xoá lựa chọn hiện tại, add images.value = [], tức là mình gắn một giá trị mới là mảng rỗng. Như vậy với vài dòng code, bạn đã xử lý user input 1 cách gọn gàng. Nhắc lại, **variable có 2 nhiệm vụ, nhận tín hiệu và phát tín hiệu, phần trên đã xử lý công việc nhận tín hiệu thông qua property value của Variable.**\r\n\r\n**Step 2: Adding photos to the collage**\r\nTiếp theo, ta xử lý phần phát tín hiệu, tức là observing images (sau đó hiển thị lên screen). Các bạn để phần code này bên trong viewDidload() như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/1pbgf0wgy2_Screen%20Shot%202018-02-16%20at%204.46.59%20PM.png)\r\n\r\nBạn có thể quan sát sự thay đổi này và cập nhập collage preview một cách tương ứng. Vì đây là 1 Variable nên bạn cần dùng Observable của nó để subscribe đến nó\r\n\r\nBạn subscribe cái .next events được phát ra bởi images và mỗi event bạn tạo ra 1 collage với hàm UIImage.collage(images:size:) mà ta extension trong class UIImage+Collage (mình sẽ không giải thích lớp này ở đây). Cuối cùng add subscription này vào cái túi của VC.\r\n\r\nỞ lúc này, bạn subscribe cái observables trong viewDidLoad(). Ở những phần tới, ta sẽ làm chuyện này ở trong ViewModel trong MVVM. Bây giờ run app để thấy được cái hay.![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/moo0d3ls6f_Screen%20Shot%202018-02-16%20at%204.58.58%20PM.png)\r\n\r\n**Step 3: Driving a complex view controller UI**\r\nBây giờ ta chỉnh app ta thông minh 1 chút như sau:\r\n```\r\n• Disable Clear/ Save button nếu không có photos\r\n• Disable Clear/ Save button sau khi vừa bấm Clear\r\n• Nếu hình là số lẻ thì Save bị disable (vì bị trống)\r\n• Hạn chế số hình là 6, nếu hơn rất xấu\r\n• Title update số hình hiện tại.\r\n```\r\nNếu theo hướng non-reactive thì bạn sẽ thấy những cái này implement là hơi bị cực, còn với RxSwift, bạn chỉ cần subscribe images 1 lần rồi update cái UI tại 1 chỗ duy nhất, khỏi phải lòng vòng. Add thêm cái subscription này bên trong viewDidLoad():\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/uozs1vwlr0_Screen%20Shot%202018-02-16%20at%205.20.45%20PM.png)\r\n\r\nupdateUI() là một hàm private ta sẽ tạo sau đây, tuy nhiên, **ở đây mình xin chia sẻ thêm chỗ này, giả sử bạn chưa tạo hàm updateUI() thì compiler thì báo lỗi nhìn chả liên quan gì cả:**\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ss4n9hq6bh_Screen%20Shot%202018-02-16%20at%205.25.38%20PM.png)\r\n\r\nLỗi là: \"Extraneous argument label 'onNext:' in call\". Thực sự nếu sau này bạn gặp lỗi này tức là bạn đã gặp lỗi bên trong closure onNext, cái bạn cần fix chính là bên trong này chứ không phải là onNext function. Ở đây, mình gặp issue là mình chưa tạo func updateUI(). \r\n\r\nThôi bây giờ ta code phần updateUI(): \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/jy744aj5sp_Screen%20Shot%202018-02-16%20at%205.25.02%20PM.png)\r\n\r\nTrong phần code trên, các logic mình chắc không cần giải thích nhiều, khá rõ ràng và dễ hiểu. Cái hay ở đây là toàn bộ logic code được đặt vào chỉ một chỗ, chỉ một vài dòng code đơn giản mà nắm toàn bộ app. Quá đỉnh!"
                }, {
                "id": "baAeuAevc9mXyVp1HZPXXA",
                "title": "RxSwift: Bài 4 - Subjects (Part 3) - Variables",
                "content": "## RxSwift: Bài 4 - Subjects (Part 3) - Variables\r\n\r\n***1. Giới thiệu:*** \r\nNhư để cập ở Part 1, 1 Variable có các tính chất của BehaviorSubject và lưu trữ giữ liệu hiện tại của nó như là trạng thái hiện tại của nó.\r\nBạn có thể truy cập giá trị hiện tại này thông qua property \"value\" của nó. Và bạn cũng có thể sử dụng cái \"value\" này để nhập những element lên trên variable của nó. Nói cách khác, bạn không dùng onNext(_:).\r\n\r\nBởi vì nó có các tính chất của BehaviorSubject nên 1 Variable được tạo ra với 1 giá trị khởi tạo, và nó sẽ phát ra giá trị mới nhất hoặc giá trị ban đầu đến những subscribers mới của nó. Để truy cập vào 1 behavior subject bên dưới của Variable, bạn gọi asObservable() lên nó\r\n\r\nMột tính chất khá đặc trưng của Variable so với những subject khác đó là nó được đảm bảo rằng sẽ không phát ra Error. Mặc dù bạn có thể lắng nghe .error events trong 1 subscription đến 1 variable, nhưng bạn không thể add 1 .error event lên trên 1 Variable. Ngoài ra, một variable cũng sẽ tự động kết thúc khi nó chuẩn bị deallocated, cho nên bạn không thể add .completed event vào nó.\r\n\r\n***2. Ví dụ cụ thể***\r\nBạn xem dòng code sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gfk0dnnbph_Screen%20Shot%202018-02-15%20at%208.11.01%20PM.png)\r\n\r\nMình xin phân tích như sau: \r\n1.Tạo 1 Variable với 1 giá trị khởi tạo. Variable có thể tự suy luận kiểu thông qua giá trị ban đầu nhưng bạn cũng có thể khai rõ ràng loại là gì, ví dụ như là Variable\u003cString\u003e(\"Initial value\").\r\n2.Add một giá trị cho nó, là \"new init value\", bạn lưu ý các add lần này không còn add qua onNext nữa mà là add thông qua cái value.\r\n3.Subscribe đến cái variable này bằng cách gọi asObservable() để truy cập vào behavior subject nằm bên trong của nó.\r\n\r\nKết quả như hình dưới, nó sẽ lấy giá trị mới nhất của nó: \r\n```\r\n --- Example of: Variable ---\r\n1) New initial value\r\n```\r\n\r\nBây giờ ta add thêm đoạn code sau vào chỗ tiếp theo:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/66xny5njlh_Screen%20Shot%202018-02-15%20at%208.24.45%20PM.png)\r\n\r\nPhân tích một chút:\r\n1.Ta add thêm giá trị mới vào variable.\r\n2.Tạo thêm 1 subscription đến thằng variable này.\r\n3.Add thêm một giá trị khác vào variable này.\r\n \r\n Kết quả như sau: \r\n ![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/oznr6g936t_Screen%20Shot%202018-02-15%20at%208.25.22%20PM.png)\r\n \r\n Các bạn có đoạn được tại sao không? Cho các bạn 5p suy nghĩ, hết giờ. Bây giờ mình xin giải thích như sau. \r\n \r\n Cái subscription hiện tại Sub01 nhận giá trị mới 1 từ Variable, không có gì khó hiểu vì nó đã subscribe nãy giờ. Còn đối với Sub02, nó vẫn nhận giá trị tương tự bởi vì đó là giá trị gần nhất. Sau đó cả hai đều nhận được giá trị 2, khi giá trị 2 này đã được add vào value của nó. \r\n\r\nKhông có cách nào để add .error hay .completed event vào variable, dù có cố thì compiler cũng báo lỗi nên ta sẽ không làm thử việc này để làm gì. Đây là một vài cách chữa cháy: \r\n```\r\n// These will all generate errors\r\nvariable.value.onError(MyError.anError)\r\nvariable.asObservable().onError(MyError.anError)\r\nvariable.value = MyError.anError\r\nvariable.value.onCompleted()\r\nvariable.asObservable().onCompleted()\r\n```\r\n\r\nVariables rất linh hoạt. Bạn có thể subscribe chúng như là observables để có thể react bất cứ khi nào có 1 new .next event xuất hiện, giống như các subject khác. Chúng còn có thể đáp ứng nhu cầu dùng lần rồi thôi như là khi bạn chỉ cần check giá trị hiện tại là đủ mà không cần phải subscribe gì cho phức tạp.\r\n"
                }, {
                "id": "bSQGSkDvqrsRfuPSAO6-fQ",
                "title": "RxSwift: Bài 4 - Subjects (Part 2) - BehaviorSubject và ReplaySubject",
                "content": "## RxSwift: Bài 4 - Subjects (Part 2) - BehaviorSubject và ReplaySubject\r\n\r\n\r\n***1. BehaviorSubject***\r\n**BehaviorSubject tương tự như PublishSubject ngoại trừ chúng sẽ nhận giá trị gần nhất của .onNext event đến những new subscribers**. Xem sơ đồ sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ncw28krckw_Screen%20Shot%202018-02-15%20at%202.54.32%20PM.png)\r\n\r\nDòng thứ nhất là BehaviorSubject, 2 dòng tiếp theo là 2 subscribers của nó. \r\nSub01 đăng kí trước 1) và sau 2). Nó nhận được 2), 3) là đương nhiên, ngoài ra nó còn nhận đc 1) vì đó là giá trị gần nhất được phát trước khi ta subscribe\r\nSub02 đăng kí trước 2) và sau 3). Nó nhận được 3) là rõ ràng, ngoài ra nó nhận được thêm 2) vì đây là giá trị gần nhất được phát trước khi nó subscribe\r\n\r\nĐược rồi, đến đây ta bắt tay vào đoạn code như sau:\r\nThêm cho mình 1 enum là myError kế thừa Error bên trong có 1 case là anError. Sau đó, thêm cho mình những đoạn code sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ncxvjpzi7u_Screen%20Shot%202018-02-15%20at%203.14.20%20PM.png)\r\n\r\nMình giải thích một chút:\r\n1.Mình tạo 1 func print để cho tiện hơn thôi, ở đây mình giải thích đoạn toán tử ?? một chút, mình sẽ hiểu như sau:\r\n+ event.element ?? (event.error ?? event) -\u003e nếu element không nil thì trả về event.element, nếu nil thì trả về cái thằng bên trong dấu ngoặc này.\r\n+ bên trong dấu ngoặc, nếu error không nil (tức là nó bị error) thì trả về event.error không thì trả về event. Event này thì bạn đã biết event gì rồi đấy, là completed.\r\n\r\n2.Tiếp theo mình tạo 1 BehaviorSubject với giá trị ban đầu. Lưu ý, vì **BehaviorSubject luôn luôn phát ra phần tử gần nhất nên bạn không thể tạo ra nó mà không cung cấp giá trị ban đầu. Nếu bạn không thể cung cấp giá trị ban đầu tại thời điểm khởi tạo, có nghĩa là bạn cần dùng PublishSubject thay vì BehaviorSubject**\r\nTiếp theo là subscribe nó:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/p840ox6m2i_Screen%20Shot%202018-02-15%20at%203.30.33%20PM.png)\r\n\r\nĐoạn trên tạo 1 subscription đến cái subject, và không có bất kì elements nào được add vào subject, cho nên nó sẽ phát lại giá trị ban đầu đến thằng subscriber. Kết quả thu được sẽ là: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/xfydbhfrn7_Screen%20Shot%202018-02-15%20at%203.34.07%20PM.png)\r\n\r\nBây giờ bạn thêm giá trị cho subject trước khi nó đc ai đó subscribe nhưng sau thời điểm khởi tạo:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/wbm8aa4wsd_Screen%20Shot%202018-02-15%20at%203.38.22%20PM.png)\r\n\r\nVà kết quả sẽ là tín hiệu gần nhất:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7qnfupr0cx_Screen%20Shot%202018-02-15%20at%203.38.39%20PM.png)\r\n\r\nTa code thêm chút nữa cho hiểu thêm: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hqhm9ohpxd_Screen%20Shot%202018-02-15%20at%203.45.38%20PM.png)\r\n\r\nCác bạn đoán được kết quả chứ, đúng rồi, sub02 sẽ nhận được error.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/3jn9oasm7x_Screen%20Shot%202018-02-15%20at%203.45.46%20PM.png)\r\n\r\nTóm lại: \r\nBehaviorSubject được dùng khi bạn muốn thông báo cho 1 ai đó về dữ liệu gần nhất. Ví dụ như login 1 app, đôi khi bạn muốn show lại latest value để hiển thị trong form login chẳng hạn. \r\n\r\nCòn nếu trong search screen, bạn muốn show 5 giá trị gần nhất thì dùng cái gì bây giờ, vì BehaviorSubject chỉ hiển thị 1 cái. Đó chính là ReplaySubject.\r\n\r\n***2. ReplaySubject***\r\nReplaySubject sẽ tạm thời lưu trữ lại các cache hay bộ đệm (buffer) của nhiều value gần nhất, tối đa số lượng sẽ phụ thuộc vào mình chọn. Nó sẽ phát lại bộ đệm này cho những subscribers mới. Hãy xem sơ đồ dưới đây: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/n7gvbbiy3d_Screen%20Shot%202018-02-15%20at%205.03.07%20PM.png)\r\n\r\nCái sub01 thứ nhất sẽ subscribe ngay từ đầu nên nó sẽ nhận toàn bộ event mà subject phát ra. Cái sub02 subscribe sau 2) và trước 3) và size of buffer của nó = 2 nên nó sẽ nhận 2 giá trị gần nhất trước đó nên nó sẽ nhận luôn toàn bộ giá trị. \r\n\r\nHãy lưu ý khi sử dụng ReplaySubject thì bộ đệm của nó sẽ được lưu trong bộ nhớ. Bạn sẽ dễ gặp phiền phức như là bộ đệm của bạn quá lớn hay loại lưu trữ của bạn là hình ảnh dung lượng lớn. Một điều cần lưu ý là tạo 1 ReplaySubject của array, buffer size sẽ lưu nhiều array, rất dễ bị issue về bộ nhớ nếu không cẩn thận.\r\n\r\nXem ví dụ sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lkurqp7a2c_Screen%20Shot%202018-02-15%20at%205.53.52%20PM.png)\r\n\r\nPhân tích các dòng code như sau\r\n1. Khởi tạo ReplaySubject trong đó sử dụng create(bufferSize:) để khai báo size của bộ đệm.\r\n2. Add thêm 3 giá trị vào subjects\r\n3. Tạo 2 subscriptions của subjects\r\n\r\nHai phần tử gần nhất là 2, 3 sẽ được phát đến cả 2 subscribers, 1 sẽ không được phát vì giới hạn bộ đệm là 2 - ta đã setup cho nó trước khi có bất kì ai subscribe (nếu ta tăng lên 3 thì được). Kết quả thu được như sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/kshvbdygg5_Screen%20Shot%202018-02-15%20at%205.54.04%20PM.png)\r\n\r\nBây giờ ta thêm 1 value cho cái subject này và thêm 1 subscription Sub03 cho nó, \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/rv8mz57nrz_Screen%20Shot%202018-02-15%20at%206.11.42%20PM.png)\r\n\r\nCác bạn đoán thử kết quả? Đúng rồi. Sub01, Sub02 sẽ tự động nhận giá trị 4, vì nó đang đăng kí, trong khi Sub03 sẽ nhận giá trị 3, 4 chứ không phải 2, 3 như Sub01, Sub02 đã nhận trước đó.\r\n```\r\nSub01: 4\r\nSub02: 4\r\nSub03: 3\r\nSub03: 4\r\n```\r\n\r\nĐến đoạn này, mình hi vọng các bạn đã hiểu rõ về hai loại subject này. Bây giờ đặt một vấn đề là nhỡ may bị error thì làm sao? Hãy add thêm error vào vị trí như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/98kes0uk1h_Screen%20Shot%202018-02-15%20at%206.21.17%20PM.png)\r\n\r\nCác bạn có thể đoán được kết quả không ? Lần này mình sẽ add kết quả trước rồi giải thích sau, các bạn hãy nhìn vào kết quả rồi tự rút ra kết luận cho mình trước khi đọc phần giải thích nhé:\r\n```\r\nSub01: 4\r\nSub02: 4\r\nSub01: anError\r\nSub02: anError\r\nSub03: 3\r\nSub03: 4\r\nSub03: anError\r\n```\r\nCó thể giải thích như sau? Cái replaySubject này đã kết thúc với 1 error, đương nhiên Sub01, Sub02 sẽ biết chuyện này và nhận event Error này. **Và cái quan trọng ở đây là nó vẫn sẽ vẫn phát 2 giá trị trước đó trước khi phát Error event cho những subscribers mới.**\r\n\r\nBây giờ, add dòng code này ngay sau khi error,\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/j3hsbe5qnl_Screen%20Shot%202018-02-15%20at%207.02.51%20PM.png)\r\n\r\nthì kết quả như sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gdcjjkcwan_Screen%20Shot%202018-02-15%20at%207.01.53%20PM.png)\r\n\r\nBằng cách gọi dispose() của ReplaySubject trước đó, thì các new subscribers sẽ chỉ nhận được error event mà nói rõ rằng subject đã được xử lý xong rồi (was already disposed)\r\n\r\nGọi dispose() lên replay subject kiểu như này không phải cách mình thường hay làm, bởi vì nếu bạn đã thêm subscriptions của bạn vào trong disposeBag (chủ yếu để tránh tạo ra những strong reference cycles) thì mọi thứ sẽ bị xử lý và huỷ đi khi chủ của nó (trong thực tế thường là ViewController hoặc ViewModel). Dù sao, đây cũng là một kiến thức khá hiếm và hay, nên biết.\r\n\r\nNhư vậy, với các loại subject hiện tại, bạn có thể xử lý hết nhu cầu cần thiết. Bây giờ lỡ bạn đơn giản là chỉ muốn hỏi observable type là giá trị hiện tại là gì? thì lúc đó Variable sẽ rất có ích."
                }, {
                "id": "P7sUft3V7-kjXgsHnubIbw",
                "title": "RxSwift: Bài 4 - Subjects (Part 1) - PublishSubject",
                "content": "## RxSwift: Bài 4 - Subjects (Part 1) - PublishSubject\r\n\r\n***1. Đặt vấn đề***\r\nỞ ba bài trước, bạn đã biết observable là gì? Làm sao để tạo ra nó, làm sao để subscribe nó, làm sao để dispose khi đã subscribe xong.\r\n\r\nTrong thực tế, ta muốn add new values vào observable at runtime mà sau đó sẽ emit đến subscribers. Cái ta thực sự cần đó là cái gì đó hoạt động như một observable lẫn observer. Và cái đó chính là Subject. Trong bài này ta sẽ học về các loại subjects khác nhau, cách hoạt động với từng phần và lý do tại sao bạn lại chọn nó dựa trên những trường hợp phổ biến nhất. \r\n\r\nTrước khi vào từng ví dụ cụ thể, mình sẽ ví dụ một loại subject cho các bạn dễ hình dung:\r\n\r\nTa tạo một PublishSubject. Nó sẽ nhận thông tin dữ liệu rồi quay ngược ra phát cho những subscribers của nó. Sau khi nó được khởi tạo, nó đã sẵn sàng nhận dữ liệu: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/m6q5mhgeim_Screen%20Shot%202018-02-15%20at%209.02.47%20AM.png)\r\n\r\nH ta truyền dữ liệu cho nó, ta sẽ truyền một dữ liệu cho nó trước\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/5sxyr7d0xg_Screen%20Shot%202018-02-15%20at%209.04.31%20AM.png)\r\n\r\nVà đây là kết quả:\r\n```\r\n\r\n```\r\n\r\nKhông có gì print ra được gì hết bởi vì chưa có ai subscribe nó hết, tạo 1 subscribe cho nó: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/1nxsccmjp1_Screen%20Shot%202018-02-15%20at%209.08.45%20AM.png)\r\n\r\nTheo các bạn, có in được gì không? Câu trả lời là không. Tại sao? Mình sẽ trả lời ở phần dưới, thay vào đó mình sẽ làm một đoạn code để các bạn tự đoán tại sao.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/szxsk7598k_Screen%20Shot%202018-02-15%20at%209.11.04%20AM.png)\r\n\r\nĐây là kết quả:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/jp2tkcq1f2_Screen%20Shot%202018-02-15%20at%209.11.13%20AM.png)\r\n\r\n***2. Các loại Subject***\r\nSubject là gì? Mình chỉ nhắc lại, subjects hoạt động như cả observable lẫn observer, như ví dụ trên, bạn có thể thấy nó nhận tín hiệu ở .next events và truyền tín hiệu này đến subscribe của nó. Có 4 loại subjects:\r\n```\r\n1. PublishSubject: Bắt đầu là rỗng và chỉ phát tín hiệu mới (onNext) đến subscribe\r\n2. BehaviorSubject: Bắt đầu với một giá trị khởi tạo và phát tín hiệu khởi tạo này. (nếu không nhận đc tín hiệu nào) và nếu có giá trị gần nhất thì nó sẽ phát giá trị này đến các subscribers của nó.\r\n3. ReplaySubject: Tương tự với BehaviorSubject nhưng mà nó có thêm bộ đệm với số lượng nhất định. ReplaySubject sẽ phát ra nhiều giá trị gần nhất dựa trên số lượng bộ đệm này.\r\n4. Variable: Lớp này wrap 1 BehaviorSubject, lưu giữ giá trị hiện tại như là trạng thái của nó và phát ra giá trị gần nhất/ khởi tạo đến những subscribers của nó\r\n```\r\n\r\nNào bây giờ ta bắt tay phân tích từng thằng.\r\n\r\n***3. PublishSubject***\r\n**PublishSubject được dùng khi bạn chỉ muốn subscribe để nhận những sự kiện ngay tại thời điểm bạn bắt đầu đăng kí**\r\n\r\nTrở lại ví dụ ở đầu bài, PublishSubject chỉ phát ra đến những subscribers hiện tại. Do đó nếu bạn chưa subscribe khi có gì đó đã được add trước đó, bạn sẽ không nhận được nó.\r\n\r\nHay xem sơ đồ dưới đây: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/inotu7q2cp_Screen%20Shot%202018-02-15%20at%2010.39.03%20AM.png)\r\n\r\nDòng số 1 là PublishSubject, dòng số 2, số 3 là những subscribers. Mũi tên hướng lên của subscriptions, mũi tên hướng xuống là emit ra events.\r\n\r\nSubscriber đầu tiên đăng kí sau 1) nên nó không nhận đc event này mà chỉ nhận được event 2) và 3). Subscriber thứ hai join sau 2) nên nó chỉ nhận được 3).\r\n\r\nBây giờ, quay lại code, ta sửa code một chút để dễ nhìn và thêm vào 1 subscription thứ 2, như sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/xzdmtthn6_Screen%20Shot%202018-02-15%20at%2010.55.42%20AM.png)\r\n\r\nKết quả thu được như dự đoán, chỉ có sub01 nhận được event thứ 2.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/y4rlp3u2t2_Screen%20Shot%202018-02-15%20at%2010.56.04%20AM.png)\r\n\r\nBây giờ mình thêm một dòng code vào, để có event mới: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/fwmfmuwf4u_Screen%20Shot%202018-02-15%20at%2010.59.19%20AM.png)\r\n\r\nVà kết quả là: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/obex8qk3ej_Screen%20Shot%202018-02-15%20at%2010.59.25%20AM.png)\r\n\r\nNếu bây giờ bạn lấy subscription đầu tiên và dispose nó đi rồi add thêm new event, chỉ có sub02 có giá trị. Các bạn thử đi cho hiểu.\r\n\r\nCái quan trọng nhất ở đây là: Khi một PublishSubject nhận event .completed hay là .error aka event stop, nó sẽ ngưng phát event đế những new subscriber mới cũng như không phát event nữa. **Tuy nhiên, nó vẫn sẽ phát event stop đến các subscribers trong tương lai**. Xem code dưới đây: \r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/9p5srt871z_Screen%20Shot%202018-02-15%20at%2011.28.10%20AM.png)\r\n\r\nCó rất nhiều thứ rất hay ở đây: \r\n1. Thứ nhất, mình dispose() sub01 trước khi để subject nhận event thứ 3\r\n2. Mình cho subject nhận event thứ 3 (\"Third thing\")\r\n3. Sau đó mình .complete()\r\n4. Tiếp theo mình phát tiếp tín hiệu thứ 4\r\n5. Mình tạo ra hai subscription, ở đây mình xin giải thích kĩ một chút:\r\n\t \r\n     a.  Trong cái sub03, mình chỉ để { event mà không có onNext tức là nó sẽ phát tất cả các event, mà event thì chỉ có riêng onNext mới có element. Cho nên đoạn này mình dùng nil-coalescing để unwrap cái optional này. Nếu mà là event onNext thì lấy element, ko thì lấy các event kia.\r\n   b. Trong cái sub04 thì cũng tương tự sub03, có điều mình dùng $0 sẽ tiện hơn, thay cho việc phải gọi tên cụ thể ra.\r\n \r\n Kết quả sẽ là: \r\n ![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/tap8zcuf45_Screen%20Shot%202018-02-15%20at%2012.09.50%20PM.png)\r\n \r\nThực ra thì tất cả các loại subject một khi đã chấm dứt cũng sẽ phát ra event stop cho các subscribers tương lai. Mình thấy cũng hay khi mà không chỉ biết đc nó đã kết thúc mà còn thông báo cho những đứa tiếp là mình không còn emit nữa.\r\n\r\nĐôi khi, ta cũng muốn biết những giá trị trước khi mình subscription. Đó là lý do mình có những phần khác."
                }, {
                "id": "fXDj8uK10DXK1ayb2T0cqQ",
                "title": "RxSwift: Bài 3 - Disposing and terminating",
                "content": "## RxSwift: Bài 3 - Disposing and terminating\r\n\r\n***1. Đặt vấn đề:*** \r\nNhắc lại là 1 observable sẽ không làm bất kì điều gì cho đến khi nó nhận một subscribe. Cái việc subscription này sẽ trigger hay báo hiệu cho một observable để bắt đầu phát ra các events, cứ thế cho đến khi nó phát ra sự kiện .error hoặc .completed rồi mới xong. Thực tế thì ta có thể làm việc này thủ công để khiến cho observable phải kết thúc bằng cách kết thúc tất cả các subscribe.\r\n\r\nVẫn trong ví dụ của bài 1, 2, ta thêm đoạn code sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/c4k68vgo6b_Screen%20Shot%202018-02-14%20at%207.20.30%20PM.png)\r\n\r\nTrình tự các bước như sau: \r\n1. Tạo ra một observable của một vài strings.\r\n2. Subscribe thằng observable này, lần này ta sẽ lưu cái biến trả về Disposable cho 1 local constant (đặt tên là subscription)\r\n3. Print ra các emit trong cái handler.\r\n4. Để cancel đàng hoàng một subscription, gọi dispose() nó là được. Sau khi cancel cái subscription này (hay nói cách khác là dispose nó), cái observable này hiện tại sẽ ngưng emit ra các events.\r\n\r\nQuản lí từng subscription riêng biệt nhìn khá nghiệp dư nên RxSwift đã có thêm cho ta 1 cái gọi là DisposeBag. Cái này dễ giữ các disposables, mà được add trong dispose(to: DisposeBag), và nó sẽ gọi dispose() mỗi khi subscribe này chuẩn bị deallocated. \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/cerxoj1ulv_Screen%20Shot%202018-02-14%20at%207.35.11%20PM.png)\r\n\r\nDưới đây là cách mà disposable code hoạt động: \r\n+ Tạo ra một disposeBag\r\n+ Tạo ra một observable\r\n+ Subscribe đến observable và print out ra cái giá trị được emit\r\n+ Add cái giá trị disposable đc trả về vào cái disposeBag\r\n\r\nĐây là pattern bạn sẽ dùng rất nhiều: Tạo ra observable rồi subscribe nó và add cái subscription vào 1 disposeBag\r\n\r\nTại sao lại lo lắng về vấn đề này ? Nếu bạn quên add cái subscription vào dispose bag hay add nó bằng manual hay cách nào khác khiến cho observable kết thúc ở nhiều chỗ khác nhau dẫn đến leak memory. \r\n\r\n***2. Create operator***\r\nCó một cách để lôi ra các events mà observable sẽ emit đến subscribers là create operator.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/735y02n0u7_Screen%20Shot%202018-02-14%20at%209.30.16%20PM.png)\r\n Ở đây take note 1 chút về return Disposable, Disposables.create() là một empty disposable để ai subscribe sẽ có disposable mà trả về.\r\nTrước hết, ta xem thử create có gì trong đó: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/tf1a85r2kf_Screen%20Shot%202018-02-14%20at%209.32.07%20PM.png)\r\n\r\nCái create operator này sẽ nhận 1 parameter là subscribe, nhiệm vụ của nó là tiến hành gọi observable. Hay nói cách khác, nó defines các event mà sẽ được emit đến subscribers. Subscribe này là 1 escaping closure mà lấy 1 AnyObserver và trả về 1 Disposable. \r\n\r\nAnyObserver là 1 generic type giúp cho việc add các giá trị này vào observable sequence được dễ dàng hơn, và chúng sau đó sẽ được emit đến các subscribers\r\n\r\nThe subscribe parameter is an escaping closure that takes an AnyObserver and returns a Disposable. AnyObserver is a generic type that facilitates adding values onto an observable sequence, which will then be emitted to subscribers. Change the implementation of create to the following:\r\n\r\nNhìn vào các đoạn code trên, bạn xem thử liệu onNext(?) có được gọi không? Dĩ nhiên là không, bởi vì observable đã phát ra .completed event. Ta check thử bằng cách sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/q6xocpqoo8_Screen%20Shot%202018-02-14%20at%209.45.50%20PM.png)\r\n\r\nVà kết quả sẽ là:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/pj8j0dm42r_Screen%20Shot%202018-02-14%20at%209.45.59%20PM.png)\r\n\r\n***3. Trường hợp leak memory***\r\nBây giờ, giả sử ta có lỗi thì sao? Add 1 enum ở ngoài class như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/sber57e4qk_Screen%20Shot%202018-02-14%20at%209.56.11%20PM.png)\r\n\r\nSau đó add thêm error giữa onNext và onComplete\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hncvwwtnoo_Screen%20Shot%202018-02-14%20at%209.56.25%20PM.png)\r\n\r\nKết quả sẽ là: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/fdjgdu6nto_Screen%20Shot%202018-02-14%20at%209.56.54%20PM.png)\r\n\r\nRõ ràng bạn thấy nó gọi Error ra và kết thúc, onCompleted không hề được gọi trong trường hợp này. \r\n\r\nBây giờ ta giả sử bạn ko có hàm onError và onCompleted cũng như không có disposeBag thì chuyện gì sẽ xảy ra ?\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/2ptf711yzp_Screen%20Shot%202018-02-14%20at%2010.00.25%20PM.png)\r\n\r\nKết quả là observable không bao giờ kết thúc và disposable cũng không bao giờ bị disposed dẫn đến tình trạng memory leak\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/tx0bhivzm5_Screen%20Shot%202018-02-14%20at%2010.00.37%20PM.png)\r\n\r\n***3. Observable factories***\r\nThay vì tạo ra 1 observable mà đi chờ đợi xung quanh xem có ai subscribe không, ta có thể tạo observable factories mà nó phát ra một observable cho từng subscriber\r\n\r\nXem đoạn code dưới đây:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/evp17iik5w_Screen%20Shot%202018-02-15%20at%207.44.05%20AM.png)\r\n\r\nMình xin giải thích một chút:\r\n+ Tạo ra một cờ Bool để thay đổi qua lại giữa true/ false\r\n+ Tạo ra 1 Observable của factory Int mà sử dụng deferred operator\r\n+ Lật cờ Bool- cái này sẽ được gọi mỗi khi factory được subscribe\r\n+ Return các data tương ứng với kết quả của flip\r\n\r\nThực sự, observable factory không khác mấy so với observable mà ta đã biết ở các bài trước. Thêm đoạn code này vào để check results:\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/iki7ra00i1_Screen%20Shot%202018-02-15%20at%207.52.04%20AM.png)\r\n\r\nVà kết quả là: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ehpnpiltai_Screen%20Shot%202018-02-15%20at%207.53.38%20AM.png)\r\n\r\nMỗi lần bạn subscribe đến factory, bạn sẽ nhận đc 1 observable mà flip sẽ được lật lại. Bạn lấy được 123, 456, 123, 456, cứ lập đi lập lại mỗi khi có 1 subscription đc tạo ra.\r\n\r\nNhư vậy, mình đã xong bài 3. "
                }, {
                "id": "T6bwLFgAe5IIUlRH9Rb4Mw",
                "title": "RxSwift: Bài 2 - Subscribing to observables",
                "content": "## RxSwift: Bài 2 - Subscribing to observables\r\n\r\n***1. Khái niệm***\r\n\r\nSubscribe (đăng kí) đến một RxSwift observable khá giống như NotificationCenter, thay vì addObserver(), ta dùng subscribe(). Không giống như NotificationCenter, cái mà ta hay dùng .default như là 1 singleton instance, mỗi observable trong Rx là khác nhau.\r\n\r\n**Quan trọng nhất, 1 observable sẽ không phát ra events cho đến khi có ai đó subscribe nó**\r\n\r\n\u003e Update: Chỗ này mình xin update 1 chút, 1 cold observable sẽ không phát ra events cho đến khi có ai đó subscribe nó. Và hot và cold observable là gì? Các bạn tìm hiểu thêm [ở đây](https://kipalog.com/posts/RxSwift---Phan-bo-sung---Bai-1--Hot-va-Cold-Observables).\r\n\r\n. Theo cách hiểu của mình, ta có thể giải thích vấn đề này như sau: \r\nĐịnh nghĩa của observable là 1 sequence, do đó việc subscribe đến 1 observable giống như việc mình gọi next() trong Iterator trong thư việc Swift chuẩn. \r\n\r\nTuy nhiên, subscribe đến observables được sắp xếp hợp lí hơn. Bạn cũng có thể thêm các handlers cho mỗi loại Event mà observable emit ra (bao gồm .next, .error và .completed). Một sự kiện .next sễ gửi đến 1 element hợp lệ đến handlers, và 1 .error sẽ chứa một error instance. \r\n\r\n***2. Các ví dụ:***\r\n**a. Tất cả Event**\r\nTrong bài một ta có 1 loạt các observable, bây giờ ta chọn observable1 để subscribes, observable1 có dạng như sau: \r\nlet observable1: Observable\u003cInt\u003e = Observable\u003cInt\u003e.of(one, two, three)\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/a83n6wnuip_Screen%20Shot%202018-02-14%20at%204.54.07%20PM.png)\r\n\r\nKết quả là: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/3wvqbclz7p_Screen%20Shot%202018-02-14%20at%204.55.58%20PM.png)\r\n\r\nTa phân tích kĩ một chút về subscribe, Option-click nó, bạn sẽ thấy như sau: \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gauc4kk5f4_Screen%20Shot%202018-02-14%20at%204.57.52%20PM.png)\r\n\r\nNó nhận 1 escaping closure mà lấy 1 Event kiểu Int, closure này ko trả về gì cả. Và hàm này trả về 1 Disposable. Cái disposable này mình sẽ nói đến ở bài 3. Như bạn thấy result trả về, nó có 3 lần onNext được gọi là, sau đó là onCompleted và rồi xong, kết thúc. \r\n\r\n**b. Event onNext**\r\nTa tiếp tục subscribe nó tiếp như sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/b5wqickvux_Screen%20Shot%202018-02-14%20at%205.04.17%20PM.png)\r\n\r\nEvent có 1 element property, đây là một giá trị optional, bởi vì chỉ có mỗi .next mới có element, cho nên bạn cần binding unwrap cái này nếu nó không nil. Bây giờ thì kết quả sẽ là \r\n```\r\n1\r\n2\r\n3\r\n```\r\nChỉ có mình nội dung của element xuất hiện, không còn next(1) hay không còn .completed event nữa (bởi vì completed ko có element như đã nói ở trên). Tuyệt.\r\n\r\nRx cung cấp một subscribe operator giúp cho ta lấy được hẳn element mà không cần phải unwrap các kiểu. Đó là onNext.\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ef3vvq2h58_Screen%20Shot%202018-02-14%20at%205.26.14%20PM.png)\r\n\r\nKết quả vẫn y như vậy\r\n```\r\n1\r\n2\r\n3\r\n```\r\nVới onNext bạn chỉ cần xử lý .next event mà không cần để ý cái gì khác.\r\n\r\n**c. empty operator**\r\n\r\nCái empty operator sẽ tạo ra một empty observable sequence mà không có bất kì elements nào hết, do đó nó chỉ phát ra .completed event.\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/acqfzm7flg_Screen%20Shot%202018-02-14%20at%205.39.01%20PM.png)\r\n\r\nĐối với empty operator này, observable phải được định nghĩa một cách rõ ràng, nếu không nó sẽ không thể tự biết được. Và empty thì không có gì cả, nên trong trường hợp này, Void cũng chả khác gì các type khác.\r\n\r\nỞ code trên, ta đã:\r\n1. Handle .next event như phía trên\r\n2. Print message ra trong .completed, bởi vì nó ko có bất kì elements nào hết. Và đây là kết quả: \r\n```\r\n--- Example of: Void ---\r\nCompleted\r\n```\r\nBạn thấy đấy, chỉ emit mỗi .completed. Nhưng mà empty observable này để dùng làm gì? Thực ra mình chưa gặp, theo lý thuyết nó được dùng khi mà ta muốn tạo 1 observable mà dừng ngay lập tức hay cố tình tạo 1 observable không có giá trị.\r\n\r\n**d. never operator**\r\nNever Operator này sẽ không có phát ra bất kì cái gì cả và cũng không kết thúc. Nó được sử dụng để đại diện cho 1 infinite duration. Thực ra mình cũng chưa gặp cái này lần nào. Và mình có một thắc mắc là nó ko print ra cái gì cả thì liệu làm sao mình kiểm tra nó có tồn tại hay không ?\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ckltys810c_Screen%20Shot%202018-02-14%20at%205.52.17%20PM.png)\r\n\r\n**e. Range of value**\r\nRxSwift còn có thể tạo ra 1 observable từ một khoảng các giá trị. Xem ví dụ sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/vgu236h46z_Screen%20Shot%202018-02-14%20at%205.58.59%20PM.png)\r\n\r\n\r\nTa phân tích như sau:\r\n+ Tạo ra 1 observable mà sử dụng range operator, nó sẽ bắt đầu lấy giá trị đầu tiên và bắt đầu tiếp một chuỗi tuần tự các số integer tiếp theo để generate ra.\r\n+ Tính toán và emit ra chuỗi fibo cho mỗi phần tử \r\n\r\nCho đến lúc này, ta đã làm việc với các observables mà tự động gọi .completed event và được kết thúc êm đẹp. Trong thực tế lại không được như vậy. Do đó ta cần handle việc dừng subscribe này bằng một cách khác. Gọi là disposable, ta sẽ tìm hiểu ở bài 3."
                }, {
                "id": "xOqXELUVVGzNhxerQ3zPGA",
                "title": "RxSwift: Bài 1 - Observable và Just, Of, From",
                "content": "## RxSwift: Bài 1 - Observable và Just, Of, From\r\n\r\n**Đôi lời:** Mình viết loạt bài này không phải là loạt bài tut, nó chỉ là những kiến thức mình tự hiểu và tự take note dưới góc nhìn của một newbie. Hiện giờ tài liệu RxSwift khá mơ hồ và đọc rất thiếu chiều sâu. Do đó, mình muốn viết 1 loạt bài cho những bạn mới có 1 cái gọi là tài liệu kiến thức căn bản, VÀ QUAN TRỌNG NHẤT LÀ MÌNH VIẾT BÀI NÀY CHO BẢN THÂN MÌNH ÔN LẠI KIẾN THỨC. \r\n\r\nCho nên những anh chị level cao có thể ignore loạt bài của mình hoặc giúp mình xây dựng nó tốt hơn thông qua các góp ý. Mình xin cảm ơn.\r\n\r\nTrong bài này, mình sẽ không nói Observables là gì hoặc cái khái niệm cơ bản của RxSwift vì mình thấy phần này, google có rất nhiều và rất đầy đủ, các bạn có thể search ở đó. Mình sẽ giới thiệu về just, of, from của Observables. Trước hết, ta tạo 1 function sau: \r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/6dv9u3sm4s_Screen%20Shot%202018-02-14%20at%201.34.29%20PM.png)\r\n\r\nTiếp theo, trong viewDidLoad, các bạn sử dụng lại hàm này, với define 1 vài constants, như sau:\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/s56wh3m93z_Screen%20Shot%202018-02-14%20at%201.38.28%20PM.png)\r\n\r\nỞ trên ta đã tạo một observable sequence của kiểu Int và sử dụng method \"just\" với 1 integer.\r\n\r\n***1. JUST***\r\n\r\nNgay cả cái tên just đã nói rõ, method này sẽ tạo ra 1 observable sequence mà chỉ chứa duy nhất 1 phần tử. **Trong Rx thì methods được gọi là operators (toán tử) nhiều hơn.**\r\n\r\nOption-click vào biến observable, bạn sẽ thấy là nó hiển thị là observable của kiểu Int, duy nhất 1 phần tử. \r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/3fiw5jdszu_Screen%20Shot%202018-02-14%20at%203.38.10%20PM.png)\r\n\r\nNếu bạn truyền vào một mảng, nó cũng hiển thị kiểu mảng. Nghe có vẻ hơi lạ nhưng mà nói mảng là 1 elements, ko phải nói nội dung của nó.\r\n\r\n***2. OF***\r\nVề phần *of* này, mình sẽ tạo ra 2 cái observable như sau: \r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/5vhuypocm6_Screen%20Shot%202018-02-14%20at%203.45.39%20PM.png)\r\n\r\nĐối với observable1, ta cứ nghĩ nó sẽ trả về dạng Array nhưng thực tế không phải vậy, nó sẽ trả về dạng Int bởi vì of nhận tham số variadic. \r\n\r\nOption-click vào nó, bạn sẽ thấy cụ thể: (_ elements: Int ...)\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/pvioq13opc_Screen%20Shot%202018-02-14%20at%203.50.05%20PM.png)\r\n\r\nNếu bạn muốn truyền vào 1 array thì làm như observable2, rồi truyền mảng vào cho nó. Bây giờ ta run để print cả hai observable để xem cụ thể.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/wo7n7oe89p_Screen%20Shot%202018-02-14%20at%203.56.40%20PM.png)\r\n\r\nBạn để ý sẽ thấy observable1 là Swift.Int, nó là observable của các giá trị kiểu Int, còn observable2 là Swift.Array nó là observable của 1 mảng. Bây giờ điều tiếp theo là tạo các observable của các phần tử trong mảng đó? From sẽ giải quyết vấn đề đó.\r\n\r\nBên lề 1 chút, như mình đã nói, just cũng có thế dùng để tạo 1 observable của 1 mảng vào mặc dù nó hơi kì kì.\r\n\r\n***3. FROM***\r\nFrom tạo ra 1 observable của các phần tử trong một mảng. Khi Option-click, bạn sẽ thấy nó hiển thị kiểu Int, chứ ko phải [Int]\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/378i0t1s22_Screen%20Shot%202018-02-14%20at%204.09.37%20PM.png)\r\n\r\nVà From operator chỉ nhận duy nhất Array, các kiểu khác đều không hợp lệ.\r\n\r\nNhư vậy mình đã giới thiệu xong bài 1, console của ta hiện giờ khá đơn điệu do ta chưa print gì nhiều. Qua phần sau ta sẽ tiếp tục subscribe."
                }],
    "status": 200,
    "cause": ""
}
