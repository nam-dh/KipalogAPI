{
    "content": [{
                "id": "9hoURW8SH5_1pfdudjb_1w",
                "title": "Ninja Code",
                "content": "Nếu coding giống như một trận chiến giữa programer và problem cần giải quyết thì, như những chiến binh thực thự, chúng ta tìm kiếm đạo (phương pháp chiến đấu) phù hợp cho chính mình. Trong bạt ngàn những đạo (những nguyên lý), kinh dịch (article trên blog của những blogger nổi tiếng), chú thích kinh nghiệm (những note, post được đông đảo dev `kip` lại),...đâu đó quanh đây vẫn tồn tại một đạo mà không mấy ai để ý đến nhưng số người theo thì đếm không kể hết. Có người đắc đạo hoàn toàn, có người một phần, tuy theo nhiều mức độ khác nhau nhưng tựu chung có thể coi đều là đồng đạo trong môn phái này :))\n\n\u003c!-- more --\u003e\n\n\u003e Chú ý: Bài viết lược dịch từ [đây](https://javascript.info/ninja-code). Đối với tôi, không có từ nào nhận xét tốt hơn cho bản gốc của bài viết này ngoài 2 chữ `tuyệt vời` :)).\n\nTrong khuôn khổ bài viết, đạo này được naming là __ninja đạo__ - người theo đạo được naming là các ninja (ninja đắc đạo là những ninja tuân thủ nghiêm ngặt theo những đạo lý được liệt kê trong bài viết này).\n\n# Đạo lý trong ninja đạo\n\n![Imgur](https://i.imgur.com/9gCBJvO.jpg)\n\nChúng ta sẽ cùng điểm qua những giáo lý chủ đạo của đạo phái này. (chú ý, source code sử dụng trong bài viết là javascript, tuy nhiên mở rộng ra nó có thể là bất cứ ngôn ngữ nào, bởi môn sinh theo học ninja đạo là vô biên)\n\n\u003e Rất nhiều môn sinh theo ninja đạo. Chỉ một số ít thành công.\n\u003e\n\u003e -- \u003ccite\u003eConfucius\u003c/cite\u003e\n\n## Ngắn gọn là đích đến của sự thông tuệ\n\nCode của bạn __càng ngắn gọn, bạn càng thông minh__ hơn thằng ngồi ở block bên cạnh.\n\nLấy ví dụ, tất cả chúng ta từ khi bắt đầu học lập tình đều biết đến phép toán `?` và cách nó biến đổi biểu thức điều kiện if về dạng oneline kì diệu như thế nào.\n\nXem ví dụ bên dưới:\n\n```java\n// taken from a well-known javascript library\ni = i ? i \u003c 0 ? Math.max(0, len + i) : i : 0;\n```\n\nMột ninja đạt cảnh giới cao viết những block code tuyệt vời như vậy! Sẽ chẳng có vấn đề gì nếu nó nằm sâu ngàn lớp trong một thư viện __high performance__ nào đó, nhưng điều gì sẽ xảy ra nếu người động đến đoạn code này là một môn sinh trẻ tuổi? Hẳn là môn sinh non nớt đó sẽ phải bỏ ra kha khá thời gian để bắt được giá trị của `i` khi muốn debug đoạn code này. \n\nVà rồi đến khi không thể tìm ra lời giải thích thoả đáng cho cái lỗi hắn đang phải debug, hắn sẽ tìm đến bạn (một ninja cảnh giới cao hơn) để hỏi về nó, hãy nói với hắn \"Ngắn hơn luôn tốt hơn!\", mở cho anh ta con đường đến với ninja đạo.\n\n## Biến số một chữ cái\n\n\u003e Người Dao ẩn mình bằng sự im lặng. Cái gì người Dao đã bắt đầu, chỉ người Dao biết cách kết thúc nó.\n\u003e\n\u003e -- \u003ccite\u003eLaozi (Tao Te Ching)\u003c/cite\u003e\n\nĐối với một ninja, không gì quan trọng hơn là kĩ năng ẩn mình. Vậy kĩ năng ẩn mình của một ninja đắc đạo thể hiện ở đâu? Nó thể hiện từ những thứ nhỏ nhất như là tên biến...\n\nĐặt tên biến `một-chữ-cái` (như là `a`, `b` hay `c`) giúp các ninja thượng đẳng tăng tốc độ code một cách đáng kể!\n\nTên biến một chữ cái trong 1 block code giống như những ninja ẩn trốn trong rừng cây. Không ai có thể tìm ra họ! Kể cả công cụ search của editor (`ctrl+F` hoặc `cmd+F`) cũng phải đầu hàng trước những biến này. Mặt khác kể cả khi tìm ra, không ai (trừ gã `người Dao` bên trên) biết được ý nghĩa của biến `a` hay `b` đó là gì.\n\n...Tuy nhiên vẫn có một ngoại lệ. Một ninja đắc đạo sẽ không bao giờ dùng biến một-chữ-cái như `i` để làm biến đếm trong vòng `for`. Lý do tại sao à, đơn giản là vì còn rất nhiều lựa chọn khác ngoài `i`, như `x` hay `y` chẳng hạn. \n\nMột ninja thực thụ sẽ không bao giờ để biến của anh ta dễ dàng bị bắt chỉ bởi dùng một chữ cái ai cũng biết như `i` được. Và đặc biệt, khi độ dài của vòng `loop` đó lên đến 1-2 trang (trang ở đây chỉ độ dài hiển thị source code trên một màn hình - nếu có thể, hãy cố gắng làm cho vòng for của bạn dài đến 3 trang, điều này giúp biến của bạn ẩn mình tốt hơn), khi đó bạn đã ngộ được nguyên lý để ẩn mình thực sự.\n\n## Rút....gọn\n\nNếu team của bạn có quy định về cấm sử dụng biến một-chữ-cái hoặc tên-vô-nghĩa, hãy lách luật bằng cách rút gọn chúng.\n\nMột số ví dụ như:\n- list → lst.\n- userAgent → ua.\n- browser → brsr.\n- …etc\n\nPhải là một ninja đắc đạo hoặc là có trực giác tốt mới có thể hiểu được ý nghĩa ẩn giấu dưới những cái tên này. Hãy cố gắng rút gọn mọi thứ, nó là một lớp lọc rất tốt. Chỉ những người thực sự có năng lực mới có thể hiểu và có quyền động vào source code của bạn.\n\n## Trừu tượng là mục tiêu\n\n\u003e The great square is cornerless\n\u003e The great vessel is last complete,\n\u003e The great note is rarified sound,\n\u003e The great image has no form.\n\u003e\n\u003e -- \u003ccite\u003eLaozi (Tao Te Ching)\u003c/cite\u003e\n\nKhi đặt tên biến, trong hàng trăm lựa chọn, hãy chọn cái tên trừu tượng nhất. Giống như `obj`, `data`, `value`, `item`, `elem`,...etc.\n\n+ Cái tên lý tưởng để đặt cho bất cứ biến nào là `data`, lý do đơn giản vì nó là từ chính xác nhất để miêu tả nhiệm vụ của biến - lưu trữ data!\n\nNhưng làm thế nào khi cái tên `data` đã bị một ninja khác trong team dùng mất? Hãy thử `value`! Sau cùng thì mọi biến đều sẽ nhận một giá trị nào đó, nên cái tên value là hoàn toàn có thể chấp nhận được.\n\n+ Mặt khác, bạn hoàn toàn có thể đặt tên cho biến bằng loại giá trị mà biến đó lưu. Ví dụ như: `str`, `num`,...\n\nMột môn sinh trẻ tuổi có thể ban đầu cảm thấy lạc lõng và tự hỏi kĩ năng đặt tên biến như trên có thực sự giúp ích cho một ninja? Hãy tự tin và nói với anh ta \"chắc chắn rồi!\".\n\nThật vậy, những cái tên trên thực sự vẫn mang trong nó ý nghĩa: `str` thể hiện biến đó đang lưu một chuỗi gì đó, `num` sẽ nắm giữ một số,... Nhưng khi có ai đó bên ngoài thử cố gắng hiểu đoạn code của bạn, họ sẽ bất ngờ nhận ra cái tên đó chẳng mang một ý nghĩa cụ thể nào cả :)) họ sẽ phải từ bỏ việc đào bới đoạn code và như vậy biến cùng với logic của bạn được __an toàn__ là của bạn.\n\nKhông có cách nào để thực sự hiểu được đoạn code của bạn - một ninja thượng đẳng - ngoại trừ việc dành nhiều thời gian cho nó và phải thực sự tĩnh tâm :)) Bạn sẽ bất ngờ về khả năng đọc code của môn sinh mới sau vài tháng luyện tập.\n\n+ Vậy phải làm gì khi hầu hết những cái tên phía trên đều rất dễ bị một ninja khác trước bạn dùng mất? Đơn giản, chỉ cần __THÊM SỐ VÀO__ : `data1`, `data2`, `value3`, `str4`,...etc.\n\n## Kiên định\n\nSự tập trung cũng là một trong những yếu tố phân định đẳng cấp của một ninja! Chỉ những ninja đã thực sự tập trung và kiên nhẫn mới đủ tư cách đi cùng những ninja thượng đẳng khác. Vậy làm cách nào để thử thách họ - những môn sinh non trẻ?\n\nMột cách đơn giản, hãy __sử dụng những cặp tên dễ nhầm lẫn đặt tên biến__ như là `data` \u0026 `date`. Sau đó mix chúng lại với nhau! Sẽ không ai có thể nhanh chóng đọc được source code của bạn, và rồi khi có lỗi typo (lỗi đánh máy) Uhm...chúng ta sẽ còn kẹt ở đây khá lâu, một tách trà trước khi tiếp tục không phải một ý tưởng tồi...\n\n## Tiền tố\n\n\u003e Rất khó để có thể bắt được con mèo đen trong một căn phòng tối. Nhất là khi trong đó chẳng có con mèo nào.\n\u003e\n\u003e -- \u003ccite\u003eConfucius\u003c/cite\u003e\n\nSử dụng những từ gần nghĩa là một cách khẳng định khả năng suy nghĩ linh hoạt và sáng tạo của một ninja thượng đẳng. Nó cũng làm cho code của team trở nên thú vị hơn rất nhiều :))\n\nXem xét ví dụ về tiền tố trong đặt tên. Khi muốn viết hàm hiển thị thông tin lên màn hình - hãy đặt tên nó với tiền tố `display`...chẳng hạn `displayMessage`!!! Khi có một chức năng khác cần hiển thị một cái gì đó khác lên màn hình, cố gắng tìm một từ gần nghĩa tương tự chẳng hạn `showName`! \n\nNhấn mạnh rằng __có sự khác biệt tinh tế giữa các chức năng như vậy, trong khi không có sự khác biệt nào__. Hoặc theo một hướng khác, hãy thử thảo luận và đưa ra một hiệp ước với các ninja đồng đội: Nếu như đối với chức năng hiển thị, A sẽ viết các function với tên bắt đầu bằng `display`, B sẽ bắt đầu bằng `render` còn bạn sẽ bắt đầu bằng...`paint` chẳng hạn. Càng nhiều ý tưởng, code của team sẽ càng đa dạng, môn sinh mới gia nhập càng có thêm ví dụ để thực hành. Vậy là bạn đã có sáng tạo của riêng mình và tiến thêm được một bước trên con đường ninja đạo.\n\n...Và bây giờ là thời gian dành cho mẹo vặt!\n\nNếu đã __đặt tiền tố khác nhau cho những chức năng tương tự nhau__, còn gì cản bước bạn không thực hiện nốt phần \u001dcòn lại: __đặt tên tiền tố giống nhau cho những chức năng không mấy liên quan đến nhau__?\n\nVí dụ, hàm `printPage(page)` sẽ sử dụng máy in, in trang hiện tại. Và hàm `printText(text)` sẽ hiển thị văn bản lên màn hình. Hãy để môn sinh xa lạ khi nghĩ về chức năng `printMessage(message)` - một cái tên cùng tiền tố - “Nó đặt thông điệp ở đâu? Để máy in hoặc trên màn hình? ”. Sẽ là một môn sinh đầy triển vọng nếu anh ta có thể làm cho nó thực sự tỏa sáng bằng một ý tưởng: `printMessage(message)` nên xuất nó trong cửa sổ mới!\n\n## Tái sử dụng tên (biến, hàm,...)\n\n\u003e Once the whole is divided, the parts need names.\n\u003e There are already enough names. One must know when to stop.\n\u003e\n\u003e -- \u003ccite\u003eLaozi (Tao Te Ching)\u003c/cite\u003e\n\nMột ninja giỏi biết cách tăng tối đa hiệu quả sử dụng bộ nhớ bằng cách __chỉ tạo biến mới khi thực sự cần thiết__!\n\nMột mặt tích cực khác là bạn đỡ tốn thời gian naming cho biến mới. Do đó tốt hơn cả là sử dụng lại biến với những cái tên đã có, chỉ cần __thay giá trị mới cho chúng__.\n\nMột ninja thượng đẳng có thể viết ra những function hàng chục dòng logic mà chỉ sử dụng các biến được __truyền vào dưới dạng tham số__. Một môn sinh mới sẽ cảm thấy khó khăn để xác định được chính xác giá trị tại thời điểm hiện tại của một biến nào đó, hay biến đó đến từ đâu. Một người có trực giác yếu sẽ phải phân tích đoạn mã theo từng dòng, theo dõi sự thay đổi qua mỗi nhánh mã và sau cùng tuyệt vọng chạy thử đoạn mã trên giấy...\n\nMột biến thể cao cấp của kĩ năng này là thử tráo (tạo clone) của biến đó bên trong vòng loop hoặc function. Những môn sinh yếu không hiểu rõ về những thứ như tham chiếu và tham trị thực sự sẽ phải quỳ gối trước những đoạn code như vậy.\n\n```java\nfunction ninjaFunction(elem) {\n  // 20 lines of code working with elem\n\n  elem = clone(elem);\n\n  // 20 more lines, now working with the clone of the elem!\n}\n```\n\nKhi muốn làm việc với biến `elem` ở nửa sau của hàm, thậm chí, ngay cả một ninja khác cũng có thể sẽ phải bất ngờ...Chỉ khi debug đoạn code trên từng dòng, anh ta mới có cơ hội nhận ra mình đang làm việc với bản clone của biến đó.\n\n## Thể hiện tình yêu đối với những gì bạn tạo ra\n\nHãy để những môn sinh trẻ tuổi thấy được sự tuyệt vời của những thứ bạn tạo ra! Những cái tên như `superElement`, `megaFrame` và `niceItem` chắc chắn sẽ soi sáng họ.\n\nThật vậy, một cái gì đó được naming: `super...`, `mega...`, `nice...` hẳn là một thứ tuyệt vời. Nhưng mặt khác - điều đó không mang lại bất cứ thông tin chi tiết nào. Môn sinh trẻ tuổi có thể sẽ tự ngộ ra một ý nghĩa ẩn giấu nào đó sau khi đã thiền định trong một hoặc hai giờ.\n\n## Chồng chéo các biến bên ngoài\n\n\u003e When in the light, can’t see anything in the darkness.\n\u003e When in the darkness, can see everything in the light.\n\u003e\n\u003e -- \u003ccite\u003eGuan Yin Zi\u003c/cite\u003e\n\nSử dụng __cùng một tên biến cho biến ở trong và ngoài một scope nào đó__. Ví dụ \n\n```java\nlet user = authenticateUser();\n\nfunction render() {\n  let user = anotherValue();\n  ...\n  ... //many lines...\n  ...\n  ... // \u003c-- a programmer wants to work with user here and...\n  ...\n}\n```\n\nMôn sinh trẻ tuổi đang làm việc với đoạn code bên trong function `render` sẽ không thể nhận ra có một __biến local__ khác cùng tên `user` mới thực sự là biến đang được sử dụng. Anh ta vẫn đang tưởng mình đang sử dụng biến user là kết quả của `authenticateUser()`...!!! Ok happy debugging :))\n\n## Side-effects everywhere!!!\n\nCó những chức năng giống như chúng __không thay đổi gì cả__. Những function với cái tên như `isReady()`, `checkPermission()`, `findTags()`,... Chúng được giả định để thực hiện các phép tính, tìm và trả về dữ liệu mà __không thay đổi bất kỳ thứ gì bên ngoài chúng__. Nói cách khác, chúng không có __\"side effect\"__.\n\n+ Một ninja đắc đạo biết cách __thêm vào chúng những chức năng hữu ích__ để hỗ trợ đồng đội.\n\nBiểu hiện của sự ngạc nhiên trên khuôn mặt đồng nghiệp của bạn khi anh ta thấy một chức năng có tên là `check...` hoặc `find...` thay đổi một cái gì đó - chắc chắn sẽ là lý do anh ấy rời xa bạn hơn :)).\n\n+ Một cách khác để gây ngạc nhiên cho anh bạn đồng nghiệp là __trả lại kết quả không chuẩn__.\n\nVới cách suy nghĩ còn non nớt chưa qua rèn rũa của một môn sinh, `checkPermission()` hẳn là một thứ gì đó mà sẽ trả về `true/false`, nhưng là một ninja có trách nhiệm, bạn nên trả về nhiều hơn để giúp anh ta, hãy trả về cho anh ấy một object.\n\nCho đến khi môn sinh trẻ tuổi kia viết những thứ đại loại như `if(checkPermission(...))`, anh ta sẽ tự hỏi tại sao nó không hoạt động. Nói với anh ấy: “Đọc tài liệu đi!!!”. Và __đưa cho anh ấy bài viết này__.\n\n## Powerful functions!\n\n\u003e The great Tao flows everywhere, both to the left and to the right.\n\u003e\n\u003e -- \u003ccite\u003eLaozi (Tao Te Ching)\u003c/cite\u003e\n\nĐừng giới hạn chức năng function của bạn chỉ bởi vì cái tên của nó. Hãy để cho nó làm được nhiều hơn thế.\n\nVí dụ như function `validateEmail(email)` bên cạnh việc kiểm tra tính đúng đắn của email, nó nên xuất ra thông báo về lỗi đó và gửi yêu cầu để người dùng gửi lại email chẳng hạn. Không gì tốt hơn việc __chỉ gọi một function và bạn đã có mọi thứ bạn muốn__ :)).\n\nNhững ninja giỏi biết cách giấu hàng tá logic vào trong code của họ, để không ai có thể đánh cắp chúng từ bên ngoài.\n\n![magic](https://media.giphy.com/media/12NUbkX6p4xOO4/giphy.gif)\n\n__Kết hợp nhiều logic vào trong cùng một chỗ giúp bảo vệ code của bạn khỏi nguy cơ bị tái sử dụng.__\n\nTưởng tượng một thằng ngốc nào đó trong team muốn sử dụng code của một ninja như bạn, ví dụ như hàm `validateEmail(email)` bên trên. Sau vài giờ thiền định và nhận ra function bạn viết làm được còn nhiều hơn cả những gì một gã ngốc như anh ta mong đợi (kiểm tra tính đúng đắn của email), nghiễm nhiên, anh ta sẽ bỏ cuộc và không có ý định làm phiền đến khoảng thời gian thiền định của bạn nữa.\n\n# TL;DR\n\nTất cả những __code lý__ trong __code đạo__ của ninja đạo kể trên đều từ source code có thật...Nhiều khi nó được viết bởi những developer nhiều năm kinh nghiệm, có lẽ có thể còn nhiều hơn cả bạn ;).\n\n- Tuân theo __một vài đạo lý__ trong số này, code của bạn sẽ tràn đầy sự bất ngờ.\n- Tuân theo __phần lớn đạo lý__ trong số này, code của bạn sẽ thực sự là của bạn, không ai muốn sửa hay động đến nó.\n- Tuân theo __tất cả những đạo lý__ này, code của bạn sẽ trở thành một bài học có giá trị cho các môn sinh trẻ tìm kiếm sự giác ngộ.\n\nMình tìm thấy bài viết này sau một khoảng thời gian vật lộn ở team `bugd` - một team chuyên chữa bug trên production ở công ty mình, và mình cảm thấy nó khá thấm :)).\n\nSau khi đọc xong bài viết này, hãy thử nhìn quanh và điểm xem trong những người bạn quen, ai là môn sinh, ai là ninja và ai đã đắc đạo. Nếu bạn mới chỉ là một môn sinh, không nên quá lo lắng, ninja luôn ở quanh ta, hãy tìm và học hỏi họ nhé :+1: ."
                }, {
                "id": "hcvWESKbnODBi4cvZmtJZg",
                "title": "Làm project đặt vé event hay ho của riêng bạn: Phần 1: Làm Google Form, gửi mail cho user",
                "content": "# Đôi điều tâm sự\r\nHmm đã bao giờ bạn bị nhờ là: \"Mày ơi mấy hôm nữa câu lạc bộ làm cái ì ven, mày làm cái form nào đăng kí cái là chúng nó có vé/mail báo thành công\" hay bạn là cái đứa được nhờ cũng muốn tìm hiểu :D Chẳng là ông bạn tui tính làm cái event nho nhỏ giao lưu offline trong group nên muốn cái gì đó hay ho chút nên nhờ tui làm. Mà tui lại rất là ngại mảng front-end, ngồi responsive linh ta linh tinh cũng hết bố nó 1 tuần rồi -.- (Tôi làm chậm lắm :D) nên là tôi tìm hiểu Google App Script của Google luôn.\r\n\r\n# Thế Google App Script(GAS) là cái của nợ gì?\r\nThì [GAS](https://developers.google.com/apps-script/) là một bộ script tích hợp 1 loạt cái hay ho của GG từ GG Form, Docs, Sheet nói chung là cái của nợ gì của nó cũng hay ho luôn :D Anh em lên đó xem qua thì biết\r\n\r\n# Vậy thôi bắt đầu\r\n\r\n## Trước hết làm cái Google Form cái nhỉ?\r\nGoogle Form quá dễ rồi chắc tui không hướng dẫn nữa :D Nếu lần đầu tiếp xúc thì cũng quá dễ dàng để làm quen(Nhưng tôi chắc nếu ông nào biết đến Kipa là gì thì chắc cũng phải dùng Google Form 1 lần là ít)\r\nỞ đây việc tạo như thế nào là anh em tự túc nhé :D Tui sẽ tạo 1 cái đơn giản thôi (Kiểu như thế [này](https://docs.google.com/forms/d/e/1FAIpQLSd-G-aEPMfadNxiUluKvM4ROa3ptwkwcG3QKh_EJ3xOVsdxfw/viewform)\r\n\r\n## Okay xong, ta cùng nghịch 1 chút về Script nhé\r\nĐể vào mục script ta vào trang edit của form và chọn 3 chấm -\u003e Script Editor![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/t1n28xm2uu_image.png)\r\nChính nó :3 Nó sẽ tự bắn vào 1 trang khác. ![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/adugd5exbu_image.png)\r\nVào thì sẽ có 1 file tên là Code.gs. Đây chính là trang chúng ta sẽ viết code xử lí :3 \r\nỞ đây ta có thể dùng các Trigger, libs(mình không biết gọi libs có chuẩn không) để có thể send maill (Ví dụ MailApp.sendEmail để gửi mail)\r\nOkay cùng thử nhé\r\n```js\r\nfunction myFunction() {\r\n  MailApp.sendEmail(\"nghminh163@outlook.com\",\"Xin chào bạn\", \"Lớp diu \u003c3\");\r\n}\r\n```\r\nMình sẽ thử gửi mail về cho mình\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/4k5whwtv5k_image.png)\r\nÀ các bạn lưu ý là nhớ chọn đúng function chạy vào nhé. Mặc định nó sẽ vào function myFunction(kiểu main vậy) bạn có thể chuyển, mình ở đây sẽ cứ để myFunction nhé\r\nOkay run \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/csfcx7h2j4_image.png)\r\nỞ đây nó sẽ đòi quyền gửi mail :3 App của mình mà mình cấp phép nó thôi\r\n*Nếu chưa nhận được sau khi cấp quyền hãy thử send lại nhé*\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7bb7i1xvxl_image.png)\r\nỞ đây nó nghĩ là spam :)) Cũng khá đúng nhưng mà dù sao mình cũng nhận được. Nghịch vậy thôi cùng tiếp tục với project của chúng ta nào\r\n\r\n## Bắt sự kiện người dùng submit form \r\nNếu bạn nào đã liếc qua tài liệu của Google 1 chút rồi thì thấy là nó cũng có 1 trigger là Form Submit đấy nhưng mà nó chẳng trả cái gì mấy (Docs thì đây [này](https://developers.google.com/apps-script/guides/triggers/events#form-submit_3)). Tui thì sẽ get hết response về và lấy cái response cuối cùng :D Chủ trương là như vậy nhé.\r\nTrước hết làm 1 cái function tên nó là onSubmit đã. Các bạn đặt tên gì cũng được, ở đây tui đặt theo thói quen thôi. (Xóa hết function đi để cái này cũng được hoặc các bạn có thể dùng luôn cái myFunction cũng đc)\r\nOkay tôi sẽ set trigger cho nó![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ytyz9elukb_image.png)\r\nBấm vô cái đồng hồ tí hon này này :D\r\nBấm \"No triggers set up. Click here to add one now.\"  ![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/jzqbgbuqpp_image.png)\r\nSet như mình rồi save vào là được\r\nOkay ở đây mình sẽ get cái response cuối cùng như sau\r\n```js\r\nfunction onSubmit(){\r\n   var listRes = FormApp.getActiveForm().getResponses();\r\n   var response = listRes[listRes.length-1].getItemResponses();\r\n  for(var i=0;i\u003cresponse.length;i++){\r\n      Logger.log(response[i].getItem().getTitle()); //Title của câu hỏi\r\n   \t  Logger.log(response[i].getResponse()); //Câu trả lời\r\n}}\r\n```\r\nMình sẽ save lại và thử phát. Trước khi test nhớ check lại Trigger nhé. \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mgt6fvkfov_image.png)\r\nCap cho các ông cái form :D![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ef0i68wywx_image.png)\r\nVà đây là cái log :D. Có vẻ như xong rồi đó. Nốt gửi mail báo về user là xong\r\n\r\n## Muốn mail đẹp phải thì phải dùng html nhỉ?\r\nĐúng rồi muốn mail đẹp thì phải làm file html cho nó ngon :D Trong project sẽ tạo mới 1 file html nhé\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lnxwl48zr6_image.png)\r\nNhư nói trên đó tui khá kém khoản \"hát tờ mờ lờ\" với \"cờ sờ sờ\" nên tui sẽ đơn giản như màu chữ vớ vẩn thôi :)\r\nĐể có thể đặt biến vào html này bạn dùng `\u003c?= tenbien ?\u003e`\r\nĐây mình có cái html như sau\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml\u003e\r\n  \u003cbody\u003e\r\n      \u003ch1 style=\"color:red;\"\u003e Chúng tôi xin xác minh tên bạn là: \u003c?= name ?\u003e\u003c/h1\u003e\r\n      \u003ch2 style=\"color:yellow;\"\u003eHiện tại bạn đang ở: \u003c?= address ?\u003e   \u003c/h2\u003e\r\n      \u003ch3 style=\"color:blue;\"\u003eVà tình trạng vợ con của bạn là: \u003c?= married ?\u003e  \u003c/h3\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\nOkay quay lại với cái file .gs nhé. Để import html thì ta dùng\r\n```js\r\nvar template = HtmlService.createTemplateFromFile('tenfile');\r\ntemplate.tenbien = bien\r\n```\r\nVí dụ ở đây mình có luôn i=0 thì sẽ là name, i=1 thì là địa chỉ, i=2 là tình trạng ghệ, mình ngại for nên mình sẽ set cứng giá trị luôn\r\n\r\nXong rồi dùng hàm sendEmail để send mail thôi\r\n```js\r\n  MailApp.sendEmail(emailto,title,\"\",{htmlBody:template.evaluate().getContent()});\r\n```\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lt74inakos_image.png)\r\nĐây là kết quả ta có\r\n\r\n:D Hề ở số lần sau mình sẽ hướng dẫn các bạn có thể là up cái data nên lên Firebase Firestore và dùng Cloud Function của Firebase trả về QRCode sau đó send cho user nhé. :D Cảm ơn đã đọc bài viết của mình. Mọi thắc mắc cũng như là góp ý vui lòng comment nhé. \r\n\r\n*Vì mình không đem điện thoại theo người mà cái github lại bị 2fa nên kh up source được mình để source dưới đây nhé*\r\n```html\r\n\u003c!-- response.html --\u003e\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml\u003e\r\n  \u003cbody\u003e\r\n      \u003ch1 style=\"color:red;\"\u003e Chúng tôi xin xác minh tên bạn là: \u003c?= name ?\u003e\u003c/h1\u003e\r\n      \u003ch2 style=\"color:yellow;\"\u003eHiện tại bạn đang ở: \u003c?= address ?\u003e   \u003c/h2\u003e\r\n      \u003ch3 style=\"color:blue;\"\u003eVà tình trạng vợ con của bạn là: \u003c?= married ?\u003e  \u003c/h3\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n```js\r\n//Code.gs\r\nfunction onSubmit(){\r\n   var listRes = FormApp.getActiveForm().getResponses()\r\n   var response = listRes[listRes.length-1].getItemResponses();\r\n   var name = response[0].getResponse();\r\n   var addr = response[1].getResponse();\r\n   var married = response[2].getResponse();\r\n  \r\n  var template = HtmlService.createTemplateFromFile('response');\r\n  template.name = name;\r\n  template.address = addr;\r\n  template.married = married;\r\n  \r\n  MailApp.sendEmail(\"nghminh163@outlook.com\",\"Bạn vừa đăng kí dự tiệc offline của hội không có ghệ D:\",\"\",{htmlBody:template.evaluate().getContent()});\r\n}\r\n//Bạn có thể để 1 ô nhập mail để trả về cho user nhé :D ở đây mình quên mất\r\n```"
                }, {
                "id": "nLOCPKMul498xVIdov_lVw",
                "title": "Tuyển dụng IT - Những câu chuyện dở khóc dở cười",
                "content": "**Giaosucan's blog chia sẻ kiến thức theo cách bá đạo**\r\n\r\n**http://www.giaosucan.com**\r\n\r\n##![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/baurn9mta4_image.png)\r\n\r\nFsoft là một công ty IT với hơn 10 nghìn con người, khách hàng đến từ năm châu bốn biển. Từ  Nhật Bổn , Huê Kỳ cho đến Mỹ Tho, Mù Căng Chải đủ cả.  Do đó  mà công ty có nhu cầu tuyển dụng rất lớn. Bài toán nhân lực đã tạo nên áp lực lớn cho đội ngũ tuyển dụng ở đây, và cũng tạo nên nhưng giai thoại cười ra nước mắt.\r\nĐể phục vụ cho công tác tuyển dụng, Fsoft build một đội ngũ tuyển dụng hùng hậu, gọi tắt là đội REC (recruitment), toàn các em gái xinh như mộng, chân dài đến nách, da trắng như Bạch Tuyết, tóc đen như gỗ mun, tóm lại là hàng tuyển, đảm bảo hạ gục ứng viên ngay từ cái nhìn đầu tiên\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/qr1rwiiir9_image.png)\r\n## Đăng tuyển ứng viên\r\nKhi đơn vị có dự án,  HR, các sếp chỉ thị xuống đội REC, yêu cầu tuyển dụng ứng viên ở các level khác nhau như Developer, Solution Architect, PM, biết ngôn ngữ .NET, Java, ABC. Xyz \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/d4ioc8dmsf_image.png)\r\nThường thì những vị trí như coder, tester trình độ nhàng nhàng thì dễ kiếm, nhưng khi tìm ứng viên ở trình độ PM hay SA thì quả là một thách thức đối với đội REC. giống kiểu mò kim đáy bể\r\nNhân viên REC sẽ phải tìm kiếm ứng viên trên LinkedIn, Facebook, các trường đại học… Thời buổi này nếu chỉ đăng tin tuyển dụng kiểu truyền thống, đúng theo lề phải như “Fsoft cần 10 developer .NET”, “Cần xxx Java developer “ thì xác định ứng viên bấm next luôn. Cho nên các bạn đã sử dụng những mẩu tin tuyển dụng cực kì sáng tạo. Không Like, Share không được\r\nChú nào không gửi CV cho chị là hư quá\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lce63hlvyq_image.png)\r\nEm gái xinh như mộng hẹn café thì ai lại từ chối?\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/x0g68dr9zd_image.png)\r\nCác thể loại to và cứng\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/m8vax023ls_image.png)\r\nPhong cách người lạ ơi.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/4ncik3koxp_image.png)\r\nNội dung chưa đủ, bonus cả hình để cưa đổ ứng viên. Tuy nhiên được làm chủ nhân của cái em cầm hoa này thì vẫn ổn hơn là cái lẵng hoa, tiếc là em ý có bình rồi.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7mrg2iywh4_image.png)\r\nNghèo tiền bạc anh ngại, nhưng nghèo quần áo thì ok\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/svieuca43u_image.png)\r\nThực tế hình thức đăng tin PR trên Facebook, kiểu này cũng khá hiệu quả. Mình cơ duyên vào Fsoft cũng qua những tin tuyển dụng thế này, do thấy em tuyển dụng nhìn cool quá nên đồng ý liên hệ, gặp em siêu cá sấu chắc chạy mất dép…\r\n## Tán tỉnh ứng viên\r\nĐối với những bạn ứng viên như sinh viên mới ra trường, ít năm kinh nghiệm thì không mất nhiều thời gian, nhưng đối với những kĩ sư level cao, nhiều năm kinh nghiệm thì việc thuyết phục họ nộp CV, và interview còn khó hơn cả cưa mấy em hoa hậu. Bởi vì những bạn này thuộc dạng “mình giỏi mình có quyền”, đều có công việc ổn định lương cao và đặc biệt họ có nhiều lựa chọn giữa các công ty. Đất lành thì chim đậu, công ty nào chế độ đãi ngộ tốt, môi trường thăng tiến thì sẽ làm. Đại loại không làm chỗ này thì làm chỗ kia, chán Ngọc Trinh thì chuyển sang Thủy Top, không thiệt, chỉ có công ty là thiệt.\r\nSau khi đã tìm được ứng viên trên LinkedIn, Facebook, đưa vào tầm ngắm thì bắt đầu là các loại tin nhắn, email, skype dội bom tới tấp, tiếng tây tiếng ta đủ cả, y như thả thính.\r\nNội dung chính là công việc với mức lương hấp dẫn\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/eatovhgkyh_image.png)\r\n\r\nKhi thính đã được thả cả chùm, bạn nào đớp thính sẽ đến bước 2 là alo, trao đổi qua điện thoại. tranh thủ hẹn hò café với các ứng viên tiềm năng để trao đổi tâm tư tình cảm, giới thiệu công ty, chế độ đãi ngộ, cơ hội thăng tiến, tóm lại chỉ cần bạn giỏi, còn cả thế giới công ty sẽ lo. Thực tế trong ngành IT đa phần ứng viên là nam, nếu có em gái xinh tươi nhắn tin hẹn café tâm sự thì cũng khó từ chối. \r\n## Bị ứng viên tán\r\nCông cuộc tán tỉnh này cũng sinh ra nhiều câu chuyện giở khóc, giở cười, tóm lại nhân viên tuyển dụng xinh đẹp dễ thương cũng là một lợi thế. Có chồng hay không không quan trọng, quan trọng là em cute ngọc nát vẫn hơn ngói lành\r\nNhiều bạn Rec thay vì tán ứng viên là bị ứng viên tán ngược lại theo kiểu hồi mã thương.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/v1uc0x33va_image.png)\r\nBị ứng viên úp sọt\r\nCái nghề này thì việc bị úp sọt, leo cây là chuyện thường như ở huyện. Nhiều ứng viên đồng ý hẹn interview xong thì cancel, thậm chí có bạn đã chốt deal, đợi kí hợp đồng xong thì … bùng. Y như kiểu làm con người ta có bầu rồi quất ngựa truy phong.\r\nCảm giác có thể nói là thốn vô cùng\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/xusqt6mg5x_image.png)\r\n\r\nĐiều này không thể trách ứng viên, khi hợp đồng chưa kí, ván chưa đóng thuyền thì mọi thứ có thể xảy ra. Các doanh nghiệp cạnh tranh nhau về lương bổng, đãi ngộ, nếu ứng viên tìm thấy chỗ tốt hơn thì họ sẽ nhẩy thôi.\r\n\r\n ![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/jn54c16e4h_image.png)\r\n\r\n Đến ngay cả kí xong đi làm, còn nghỉ việc được, chỉ khổ cho các em tuyển dụng chỉ biết ngồi lòng đau như cắt, nước mắt tuôn rơi\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/9uoxhxdvfv_image.png)\r\nỨng viên kí hợp đồng\r\nNỗi buồn đi liền với niềm vui, khi một ứng viên pass interview và kí hợp đồng, nhất là trường hợp “hàng hiếm”, trình độ cao thì cảm giác muốn bùng cháy vì đã hoàn thành nhiệm vụ.\r\nRelated image\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7j355ij715_image.png)\r\n\r\n## Kết luận\r\nNghề tuyển dụng là một nghề có đủ mọi cung bậc cảm xúc, hị nộ ái ố. Tâm trạng thay đổi như  4 mùa, sáng nắng chiều mưa, tối rét run, sáng mai bão tố. Người làm nghề Rec phải hết sức tỉnh táo, phải nắm bắt thông tin thị trường lao động, đối mặt với nhiều khó khăn. Các công ty có được nguồn nhân lực trình độ cao có công lao đóng góp không nhỏ của đội ngũ REC"
                }, {
                "id": "jYiZqfzDlFJw1BhlEO98KA",
                "title": "Muốn theo nghề lập trình bắt đầu từ đâu? (một góc nhìn từ “Khảo sát của Stack Overflow năm 2018”)",
                "content": "#Muốn theo nghề lập trình bắt đầu từ đâu? (một góc nhìn từ “Khảo sát của Stack Overflow năm 2018”)\r\n##1.\tVề Stack Overflow\r\n* Là một mạng xã hội lớn, uy tín của các lập trình viên trên thế giới\r\n* Giúp các lập trình viên tìm kiếm giải pháp cho các vấn đề gặp phải trong công việc hàng ngày; là nơi mỗi cá nhân thể hiện trình độ của mình thông qua việc giúp đỡ các đồng nghiệp khác; tuyển người làm \u0026 tìm việc làm\r\n* Jeff Atwood và Joel Spolsky (người Mỹ) sáng lập Stack Overflow năm 2008\r\n* Hơn 50M lượt người truy cập mỗi tháng, trên 14M câu hỏi, trên 19M trả lời\r\n* Thực hiện các khảo sát hàng năm, năm nay là lần thứ 8, với hơn 100.000 lập trình viên đang làm việc tại 183 quốc gia và vùng lãnh thổ tham gia khảo sát\r\n* Nội dung khảo sát liên quan đến ngành lập trình\r\n\r\n##2.\tNên chọn công việc nào để theo học\r\nDanh sách sau là một số công việc phổ biến của nghề lập trình, đồng thời cho biết tỉ lệ của mỗi công việc dựa trên số người được khảo sát. Tham khảo để chọn sẽ theo học cái gì? Thông thường, nên chọn công việc có nhiều người đang làm, tức thị trường đang cần nhiều. Hoặc có người đang làm nghĩa là có nhu cầu tuyển dụng, vì vậy học cái gì cũng được, nếu thực sự đam mê. Tuy nhiên, nếu chưa thử hết các công việc làm sao biết mình thích cái nào hơn cái nào? Cần người tư vấn và tự trải nghiệm?\r\n\r\nLoại công việc - Tỉ lệ người đang làm/Tổng số người tham gia khảo sát\r\n\r\n* Back-end developer - 57.9%\r\n* Full-stack developer - 48.2%\r\n* Front-end developer\t- 37.8%\r\n* Mobile developer\t- 20.4%\r\n* Desktop or enterprise applications developer\t- 17.2%\r\n* Student\t- 17.1% (người khảo sát đang là sinh viên, không phải một loại công việc)\r\n* Database administrator\t- 14.3%\r\n* Designer\t- 13.1%\r\n* System administrator\t- 11.3%\r\n* DevOps specialist\t- 10.4%\r\n* Data or business analyst\t- 8.2%\r\n* Data scientist or machine learning specialist\t- 7.7%\r\n* QA or test developer\t- 6.7%\r\n* Engineering manager\t- 5.7%\r\n* Embedded applications or devices developer\t- 5.2%\r\n* Game or graphics developer\t- 5.0%\r\n* Product manager\t- 4.7%\r\n* Educator or academic researcher\t- 4.0%\r\n* C-suite executive (CEO, CTO, etc.)\t- 3.8%\r\n* Marketing or sales professional\t- 1.2%\r\n\r\n##3.\tMức lương của mỗi công việc\r\n\r\nNgoài yếu tố dễ xin việc, hợp với đam mê của bản thân, cũng nên quan tâm tới mức lương của mỗi công việc. Tất nhiên, lương cao thì đòi hỏi trình độ, kinh nghiệm, áp lực công việc cũng cao.\r\nDưới đây là danh sách các loại công việc và mức lương tương ứng (lưu ý:  không phải lương áp dụng cho người đang làm việc tại Việt nam)\r\n\r\nLoại công việc\t- Mức lương\t\r\n\r\n* Engineering manager\t- $89,000\r\n* DevOps specialist\t- $72,000\r\n* Data scientist or machine learning specialist\t- $60,000\r\n* Data or business analyst\t- $59,000\r\n* Embedded applications or devices developer\t- $59,000\r\n* Full-stack developer\t- $59,000\r\n* Desktop or enterprise applications developer\t- $57,000\r\n* Back-end developer\t- $56,000\r\n* System administrator\t- $56,000\r\n* QA or test developer\t- $55,000\r\n* Database administrator\t- $51,000\r\n* Front-end developer\t- $51,000\r\n* Designer\t- $46,000\r\n* Educator or academic researcher\t- $44,000\r\n* Mobile developer\t- $43,000\r\n* Game or graphics developer\t- $40,000\r\n\r\n\r\n##4.\tChọn công nghệ nào để theo\r\nVới mỗi công việc có thể lựa chọn nhiều công nghệ khác nhau, bao gồm: ngôn ngữ lập trình, cơ sở dữ liệu, mã nguồn mở hay đóng, trình viết mã, framework, thư viện.\r\n###4.1\tNgôn ngữ\r\nDưới đây là danh sách các ngôn ngữ phổ biến đang được mọi người sử dụng,\r\n\r\nNgôn ngữ\t- Tỉ lệ người đang sử dụng/Tổng số người tham gia khảo sát\r\n* JavaScript\t71.5%\r\n* HTML\t- 69.4%\r\n* CSS\t- 66.2%\r\n* SQL\t- 58.5%\r\n* Java\t- 45.4%\r\n* Bash/Shell\t- 40.4%\r\n* Python\t- 37.9%\r\n* C#\t- 35.3%\r\n* PHP\t- 31.4%\r\n* C++\t- 24.6%\r\n* C\t- 22.1%\r\n* TypeScript\t- 18.3%\r\n* Ruby\t- 10.3%\r\n* Swift\t- 8.3%\r\n* Objective-C\t- 7.3%\r\n* Go\t- 7.2%\r\n* Assembly\t- 6.9%\r\n* VB.NET\t- 6.9%\r\n* R\t- 6.0%\r\n* Matlab\t- 5.5%\r\n* VBA\t- 4.8%\r\n* Kotlin\t- 4.7%\r\n* Groovy\t- 4.5%\r\n* Scala\t- 4.5%\r\n* Perl\t- 4.2%\r\n\r\n\r\n###4.2\tCơ sở dữ liệu\r\nDưới đây là danh sách các cơ sở dữ liệu phổ biến đang được mọi người sử dụng,\r\n\r\nCơ sở dữ liệu\t- Tỉ lệ người đang sử dụng/Tổng số người tham gia khảo sát\r\n* MySQL\t- 58.7%\r\n* SQL Server\t- 41.2%\r\n* PostgreSQL\t- 32.9%\r\n* MongoDB\t- 25.9%\r\n* SQLite\t- 19.7%\r\n* Redis\t- 18.0%\r\n* Elasticsearch\t- 14.1%\r\n* MariaDB\t- 13.4%\r\n* Oracle\t- 11.1%\r\n* Microsoft Azure (Tables, CosmosDB, SQL, etc)\t- 7.9%\r\n* Google Cloud Storage\t- 5.5%\r\n* Memcached\t- 5.5%\r\n* Amazon DynamoDB\t- 5.2%\r\n* Amazon RDS/Aurora\t- 5.1%\r\n* Cassandra\t- 3.7%\r\n* IBM Db2\t- 2.5%\r\n* Neo4j\t- 2.4%\r\n* Amazon Redshift\t- 2.2%\r\n* Apache Hive\t- 2.2%\r\n* Google BigQuery\t- 2.1%\r\n* Apache Hbase\t- 1.7%\r\n\r\n\r\n###4.3\tFramework, thư viện, công cụ\r\n\r\nDưới đây là danh sách các framework, thư viện, công cụ phổ biến đang được mọi người sử dụng,\r\n\r\nFramework, thư viện, công cụ - Tỉ lệ người đang sử dụng/Tổng số người tham gia khảo sát\r\n* Node.js (JS)\t- 49.6%\r\n* Angular (JS)\t- 36.9%\r\n* React (JS)\t- 27.8%\r\n* .NET Core\t- 27.2%\r\n* Spring (Java)\t- 17.6%\r\n* Django (Python)\t- 13.0%\r\n* Cordova (JS mobile)\t- 8.5%\r\n* TensorFlow (Machine Learning)\t- 7.8%\r\n* Xamarin (mobile app)\t- 7.4%\r\n* Spark (Java)\t- 4.8%\r\n* Hadoop (big data, distributed data)\t- 4.7%\r\n* Torch/PyTorch (deep learning – python)\t- 1.7%\r\n\r\n\r\n###4.4\tTrình viết mã\r\nDưới đây là danh sách trình soạn thảo mã nguồn (IDE, code editor) đang được mọi người sử dụng,\r\n\r\nIDE, code editor - Tỉ lệ người đang sử dụng/Tổng số người tham gia khảo sát\r\n* Visual Studio Code\t- 34.9%\r\n* Visual Studio\t- 34.3%\r\n* Notepad++\t- 34.2%\r\n* Sublime Text\t- 28.9%\r\n* Vim\t- 25.8%\r\n* IntelliJ\t- 24.9%\r\n* Android Studio\t- 19.3%\r\n* Eclipse\t- 18.9%\r\n* Atom\t- 18.0%\r\n* PyCharm\t- 12.0%\r\n* Xcode\t- 10.6%\r\n* PHPStorm\t- 9.0%\r\n* NetBeans\t- 8.2%\r\n* IPython / Jupyter\t- 7.4%\r\n* Emacs\t- 4.1%\r\n* Rstudio\t- 3.3%\r\n* RubyMine\t- 1.6%\r\n* TextMate\t- 1.1%\r\n* Coda\t- 0.6%\r\n* Komodo\t- 0.6%\r\n* Zend\t- 0.4%\r\n* Light Table\t- 0.2%\r\n\r\n###4.5\tCác nhóm công nghệ liên quan\r\nHình sau là các nhóm công nghệ liên quan, (nguồn: stackoverflow)\r\n \r\n ![alt](https://cdn.sstatic.net/insights/Img/Survey/2018/tech_network-1.svg?v=d48aa121744c)\r\n###4.6\tMột số hướng đang được quan tâm nhiều\r\n* Web\r\n* Mobile\r\n* IoT\r\n* Machine Learning\r\n* Data Science\r\n\r\n##5.\tTài liệu tham khảo\r\n[1] http://travisnguyen.net/selfpondering/2018/04/28/stackoverflow-history/\r\n[2] https://en.wikipedia.org/wiki/Joel_Spolsky\r\n[3] https://en.wikipedia.org/wiki/Jeff_Atwood\r\n[4] https://en.wikipedia.org/wiki/Stack_Overflow\r\n[5] https://insights.stackoverflow.com/survey/2018\r\n\r\n\r\nLeGiaCong 05-06-2018"
                }, {
                "id": "hoSSxR1pY6B_SrmIIZYVGA",
                "title": "Tuốt tuồn tuột về Promise và async/await",
                "content": "**Bài viết gốc được đăng ở Ê-ku [https://ehkoo.com/bai-viet/tat-tan-tat-ve-promise-va-async-await](https://ehkoo.com/bai-viet/tat-tan-tat-ve-promise-va-async-await)**\r\n\r\n---\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/uaulqha86j_image.png)\r\n_`Promise.race([blueTuktuk, greenMotobike, redTractor])` -- Hình minh họa của [Ken Wong](http://www.kenart.net/)_\r\n\r\n\u003e Chời, thời này ai xài Promise nữa. Chuẩn bây giờ là async/await.\r\n\u003e -- _Ai đó trên mạng_\r\n\r\nHãy khoan bạn ơi, đừng vội nhảy lên chuyến tàu tốc hành async/await trong khi chưa rành Promise, kẻo lại xảy ra \"va chạm khi dồn dịch\", gây nên hậu quả khôn lường, vì căn bản async/await vẫn dùng Promise ở bên dưới mà thôi.\r\n\r\nCùng xem lại những khái niệm căn bản của Promise, đồng thời so sánh với async/await để xem khi nào thì nên xài hàng nào nhé.\r\n\r\n### Nhắc lại, Promise là gì?\r\n\r\nPromise là một _cơ chế_ trong JavaScript giúp bạn thực thi các tác vụ bất đồng bộ mà không rơi vào _callback hell_ hay _pyramid of doom_, là tình trạng các hàm callback lồng vào nhau ở quá nhiều tầng. Các tác vụ bất đồng bộ có thể là gửi AJAX request, gọi hàm bên trong `setTimeout`, `setInterval` hoặc `requestAnimationFrame`, hay thao tác với WebSocket hoặc Worker... Dưới đây là một callback hell điển hình.\r\n\r\n```js\r\napi.getUser('pikalong', function(err, user) {\r\n  if (err) throw err\r\n  api.getPostsOfUser(user, function(err, posts) {\r\n    if (err) throw err\r\n    api.getCommentsOfPosts(posts, function(err, comments) {\r\n      // vân vân và mây mây...\r\n    })\r\n  })\r\n})\r\n```\r\n\r\nVí dụ trên khi được viết lại bằng Promise sẽ là:\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e api.getPostsOfUser(user))\r\n  .then(posts =\u003e api.getCommentsOfPosts(posts))\r\n  .catch(err =\u003e { throw err })\r\n```\r\n\r\nĐể tạo ra một promise object thì bạn dùng class Promise có sẵn trong trình duyệt như sau:\r\n\r\n```js\r\nconst p = new Promise( /* executor */ function(resolve, reject) {\r\n  // Thực thi các tác vụ bất đồng bộ ở đây, và gọi `resolve(result)` khi tác\r\n  // vụ hoàn thành. Nếu xảy ra lỗi, gọi đến `reject(error)`.\r\n})\r\n```\r\n\r\nTrong đó, `executor` là một hàm có hai tham số:\r\n* `resolve` là hàm sẽ được gọi khi promise hoàn thành\r\n* `reject` là hàm sẽ được gọi khi có lỗi xảy ra\r\n\r\nVí dụ:\r\n\r\n```js\r\napi.getUser = function(username) {\r\n  // Hàm api.getUser() trả về một promise object\r\n  return new Promise((resolve, reject) =\u003e {\r\n    // Gửi AJAX request\r\n    http.get(`/users/${username}`, (err, result) =\u003e {\r\n\r\n      // Nếu có lỗi bên trong callback, chúng ta gọi đến hàm `reject()`\r\n      if (err) return reject(err)\r\n\r\n      // Ngược lại, dùng `resolve()` để trả dữ liệu về cho `.then()`\r\n      resolve(result)\r\n\r\n    })\r\n  })\r\n}\r\n```\r\n\r\nNhư vậy `api.getUser()` sẽ trả về một promise object. Chúng ta có thể truy xuất đến kết quả trả về bằng phương thức `.then()` như sau:\r\n\r\n\r\n```js\r\nfunction onSuccess(user) { console.log(user) }\r\nfunction onError(err) { console.error(error) }\r\n\r\napi.getUser('pikalong')\r\n  .then(onSuccess, onError)\r\n```\r\n\r\nPhương thức `.then(onSuccess, onError)` nhận vào hai hàm: `onSuccess` được gọi khi promise hoàn thành và `onError` được gọi khi có lỗi xảy ra. Bên trong tham số `onSuccess` bạn có thể trả về một giá trị đồng bộ, chẳng hạn như giá trị số, chuỗi, `null`, `undefined`, array hay object; hoặc một **promise object** khác. Các giá trị bất đồng bộ sẽ được bọc bên trong một Promise, cho phép bạn kết nối (chaining) nhiều promises lại với nhau.\r\n\r\n```js\r\npromise()\r\n  .then(() =\u003e { return 'foo' })\r\n  .then(result1 =\u003e {\r\n     console.log(result1) // 'foo'\r\n     return anotherPromise()\r\n  })\r\n  .then(result2 =\u003e console.log(result2)) // `result2` sẽ là kết quả của anotherPromise()\r\n  .catch(err =\u003e {})\r\n```\r\n\r\nTrong ví dụ trên, bạn thấy đến phương thức `.catch()`. Phương thức này chỉ là _cú pháp bọc đường_ (syntactic sugar) của `.then(null, onError)` mà thôi. Chúng ta sẽ nói thêm về `.catch()` ở bên dưới.\r\n\r\n#### Tạo nhanh Promise với `Promise.resolve()` và `Promise.reject()`\r\n\r\n Có những trường hợp bạn chỉ cần bọc một giá trị vào promise hay tự động reject. Thay vì dùng cú pháp `new Promise()` dài dòng, bạn có thể dùng hai phương thức tĩnh `Promise.resolve(result)` và `Promise.reject(err)`\r\n\r\n```js\r\nconst p = Promise.resolve(12)\r\n  .then(result =\u003e console.log(result)) // 12\r\n  .then(res =\u003e Promise.reject(new Error('Dừng lại nhanh')))\r\n  .then(() =\u003e 'Cười thêm phát nữa là tym anh đứt phanh')\r\n  .catch(err =\u003e console.error(err)) // Error: Dừng lại nhanh\r\n```\r\n\r\n### Còn async/await là cái chi?\r\n\r\nĐược giới thiệu trong ~~ES7~~ ES8, async/await là một _cơ chế_ giúp bạn thực hiện các thao tác bất đồng bộ một cách _tuần tự_ hơn. Async/await vẫn sử dụng Promise ở bên dưới nhưng mã nguồn của bạn (theo một cách nào đó) sẽ trong sáng và dễ theo dõi.\r\n\r\nĐể sử dụng, bạn phải khai báo hàm với từ khóa `async`. Khi đó bên trong hàm bạn có thể dùng `await.`\r\n\r\n```js\r\nasync function() {\r\n  try {\r\n    const user = await api.getUser('pikalong')\r\n    const posts = await api.getPostsOfUser(user)\r\n    const comments = await api.getCommentsOfPosts(posts)\r\n\r\n    console.log(comments)\r\n  } catch (err) {\r\n    console.log(err)\r\n  }\r\n}\r\n```\r\n\r\nCăn bản về Promise và async/await là vậy. Hiện giờ, bạn đã có thể sử dụng Promise và async/await ở tất cả các trình duyệt hiện đại (trừ IE11 ra nhé, bạn vẫn cần polyfill cho nó). Hãy xem những trường hợp cần lưu ý khi sử dụng chúng.\r\n\r\n### Vài lưu ý\r\n\r\n#### \"Kim tự tháp\" Promises\r\n\r\nMột lỗi chúng ta hay mắc phải khi mới làm quen với Promise, đó là tạo ra \"kim tự tháp\" promises như thế này.\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e {\r\n     api.getPostsOfUser(user)\r\n       .then(posts =\u003e {\r\n         api.getCommentsOfPosts(posts)\r\n         .then(comments =\u003e {\r\n           console.log(comments)\r\n         })\r\n         .catch(err =\u003e console.log(err))\r\n       })\r\n       .catch(err =\u003e console.log(err))\r\n  })\r\n  .catch(err =\u003e console.log(err))\r\n```\r\n\r\nLý do vì chúng ta quên mất tính chất liên kết (chaining) của promise, cho phép bên trong hàm `resolve` có thể trả về một giá trị đồng bộ hoặc **một promise** khác. Do đó cách giải quyết là:\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  // Trả về một promise\r\n  .then(user =\u003e api.getPostsOfUser(user))\r\n  .then(posts =\u003e api.getCommentsOfPosts(posts))\r\n  .catch(err =\u003e { throw err })\r\n```\r\n\r\nViệc hiểu và sử dụng thành thạo tính liên kết là một trong những điểm **QUAN TRỌNG NHẤT** khi làm việc với Promise. Khi promise lồng vào nhau từ 2 tầng trở lên thì đã đến lúc bạn phải refactor lại rồi.\r\n\r\n#### Luôn đưa vào `.then()` một hàm\r\n\r\nBạn thử đoán xem đoạn code sau sẽ in ra gì?\r\n\r\n```js\r\nPromise.resolve(1)\r\n  .then(2)\r\n  .then(console.log)\r\n```\r\n\r\nCâu trả lời là `1` đó. Phương thức `.then` đòi hỏi tham số của nó phải là một hàm. Nếu bạn đưa vào `.then()`  một giá trị, nó sẽ bị bỏ qua, giải thích tại sao đoạn code trên hiển thị `1`. Trường hợp tương tự:\r\n\r\n```js\r\nPromise.resolve(1)\r\n  .then(Promise.resolve(2))\r\n  .then(console.log) // 1\r\n```\r\n\r\nCách giải quyết:\r\n\r\n```js\r\nPromise.resolve(1)\r\n  .then(() =\u003e 2)\r\n  // hoặc như thế này, mặc dù hơi dư thừa\r\n  .then(() =\u003e Promise.resolve(2))\r\n  .then(console.log) // 2\r\n```\r\n\r\nChúng ta sẽ được kết quả như ý.\r\n\r\n#### Cẩn thận với `this` khi dùng tham chiếu hàm\r\n\r\nGiả sử bạn có đoạn code sau:\r\n\r\n```js\r\nconst add2 = x =\u003e x + 2\r\n\r\nPromise.resolve(4).then(result =\u003e add2(result))\r\n```\r\n\r\nHàm `onSuccess` không làm gì khác ngoài việc chuyển `result` vào cho `add2`, nên bạn có thể dùng tham chiếu hàm để đoạn code trên gọn hơn.\r\n\r\n```js\r\nPromise.resolve(4).then(add2)\r\n```\r\n\r\nBạn có thể nghĩ, vậy với phương thức của một đối tượng, ta cũng có thể đưa tham chiếu hàm vào `.then()`?\r\n\r\n```js\r\nclass User {\r\n  constructor(user) {\r\n    this.user = user\r\n  }\r\n\r\n  getUsername() {\r\n    return this.user.username\r\n  }\r\n}\r\n\r\nconst u = new User({ username: 'pikalong' })\r\nPromise.resolve()\r\n  .then(u.getUsername)\r\n  .then(console.log)\r\n```\r\n\r\nNhưng bạn lại nhận được lỗi sau:\r\n\r\n\u003e Unhandled rejection:[TypeError: Cannot read property 'user' of undefined]\r\n\r\nLý do là vì khi trong [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode), biến ngữ cảnh `this` chỉ được xác định khi trực tiếp gọi phương thức của đối tượng đó, hoặc thông qua `.bind()`. Bạn có thể xem giải thích chi tiết hơn [ở đây](https://stackoverflow.com/a/34930887).\r\n\r\nĐể giải quyết lỗi này, bạn có thể dùng một trong những cách sau:\r\n\r\n```js\r\n.then(() =\u003e u.getUsername())\r\n\r\n// hoặc\r\n.then(u.getUsername.bind(u))\r\n\r\n// hoặc dùng hàm mũi tên khi khai báo phương thức trong class (cần plugin\r\n// `transform-class-properties` của Babel)\r\nclass User {\r\n  // ...\r\n  getUsername = () =\u003e {\r\n    return this.user.username\r\n  }\r\n}\r\n```\r\n\r\n#### Chạy các Promise tuần tự\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mvo4pyqi2f_image.png)\r\n\r\nTrong trường hợp muốn chạy các promises một cách tuần tự như sơ đồ ở trên, bạn có thể dùng hàm `Array.prototype.reduce` .\r\n\r\n```js\r\n[promise1, promise2, promise3].reduce(function(currentPromise, promise) {\r\n  return currentPromise.then(promise)\r\n}, Promise.resolve())\r\n\r\n// Đoạn ở trên khi được viết dài dòng ra\r\nPromise.resolve().then(promise1).then(promise2).then(promise3)\r\n```\r\n\r\nAsync/await mang đến giải pháp \"xinh đẹp\" hơn, cho phép bạn truy xuất đến giá trị của các promises phía trước nếu cần thiết.\r\n\r\n```js\r\nasync function() {\r\n  const res1 = await promise1()\r\n  const res2 = await promise2(res1)\r\n  const res3 = await promise3(res2)\r\n}\r\n```\r\n\r\n#### Chạy nhiều Promises cùng lúc với Promise.all()\r\n\r\nLại có trường hợp bạn muốn thực thi và lấy ra kết quả của nhiều promises cùng lúc. Giải pháp \"ngây thơ\" sẽ là dùng vòng lặp, hoặc `.forEach`.\r\n\r\n```js\r\nconst userIds = [1, 2, 3, 4]\r\n\r\n// api.getUser() là hàm trả về promise\r\nconst users = []\r\nfor (let id of userIds) {\r\n  api.getUser(id).then(user =\u003e ([...users, user]))\r\n}\r\n\r\nconsole.log(users) // [], oát-đờ-heo?\r\n```\r\n\r\nLý do là vì khi promise chưa kịp resolve thì dòng `console.log` đã chạy rồi. Chúng ta có thể sửa bằng cách dùng `Promise.all([promise1, promise2, ...])`. Phương thức này nhận vào một mảng các promises và chỉ resolve khi tất cả các promises này hoàn thành, hoặc reject khi một trong số chúng xảy ra lỗi.\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/wo4f8pe9f6_image.png)\r\n\r\n```js\r\nconst userIds = [1, 2, 3, 4]\r\n\r\nPromise.all(usersIds.map(api.getUser))\r\n  .then(function(arrayOfResults) {\r\n    const [user1, user2, user3, user4] = arrayOfResults\r\n  })\r\n```\r\n\r\nNếu dùng async/await  thì...\r\n\r\n```js\r\nasync function() {\r\n  const userIds = [1, 2, 3, 4]\r\n  const [user1, user2, user3, user4] = await Promise.all(usersIds.map(api.getUser))\r\n}\r\n```\r\n\r\n#### Đừng quên Promise.race()\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/43qbia9hn1_image.png)\r\n\r\nNgoài hai kiểu chạy tuần tự và song song ở trên, chúng ta còn có `Promise.race([promise1, promise2, ...])`. Phương thức này nhận vào một mảng các promises và sẽ resolve/reject ngay khi một trong số các promises này hoàn thành/xảy ra lỗi.\r\n\r\n```js\r\nPromise.race([\r\n  ping('ns1.example.com'),\r\n  ping('ns2.example.com'),\r\n  ping('ns3.example.com'),\r\n  ping('ns4.example.com')\r\n]).then(result =\u003e {})\r\n```\r\n\r\n#### Cẩn thận với `return` không tường minh\r\n\r\nXét hai đoạn mã sau:\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e {\r\n    return api.getPostsByUser(user)\r\n  })\r\n  .then(console.log) // posts\r\n\r\napi.getUser('pikalong')\r\n  .then(user =\u003e {\r\n    api.getPostsByUser(user)\r\n  })\r\n  .then(console.log) // undefined\r\n```\r\n\r\nĐoạn mã thứ hai trả về `undefined` vì trong JavaScript nếu một hàm không _công khai_ trả về một giá trị, `undefined` mặc định sẽ được trả về ([nguồn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions)). Do đó, bạn cần lưu ý về giá trị `return` khi làm việc với Promise.\r\n\r\n#### Phân biệt `.then(resolve, reject)` và `.then(resolve).catch(reject)`\r\n\r\nHàm `reject` trong `.then(resolve, reject)` chỉ có thể chụp được lỗi từ những `.then()` phía trước nó, mà không thể bắt được lỗi xảy ra trong hàm `resolve` cùng cấp.\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e { throw new Error('Lỗi rồi bạn ei') }, err =\u003e { /* Không có gì ở đây cả */ })\r\n\r\napi.getUser('pikalong')\r\n  .then(user =\u003e { throw new Error('Lỗi rồi bạn ei') })\r\n  .catch(err =\u003e console.log(err)) // Chụp được rồi bạn ei\r\n```\r\n\r\nLưu ý là promise sẽ dừng quá trình thực thi khi bắt được lỗi\r\n\r\n```js\r\nPromise.resolve()\r\n  .then(() =\u003e { throw 'foo' })\r\n  .then(() =\u003e { throw 'bar' }, err =\u003e { console.error(\"here\", err) })\r\n  .catch(err =\u003e console.error('final', err))\r\n\r\n// console:\r\n// \"here bar\"\r\n```\r\n\r\n#### Truyền dữ liệu giữa các promises với nhau\r\n\r\nMột trong những yếu điểm của Promise là không có cơ chế mặc định để bạn truyền dữ liệu giữa các promise objects với nhau. Nghĩa là:\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e api.getPostsByUser(user))\r\n  .then(posts =\u003e {\r\n    // Muốn sử dụng biến user ở trên thì làm sao đây?\r\n  })\r\n```\r\n\r\nMột cách là dùng `Promise.all()`.\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e Promise.all([user, api.getPostsByUser(user)]))\r\n  .then(results =\u003e {\r\n     // Dùng kỹ thuật phân rã biến trong ES6. Bạn lưu ý chúng ta dùng 1 dấu , để\r\n     // tách ra phần tử thứ hai của mảng mà thôi\r\n     const [ , posts ] = results\r\n\r\n     // Lại tiếp tục truyền dữ liệu bao gồm [user, posts, comments] xuống promise sau\r\n     return Promise.all([...results, api.getCommentsOfPosts(posts)])\r\n  })\r\n```\r\n\r\nHoặc, nếu bạn cảm thấy phân tách mảng khó dùng vì phải nhớ thứ tự của các giá trị thì ta có thể dùng object như sau:\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e api.getPostsByUser(user).then(posts =\u003e ({ user, posts })))\r\n  .then(results =\u003e api.getCommentsOfPosts(results.posts).then(comments =\u003e ({ ...results, comments })))\r\n  .then(console.log) // { users, posts, comments }\r\n```\r\n\r\nLại một lần nữa, async/await lại tỏa sáng vì giúp bạn truy xuất đến kết quả của những promises phía trước.\r\n\r\n```js\r\nasync function() {\r\n  const user = await api.getUser('pikalong')\r\n  const posts = await api.getPostsOfUser(user)\r\n  const comments = await api.getCommentsOfPosts(posts)\r\n}\r\n```\r\n\r\n#### Cẩn thận nha, Promise không lazy\r\n\r\nVới đoạn code sau:\r\n\r\n```js\r\nconsole.log('before')\r\nconst promise = new Promise(function fn(resolve, reject) {\r\n  console.log('hello')\r\n  // ...\r\n});\r\nconsole.log('after')\r\n```\r\n\r\nKết quả được in ra console lần lượt sẽ là:\r\n\r\n```bash\r\nbefore\r\nhello\r\nafter\r\n```\r\n\r\nBạn có thể thấy hàm `executor` của Promise được thực thi ngay lập tức. Điều này có thể dẫn đến những kết quả không mong muốn, chẳng hạn như:\r\n\r\n```jsx\r\nconst getUsers = new Promise((resolve, reject) =\u003e {\r\n  return http.get(`/api`, (err, result) =\u003e  err ? reject(err) : resolve(result))\r\n})\r\n\r\nbutton.onclick = e =\u003e getUsers\r\n```\r\n\r\nCách giải quyết là đưa vào một hàm trả về promise.\r\n\r\n```js\r\nconst getUsers = () =\u003e new Promise((resolve, reject) =\u003e {\r\n  return http.get(`/api`, (err, result) =\u003e  err ? reject(err) : resolve(result))\r\n})\r\n\r\nbutton.onclick = e =\u003e getUsers()\r\n```\r\n\r\n#### Cuối cùng, `.finally()`\r\n\r\nBên cạnh `.then()` và `.catch()`, chúng ta còn có `.finally(onFinally)`. Phương thức này nhận vào một hàm và sẽ được kích hoạt dù cho promise trước nó hoàn thành hay xảy ra lỗi.\r\n\r\n```js\r\nshowLoadingSpinner()\r\napi.getUser('pikalong')\r\n  .then(user =\u003e {})\r\n  .catch(err =\u003e {})\r\n  .finally(hideLoadingSpinner)\r\n\r\n// async/await\r\nasync function() {\r\n  try {\r\n    showLoadingSpinner()\r\n    api.getUser('pikalong')\r\n  } catch(err) {\r\n  } finally {\r\n    hideLoadingSpinner()\r\n  }\r\n}\r\n```\r\n\r\nBạn có thể đọc thêm về `Promise.prototype.finally()` [ở đây](https://ehkoo.com/bai-viet/promise-finally-duoc-gioi-thieu-tu-google-chrome-63). Lưu ý là phương thức này hiện chỉ được hỗ trợ bởi Firefox, Chrome và Opera thôi nhé.\r\n\r\n### Kết\r\n\r\nBạn có thể thấy Promise và async/await không hoàn toàn thay thế mà hỗ trợ lẫn nhau. Mặc dù chúng ta có thể dùng async/await ở đa số các trường hợp, Promise vẫn là nền tảng cần thiết khi thực thi các tác vụ bất đồng bộ trong JavaScript. Do đó bạn nên xem xét và lựa chọn giải pháp phù hợp, tùy vào tình hình thực tế nhá.\r\n\r\n#### Đọc thêm\r\n\r\n[_Using Promises_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises) -- MDN\r\n\r\n[_We have a problem with Promise_](https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html) -- Nolan Lawson\r\n\r\n[_Promise is the wrong abstraction_](http://anttih.com/articles/2017/12/25/promise-is-the-wrong-abstraction) -- Antti Holvikari\r\n\r\n[_Promises are not neutral enough_](https://staltz.com/promises-are-not-neutral-enough.html) -- André Staltz\r\n\r\n#### Đính chính\r\n\r\n- Bài viết này ban đầu có nói async/await được giới thiệu trong ES7. Thật ra là ES8 - ES2017 mới đúng. Cám ơn @nhducit đã góp ý."
                }, {
                "id": "BOwT4l1iwO1lBG3eova0Pw",
                "title": "Tối ưu hiệu suất MongoDB bằng cách quản lý index",
                "content": "Ai cũng biết đánh index giúp tăng tốc các truy vấn tìm kiếm, tìm kiếm trong cây index (B-Tree) sẽ nhanh hơn scan trong toàn bộ bảng. Ai cũng biết nên không nói nhiều về index là gì nữa :trollface: vậy nhé.\r\n\r\nĐây là [MongoDB users dataset](https://github.com/xluffy/assets/blob/master/users.bson.gz) bạn có thể tải về chơi thử. \r\n\r\n## 1. Sơ sơ về index\r\n\r\nIndex trong Mongo cũng tương tự các cơ sở dữ liệu quan hệ, ví dụ ta có một index được định nghĩa như sau:\r\n\r\n```\r\ndb.users.createIndex({\r\n  user_status: 1\r\n}, {\r\n  background: true,\r\n  name: 'idx_users_by_user_status'\r\n});\r\n```\r\n\r\nCâu trên sẽ nói với database build một index dựa trên giá trị của field `user_status` của collection `users`. \r\n\r\nNgoài ra nó có thêm một tùy chọn là `backgroud: true` để build index ở dạng backgroud, thông thường đánh index sẽ block tất cả các operation khác, và với các collection có kích thước lớn thì việc đánh index sẽ tốn tới vài giờ để hoàn thành và trong thời gian này database sẽ không thể response, đánh index `background` để tránh tính trạng block các operation khác [nhưng không hẳn đời lúc nào cũng như mơ].\r\n\r\nLưu ý là nên chạy query đánh index trong `tmux` để tránh rớt kết nối và để kiểm tra process của index ta có thể truy vấn:\r\n\r\n```\r\ndb.currentOp(\r\n  { \"msg\": /Index Build/ }\r\n);\r\n\r\n\"msg\" : \"Index Build (background) Index Build (background): 3305028/574961784 0%\"\r\n```\r\n\r\nOk, tiếp tục với index phía trên, nó sẽ có tác dụng với các truy vấn tìm kiếm với điều kiện là field `user_status`, ví dụ như sau:\r\n\r\n```\r\ndb.users.find({\r\n  \"user_status\": \"new_user\"\r\n});\r\n```\r\n\r\nKhông có gì phải bàn cãi thêm, truy vấn trên sử dụng index `idx_users_by_user_status` và trả về kết quả với tốc độ của một vị thần gió. :triumph:\r\n\r\nGiờ giả sử, ta có một truy vấn lấy ra tất cả các user `confirmed` NHƯNG trong một tháng của năm 2013 như sau:\r\n\r\n```\r\nvar start = ISODate(\"2013-04-01T00:00:00Z\");\r\nvar end = ISODate(\"2013-04-30T23:59:59Z\");\r\n\r\ndb.users.find({\r\n\t\"user_status\": \"confirmed\",\r\n\t\"created_at\": { $gte: start, $lte: end}\r\n});\r\n```\r\n\r\nTương tự như trên, lấy ra danh sách các `confirmed` khá nhanh chóng do sử dụng index như câu truy vấn trên cùng, tuy nhiên trong danh sách trả ra `confirmed` ta cần lọc thêm một lần nữa để lấy ra các user đăng kí trong tháng đó, và do `created_at` không được đánh index nên có bao nhiêu `confirmed` thì ta cần quét toàn bộ từng đấy.\r\n\r\nĐể giải quyết truy vấn trên, ta cần đánh index trên 2 field, gọi là **compound index** như sau:\r\n\r\n```\r\ndb.users.createIndex({\r\n  user_status: 1,\r\n  created_at: 1 \r\n}, {\r\n  background: true, \r\n  name: 'idx_users_by_user_status_and_created_at' \r\n});\r\n```\r\n\r\nOk, trong có vẻ ngon rồi, truy vấn của chúng ta đã nhanh hơn rồi. Nhưng thử nghĩ xem, chúng ta có thể làm tốt hơn hay không nhỉ?\r\n\r\nGiả sử bạn có 20 triệu register user (hoặc bạn có thể tưởng tượng bạn có 1 tỷ register user và bạn giàu hơn Mark Zuckerberg :slightly_smiling_face: cũng được) `user_status` có các giá trị sau:\r\n\r\n  - new_user\r\n  - confirmed\r\n  - banned\r\n  - deleted\r\n\r\nNếu không có index trên `user_status`, bạn cần quét hết 20 triệu docs này, đánh index trên `user_status` con số giảm từ 20 triệu -\u003e 5 triệu (1/4).\r\n\r\nGiờ giả sử, start-úp mặt của bạn ra đời năm 2015, đến bây giờ là 3 năm, giả sử user đăng kí đồng đều giữa các ngày (thực tế thì đéo phải như vậy đâu  :sweat_smile:). Bạn index lại như sau:\r\n\r\n```\r\ndb.users.createIndex({\r\n  created_at: 1,\r\n  user_status: 1\r\n}, {\r\n  background: true,\r\n  name: 'idx_users_by_created_at_user_status'\r\n});\r\n```\r\n\r\nGiờ với câu truy vấn trên, ta được một danh sách các user đăng ký trong vòng 1 tháng, là cỡ hơn 500 ngàn user (1 ngày có ~ 18 ngàn user đăng ký), sau đó lọc theo điều kiện `new_user` ta chỉ cần quét trong tập 500k user này so với 5 triệu như cách đánh index ban đầu.\r\n\r\nChốt lại, với **compound index** nên đánh index field có giá trị uniqe nhiều hơn trước. Ở trên thì đánh `created_at` trước vì các giá trị trong field này hầu hết đều khác nhau (trong khi `user_status` chỉ có 4 giá trị), nên sẽ giảm được vùng tìm kiếm của truy vấn nhiều hơn.\r\n\r\n## 2. How to improve\r\n\r\nXong xuôi việc đánh index, bây giờ làm cách nào để ta có thể chắc chắn rằng database sẽ sử dụng index một cách hiệu quả? Index cũng như dữ liệu, được lưu trữ trên đĩa cứng, và để index có thể được sử dụng hiệu quả thì tốt nhất là nó nên được đặt trên RAM. Trong Mongo, RAM thì thường được sử dụng để giữ các dữ liệu và index thường xuyên truy vấn (WiredTiger internal cache) tránh phải đọc đĩa thường xuyên. Recommend là 50% physical memory, ví dụ server có 32GB thì WiredTiger internal cache là 15GB.\r\n\r\nNhưng data thì lúc nào cũng lớn hơn RAM, bạn không thể đặt toàn bộ dữ liệu lên Wiredtiger cache được, với index cũng vậy, đánh index thì các truy vấn đọc dữ liệu trên điều kiện sẽ nhanh, nhưng quá nhiều index dư thừa thì gây ra 2 vấn đề:\r\n\r\n- Không thể chứa tất cả các index trên memory.\r\n- Làm chậm các truy vấn ghi dữ liệu như Insert/Update/Delete -\u003e nhưng thực ra \r\nnếu phần ghi chiếm tới 80-95% thì việc đánh đổi cũng đáng kể.\r\n\r\nBạn có thể kiểm tra kích thước tổng thể của index trên cơ sở dữ liệu như sau:\r\n\r\n```\r\ndb.runCommand({ dbStats: 1, scale: 1 });\r\n{\r\n    \"db\" : \"test\",\r\n    \"collections\" : 2,\r\n    \"objects\" : 2000000,\r\n    \"avgObjSize\" : 96.120665,\r\n    \"dataSize\" : 192241330,\r\n    \"storageSize\" : 374370304,\r\n    \"numExtents\" : 0,\r\n    \"indexes\" : 6,\r\n    \"indexSize\" : 53964800,\r\n    \"ok\" : 1\r\n}\r\n```\r\n\r\nCụ thể hơn (dữ liệu này ăn cắp trên production)\r\n\r\n```\r\ndb.stats().indexSize\r\n86508650496\r\n```\r\n\r\n=\u003e kích thước của tất cả các index trên CSDL là 86GB, có nghĩa là index không thể fit hết trên memory, nên khi nào cần sử dụng tới index, nếu index đó không có sẵn trên memory thì cần đọc index đó từ đĩa lên.\r\n\r\nNói chung, xác định bao nhiêu memory là cần thiết không dễ, bạn có thể trả lời vài câu hỏi sau để tự xác định và điều chỉnh memory cho hợp lý:\r\n\r\n- Độ lớn data của bạn là bao nhiêu?\r\n- Độ lớn của index là bao nhiêu?\r\n- Độ phát triển của dữ liệu (trong 1 tháng, 1 năm?)\r\n- Độ lớn của tập dữ liệu thường xuyên truy cập nhất (gọi là working set)?\r\n\r\nVậy chiến lược để giữ index có kích thước nhỏ là như thế nào?\r\n\r\n### 2.1 Xóa các index không sử dụng\r\n\r\n```\r\ndb.users.aggregate([ { $indexStats: {} } ]);\r\n[{\r\n\t\"name\": \"idx_users_by_created_at_user_status\",\r\n\t\"key\": {\r\n\t\t\"created_at\": 1,\r\n\t\t\"user_status\": 1\r\n\t},\r\n\t\"host\": \"6b1b716ae456:27017\",\r\n\t\"accesses\": {\r\n\t\t\"ops\": NumberLong(456550227),\r\n\t\t\"since\": ISODate(\"2018-05-31T15:31:09.020Z\")\r\n\t}\r\n} {\r\n\t\"name\": \"idx_users_by_user_status\",\r\n\t\"key\": {\r\n\t\t\"user_status\": 1\r\n\t},\r\n\t\"host\": \"6b1b716ae456:27017\",\r\n\t\"accesses\": {\r\n\t\t\"ops\": NumberLong(277641131),\r\n\t\t\"since\": ISODate(\"2018-05-31T15:05:39.148Z\")\r\n\t}\r\n} {\r\n\t\"name\": \"_id_\",\r\n\t\"key\": {\r\n\t\t\"_id\": 1\r\n\t},\r\n\t\"host\": \"6b1b716ae456:27017\",\r\n\t\"accesses\": {\r\n\t\t\"ops\": NumberLong(0),\r\n\t\t\"since\": ISODate(\"2018-05-31T15:03:12.197Z\")\r\n\t}\r\n}]\r\n``` \r\n\r\nỞ ví dụ trên, ta có 3 index, ở giá trị `accesses`, ta thấy 2 index đầu tiên được sử dụng rất nhiều lần, trong khi đó index thứ 3 không hề được sử dụng. Con số bao nhiêu là hợp lí để loại bỏ một index tùy thuộc vào số lượng truy vấn và nghiệp vụ của chính bạn, bạn có thể tự cân nhắc, đo lường và loại bỏ nếu không cần thiết.\r\n\r\nCần lưu ý, `ops` có thể bị reset, con số hiện tại thể hiện số lần được sử dụng kể từ `since` -\u003e thời gian mongod được restart.\r\n\r\n### 2.2 Loại bỏ các index dư thừa\r\n\r\n```\r\ndb.users.aggregate([ { $indexStats: {} } ])\r\n[{\r\n\t\"name\": \"idx_users_by_user_status_created_at\",\r\n\t\"key\": {\r\n\t\t\"user_status\": 1,\r\n\t\t\"created_at\": 1\r\n\t},\r\n\t\"host\": \"6b1b716ae456:27017\",\r\n\t\"accesses\": {\r\n\t\t\"ops\": NumberLong(456550227),\r\n\t\t\"since\": ISODate(\"2018-05-31T15:31:09.020Z\")\r\n\t}\r\n} {\r\n\t\"name\": \"idx_users_by_user_status\",\r\n\t\"key\": {\r\n\t\t\"user_status\": 1\r\n\t},\r\n\t\"host\": \"6b1b716ae456:27017\",\r\n\t\"accesses\": {\r\n\t\t\"ops\": NumberLong(277641131),\r\n\t\t\"since\": ISODate(\"2018-05-31T15:05:39.148Z\")\r\n\t}\r\n}]\r\n```\r\n\r\nỞ ví dụ trên, cả 2 index đều được sử dụng. Tuy nhiên index đầu tiên có thể làm cho index thứ 2 trở lên dư thừa, vì các truy vấn chỉ trên điều kiện `user_status` có thể sử dụng index đầu tiên mà không có vấn đề gì.\r\n\r\n### 2.3 Sử dụng sparse index\r\n\r\nĐây là kiểu đánh index trên điều kiện, ví dụ ta có 20 triệu user, nhưng nếu ta chỉ thường truy vấn `user_status` là `new_user` thì ta có thể đánh index riêng với tập `new_user` thôi -\u003e giả sử số lượng `new_user` là 40% trên tổng số user -\u003e index của chúng ta sẽ giảm xuống tới 60% kích thước.\r\n\r\n### 2.4 Giảm bớt kích thước của collection\r\n\r\nCách duy nhất để giảm kích thước của collection đó là ... **xóa dữ liệu**, thực tế có những nghiệp vụ lưu trữ logs, events không cần giữ quá 1-2 năm để tra cứu thì ta có thể xóa bớt các dữ liệu không còn cần thiết (hoặc di chuyển nó sang một CSDL khác với tần suất tuy vấn thấp hơn). Khi kích thước của collection giảm, kích thước của index cũng sẽ giảm theo và data/index có thể fit vừa trên RAM.\r\n\r\n### 2.4 Giữ index đơn giản\r\n\r\nCompound index rất lợi hại trong trường hợp truy vấn dữ liệu trên nhiều điều kiện khác nhau, tuy nhiên nó cũng tốn chi phí bảo trì và dữ liệu càng lớn thì index size sẽ càng tăng nhanh. Tương tự như truy vấn, cố gắng giữ cho index một cách đơn giản nhất có thể.\r\n\r\n## 3. Bonus\r\n\r\nĐáng ra đéo có phần này, [nhưng sợ anh em lại bảo thằng chuyên bài trừ Mongo mà nay lại viết về Mongo](http://whyyoushouldusemongodb.com), thấy sai sai thế éo nào nên phải viết thêm tí.\r\n\r\nThật ra những lý thuyết trên về index và quản lý index đều có thể áp dụng cho các cơ sở dữ liệu quan hệ như MySQL hay PostgreSQL. Ví dụ với PostgreSQL cũng có index trên điều kiện đó là partial index tương tự như sparse index (MySQL thì không biết có không).\r\n\r\nBản chất, nếu để ý sẽ thấy các hệ CSDL có rất nhiều đặc điểm giống nhau (kể cả M$ SQL), lý thuyết này có thể áp dụng cho CSDL khác, và ngược lại. Cốt lõi của vấn đề là **tư duy** về việc **đo lường**, cách thức đo lường và đánh giá hiệu quả của mỗi hành động tác động lên hệ thống\r\n\r\nLần sau sẽ viết thêm về một số thứ liên quan đến metric trong CSDL quan hệ, hỗ trợ cho việc tối ưu hệ thống tương tự như trên MongoDB.\r\n\r\n## 4. Ref\r\n\r\n- https://mixmax.com/blog/improving-mongo-performance-by-managing-indexes\r\n- https://github.com/ozlerhakan/mongodb-json-files\r\n- https://docs.mongodb.com/manual/tutorial/ensure-indexes-fit-ram\r\n\r\n--------\r\n\r\nBài viết gốc được đăng tải tại [https://xluffy.github.io/post/improving-mongodb-perf-by-managing-indexes](https://xluffy.github.io/post/improving-mongodb-perf-by-managing-indexes)"
                }, {
                "id": "CaRI4fgU5Js6m-_4CafQFA",
                "title": "Functional Programming - Phần 3 - Buông bỏ",
                "content": "- [Phần 1: Con đường sáng](https://kipalog.com/posts/Functional-Programming---Phan-1---Con-duong-sang)\n- [Phần 2: Nhập đạo](https://kipalog.com/posts/Functional-Programming---Phan-2---Nhap-dao) \n\n\nFunctional Programming là một con đường khác, một phương pháp tư duy khác trong coding. Ở tầm nhìn trừu tượng hơn, người ta xếp Functional Programming vào nhóm \"Declarative\", còn OOP thuộc nhóm \"Imperative\".\n\nTừ các bài học ngữ pháp chúng ta đã biết 2 kiểu câu: câu trần thuật (Declarative Sentence), và câu mệnh lệnh (Imperative Sentence).\n\nLập trình theo lối \"Imperative Programming\" là sắp xếp một loạt các mệnh lệnh liên tiếp, để máy tính thực thi tuần tự từng bước. Ở đây người ta tập trung vào \"how\". Nào, hãy làm thế này, rồi làm thế kia... Một hình thức \"cầm tay chỉ việc\". \n\nVí dụ trên trang web có 4 boxes màu đỏ thế này:\n\n```\n\u003cstyle\u003e\n.box {\n  width: 100px;\n  height: 100px;\n  float: left;\n  margin: 10px;\n  background-color: red;\n}\n.hide {\n  display: none;\n}\n\u003c/style\u003e\n\u003cdiv class=\"box hide\"\u003e\u003c/div\u003e\n\u003cdiv class=\"box hide\"\u003e\u003c/div\u003e\n\u003cdiv class=\"box hide\"\u003e\u003c/div\u003e\n\u003cdiv class=\"box hide\"\u003e\u003c/div\u003e\n\n```\n\nMấy boxes này đang ẩn, ta cần làm chúng hiện ra bằng cách loại bỏ class \"hide\" đi.\n\nCác giáo viên tin học đáng kính ở trường xưa thường dạy viết kiểu như thế này:\n\n```\n// tìm hết các tags có class \"box':\nconst els = document.querySelectorAll('.box');\n// quét tất cả các tags tìm thấy\nfor (let i = 0; i \u003c els.length; i++) {\n  // với tag thứ i\n  let el = els[i];\n  // xóa bỏ class \"hide\" để cho tag hiện lên\n  el.classList.remove('hide');\n  // nếu còn phần tử phía sau thì tăng i lên 1 đơn vị\n  // quay lại với xử lý tag thứ i + 1\n}\n```\n\nHọ dùng code hướng dẫn cho máy tính làm từng nhiệm vụ.\n\nNgười tu luyện Functional Programming không tư duy theo cách đó.\n\n### No for/while\n\n \"Declarative Programming\" là tập trung vào \"what\". Chúng ta chỉ cần định nghĩa những quy tắc đầu vào, đầu ra. Chẳng hạn \"nếu input là 1 thì output là 2\". Phần còn lại để máy tính xử lý.\n\nNgười tu luyện Functional Programming không cần for loop.\n\nCode như thế này nhìn mới mẻ hơn nhiều:\n\n```\nconst getElements = (selector) =\u003e {\n  return Array.from(document.querySelectorAll(selector));\n};\n\nconst getRemover = (el) =\u003e {\n  return (className) =\u003e {\n    el.classList.remove(className);\n    return el;\n  };\n};\n\nconst els = getElements('.box')\n  .map(getRemover)\n  .map(removeClass =\u003e removeClass('hide'));\n  \nconsole.log(els);\n```\n\nTrước tiên chúng ta tạo ra 1 pure function `getElements` dùng để lấy các elements trên trang thông qua CSS Selector. Tập hợp này vốn là ArrayLike, ta dùng `Array.from` chuyển thành Array thực sự để có thể tận dụng các phương thức trong Array prototype.\n\nỞ đây ta định nghĩa input là CSS Selector, output là 1 mảng DOM Elements.\n\nCòn `getRemover` lại là 1 higher-order function. Có thể gọi nó bằng cách chaining `getRemover(DOMElement)(classToRemove)`. Chúng ta lợi dụng đặc tính của higher-order function, sau 2 lần map thì chạm tới function do `getRemover` ném lại.\n\nỞ đây ta định nghĩa input là DOM Element, output là `function() {nhận input là className và output là DOM Element đã mất đi class đó}`.\n\nCode như vậy ta có thể đem logic dùng lại ở nhiều chỗ khác nhau, chỉ cần thay đổi input. Ví dụ loại bỏ class `float-left` khỏi tất cả các thẻ div.\n\n```\nconst els = getElements('div')\n  .map(getRemover)\n  .map(removeClass =\u003e removeClass('float-left'));\n```\n\n### No if/else\n\nNgười tu luyện Functional Programming cũng không cần if/else.\n\nThậm chí họ còn tạo ra cả một chiến dịch [Anti-IF](https://francescocirillo.com/pages/anti-if-campaign)!\n\nCó nhiều cách để loại bỏ hoàn toàn `if/else` ra khỏi chương trình của bạn. Đơn giản nhất là dùng ternary.\n\n#### Ternary\n\nTrong JavaScript, ternary - tam phân - có tên gọi chính thức là Toán tử Điều kiện - Conditional Operator. Nó là cách viết ngắn gọn của `if/else`.\n\nHãy xem đoạn code dài dòng, rẽ nhánh phức tạp như sau:\n\n```\nlet title = 'Mr.';\nif (person.gender === 'female') {\n  if (!person.gotMarried) {\n    title = 'Ms.';\n  } else {\n    title = 'Mrs.';\n  }\n}\n```\n\nCó thể được viết gọn lại thành:\n\n```\nconst title = person.gender === 'female' ? (!person.gotMarried ? 'Ms.' : 'Mrs.') : 'Mr.';\n```\n\nKhông còn `if/else` nữa.\n\nTa cũng vô hình trung loại bỏ được `var`, `let` vì không cần gán lại giá trị cho `title`.\n\n#### Logical operators\n\nCách thứ 2 là khai thác sức mạnh ngầm của các logical operators `\u0026\u0026`, `||`. Đây là những toán tử logic. Hôm trước có bạn viết  [1 cái TIL ngắn](https://kipalog.com/posts/--va--) khá hay. Sau đây ta quan sát chúng kỹ hơn qua lăng kính Functional Programming.\n\nGiả sử có đoạn code như sau:\n\n```\nconst sayHello = () =\u003e {\n  console.log('Hello, bonjour, nihao');\n  return true;\n};\n\nconst doNothing = () =\u003e {\n  console.log('Do nothing');\n  return false;\n};\n\nconst greet = (hasClient) =\u003e {\n  if (hasClient) {\n    sayHello();\n  } else {\n    doNothing();\n  }\n}\n\ngreet(true); // =\u003e 'Hello, bonjour, nihao'\ngreet(false); //=\u003e 'Do nothing'\n```\n\nVề mặt logic, hàm `greet()` kiểm tra điều kiện nếu có khách thì chào, nếu không thì không làm gì cả.\n\nTheo định nghĩa của `\u0026\u0026`  và `||`, chúng ta biết:\n\n- `expr1 \u0026\u0026 expr2`  trả về `expr1` nếu `expr1` là falsy, ngoài ra nó trả về `expr2`. \n\nMột điều thú vị ở đây là JavaScript engine luôn ước lượng giá trị biểu thức logic dạng này từ trái sang phải và theo nguyên tắc \"đoản mạch\" - [short-circuit evaluation](https://en.wikipedia.org/wiki/Short-circuit_evaluation)\".  Tiên hữu nào giỏi Vật lý chắc còn nhớ hiện tượng \"đoản mạch\", đó là khi dòng điện không chạy qua tải hoặc chỉ chạy qua một phần.\n\nVì AND chỉ trả về `true` nếu cả 2 mệnh đề cùng đúng, nên ngay khi bắt gặp `expr1` sai, nó lập tức kết luận mệnh đề ghép là Sai và chấm dứt tại đó luôn, không chạy qua nửa bên phải `expr2` nữa.\n\n- `expr1 || expr2`  trả về `expr1` nếu `expr1` là truthy, ngoài ra nó trả về `expr2`. \n\nVì OR trả về `true` nếu ít nhất 1 mệnh đề đúng, nên ngay khi bắt gặp `expr1` đúng, nó lập tức kết luận mệnh đề ghép là Đúng và bỏ qua `expr2`. \n\nShort-circuit thần thánh! \n\nCác lập trình viên kinh nghiệm thường lợi dụng đặc điểm này để tối ưu hiệu suất chương trình. Họ để các biểu thức tính toán phức tạp ở nửa sau của biểu thức logic. Như vậy, khi chưa rơi vào hoàn cảnh thích hợp, chúng sẽ bị bỏ qua, không cần tốn resource xử lý.\n\nTới đây, ta đã có thể viết lại hàm `greet()` một cách bí hiểm như sau:\n\n```\nconst greet = (hasClient) =\u003e {\n  return (hasClient || doNothing()) \u0026\u0026 sayHello();\n}\n```\n\nBắt đầu phần nằm trong ngoặc đơn bên trái `\u0026\u0026`. Nếu `hasClient` là `true` thì giá trị phần này cũng là `true`, `doNothing()` bị bỏ qua.\n\nVì phần bên trái của `\u0026\u0026` là `true` nên cuối cùng, giá trị biểu thức quy về phần bên phải `\u0026\u0026`, tức là `sayHello()`.\n\nLập luận tương tự cho trường hợp `hasClient` là `false`, dòng chảy chương trình lập tức rẽ sang `doNothing()`. Lúc này giá trị nửa bên trái `\u0026\u0026` là `false`, do đó không cần quan tâm đến `sayHello()` nữa.\n\nViết như trên vừa độc vừa lạ, vừa khử được `if/else`, mà vẫn hoàn toàn ăn khớp với điều kiện quy ước. \n\nTuy nhiên, logical operators nếu nhìn không quen thì có vẻ hơi khó hình dung mạch suy diễn của chương trình. Tôi chỉ đưa ra đây để các tin hữu tham khảo. Trong dự án thực tế, vẫn nên dùng ternary cho đỡ hại não đồng đội:\n\n```\nconst greet = (hasClient) =\u003e {\n  return hasClient ? sayHello() : doNothing();\n}\n```\n\n#### Logical functions\n\nMột cách tiếp cận khác thể hiện tinh thần Functional Programming quyết liệt hơn, đó là tạo ra các hàm đặc trách nhiệm vụ xử lý logic. Ví dụ trong [Ramda.js](https://ramdajs.com) và [Sanctuary](https://sanctuary.js.org) đều có `ifElse` ,  `unless` , `when`, và hàng chục hàm logic khác. \n\nHàm `greet` nếu viết lại với Ramda sẽ trở nên xinh xắn như thế này:\n\n```\nconst R = require('ramda');\n\nconst greet = R.ifElse(R.identity, sayHello, doNothing);\n```\n\nĐó là vẻ đẹp đầy tính nghệ thuật của Function Composition. Bạn cứ ngắm nhìn nó và đừng nói gì cả! Composition cũng có nghĩa là tác phẩm, như thơ của Paul Verlaine hay nhạc của Beethoven.\n\n### No new/this\n\nCó 2 thứ luôn khiến Brendan Eich cảm thấy hài lòng khi [kể về lịch sử JavaScript](https://brendaneich.com/2008/04/popularity/), đó là first-class function và prototype mechanism.\n\nNgày nay, hầu hết developer đều biết rằng thừa kế trong JavaScript là prototype-based inheritance. Nhưng ở thời kỳ web còn hoang sơ, người ta hay dùng `new` và các hàm constructors để lập trình OOP trong JavaScript theo kiểu class-based, giống như bên Java vẫn làm.\n\n#### Classical inheritance\n\nCổ thư ghi lại rất nhiều ví dụ kiểu này:\n\n```\nfunction Dog(name) {\n  this.name = name;\n  this.say = function() {\n    console.log('woof-woof, my name is ' + this.name);\n  }\n}\n\nvar rocky = new Dog('Rocky');\nrocky.say();\n\nvar molly = new Dog('Molly');\nmolly.say();\n```\n\nHàm `Dog` gọi là Function Constructor, các tiền bối chân giới Đại Việt thủa trước chuyển ngữ thành \"hàm dựng\". Còn chúng ta thời nay có lẽ cứ nên giữ nguyên văn.\n\n#### Prototypal inheritance\n\nSang đầu kỷ thứ 3, ở tông môn Yahoo! có một vị trưởng lão tu vi rất cao thâm tên là [Douglas Crockford](https://en.wikipedia.org/wiki/Douglas_Crockford) tung ra bộ kỳ thư \"JavaScript: The Good Parts\", trong đó có đoạn nhấn mạnh bản chất prototype trong JavaScript, sự khác biệt giữa classical inheritance và prototypal inheritance. Ông cho rằng từ khóa `new` mang theo nhiều điểm bất cập, nên khuyến khích dùng `Object.create` để sao chép nguyên mẫu sang đối tượng kế thừa. \n\nTư tưởng của Douglas Crockford quả thực mới mẻ. Vào lúc đó, nhiều JavaScript engine còn chưa kịp hỗ trợ `Object.create`. Cuốn này vừa ra mắt đã gây náo loạn cả tin giới, trở thành sách gối đầu giường của rất nhiều tu sĩ.\n\n`Object.create` cho phép sao chép các properties hoặc protoype của đối tượng. Hàm `Dog` có thể được viết lại theo hướng prototypal inheritance như thế này:\n\n```\nfunction Dog() {}\n\nDog.prototype.say = function() {\n  console.log('woof-woof, my name is ' + this.name);\n}\n\nvar rocky = Object.create(Dog.prototype);\nrocky.name = 'Rocky';\n\nvar molly = Object.create(Dog.prototype);\nmolly.name = 'Molly';\n\nrocky.say();\nmolly.say();\n```\n\nKhông cần `new` nữa!\n\nCác cường giả sau đó nhanh chóng phát triển thêm nhiều cách tiếp cận prototypal inheritance khác, nổi bật nhất phải kể đến Concatenative inheritance, Prototype delegation và Functional inheritance.\n\nES6 Class ngày nay chỉ vay mượn syntax của classical OOP để làm interface, còn bên trong nó chính là cơ chế prototypal inheritance.\n\n#### Object Composition\n\nNhưng dù sao prototypal inheritance vẫn thuộc về OOP.\n\nNgười tu luyện Functional Programming không cần `new`.\n\nGần 10 năm sau bom tấn \"The Good Parts\", Douglas Crockford lại một lần nữa khiến tin giới chấn động bằng \"JavaScript: The Better Parts\". Thời điểm này, ông đã không còn dùng `Object.create()` nữa, cũng từ bỏ luôn  `this`, `for loops`, `for in`, `while`... Tu vi của ông đã tiến thêm một bước lớn. Trong clip, ông nói về những tính năng mới của ES6 lúc ấy vẫn còn chưa chính thức xuất xưởng. Mấy lão quái kiệt này luôn đi trước thiên hạ vài năm.\n\nhttps://www.youtube.com/watch?v=bo36MrBfTk4\n\nĐó cũng là khi trào lưu Functional Programming đang dần nóng trở lại, người ta bắt đầu nhắc đến khái niệm [Object Composition](https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381).\n\nĐi cặp với `new` là `this`. Từ khóa `this` chẳng qua chỉ là kỹ xảo nhằm tạo ra một ngữ cảnh khu biệt (context) để thực thi các hàm. Trong JavaScript, mỗi hàm như 1 kết giới độc lập. Function khi được gắn lên object thì gọi là method. Ngữ cảnh method đó chạy thường chính là đối tượng sở hữu nó. Sau này mới sinh ra các thủ thuật `bind`, `apply`, `call` để đánh tráo context.\n\nVới những người mới học JavaScript, `this` đôi khi trở thành nỗi khiếp sợ. Rất khó debug các vấn đề phát sinh trong hàm nếu không biết chính xác ngữ cảnh chạy nó. Mà ngữ cảnh lại thường không ổn định. Đúng hơn, phải nói rằng chúng luôn luôn mutable.\n\nNgười tu luyện Functional Programming không cần `this`.\n\nĐoạn code với classical OOP trên kia có thể viết lại thành:\n\n```\nconst sayName = (state) =\u003e {\n  return Object.assign(\n    state,\n    {\n      say: () =\u003e {\n        console.log(`woof-woof, my name is ${state.name}`);\n      },\n    }\n  );\n};\n\nconst createDog = (name) =\u003e {\n  let state = {\n    name,\n  };\n  return Object.assign(state, sayName(state));\n};\n\nconst rocky = createDog('Rocky');\nrocky.say();\nconst molly = createDog('Molly');\nmolly.say();\n```\n\nNhìn đâu cũng thấy functions.\n\nKhông còn `for/while`, `if/else`, `new/this`.\n\nLiệu bạn đã sẵn sàng rời khỏi những phàm vật ấy? \n\nHay nói như các nhà sư, liệu bạn có thể buông bỏ?\n\n![Tớ cóc thèm](https://i.imgur.com/LK0k8LW.jpg)\n\nKhi lối tư duy truyền thống đã ăn sâu vào tâm trí, hễ gặp vấn đề phân cấp đối tượng thì chúng ta sẽ nghĩ ngay đến OOP, class, prototype, inheritance... thậm chí coi chúng như giải pháp tất yếu, duy nhất. Hễ xử lý tập hợp là phải looping, hễ thấy có điều kiện thì chỉ biết dựa vào `if`... Đây là trở ngại rất lớn cho kẻ mới nhập đạo.\n\nPhải tìm cách rũ bỏ những thứ không cần thiết, thì mới đi xa được.\n\nRời khỏi chúng, chỉ giữ lại một ý niệm duy nhất: FUNCTION!\n\nNhất niệm \"phân sần\"!\n\n![Âu Dương Na Na](https://i.imgur.com/0clmtSN.jpg)\n\n\nBan đầu tất nhiên là sẽ khó khăn, lúng túng. Giống như hàng ngày bạn vẫn đi trên con đường quen thuộc từ nhà đến công sở rồi lại trở về nhà. Cho đến một hôm con đường đó bị cảnh sát chặn lại, bạn đành phải rẽ sang lối khác. \n\nTrên con đường xa lạ ấy, bạn không còn trông thấy những điểm mốc hàng ngày vẫn thấy: 1 shop lưu niệm, 1 cây xăng, 1 tiệm cầm đồ, sau ngã tư là đến ven sông, cây cầu sơn màu đỏ, một tiệm tạp hóa thường có cô em rất xinh ngồi trước cửa... Bạn không còn bắt gặp những dấu hiệu đã quen mắt. Bạn chẳng biết mình đã đi đến đâu, còn cách nhà bao nhiêu km nữa. \n\nNhưng con đường nào đi lại vài lần thì cũng thành quen. Chẳng có gì đáng ngại. Vấn đề là, ngay khi bạn nhận thấy Functional Programming là thứ gì đó rất thú vị, đáng để học hỏi, vận dụng nó, bạn nên thực hiện ngay lập tức, đừng chờ đợi dịp nào thuận tiện, đừng chờ tìm được minh sư dẫn dắt. Nếu vậy, bạn sẽ khó mà rời khỏi lối mòn xưa cũ.\n\nKrishnamurti từng diễn giải một điều gần tương tự, đại ý thế này:\n\n\u003e Nếu bạn đi về hướng Bắc suốt những ngày tháng của cuộc đời bạn, giống như con người đã đi theo một hướng đặc biệt, rồi có người nào đó xuất hiện và nói, “Hướng đó không đúng”. Sau đó ông ta bảo bạn, “Đi về hướng Nam, hướng Đông, bất kỳ hướng nào, ngoại trừ hướng đó.” Và khi bạn thực sự chuyển động khỏi hướng đó, có một sự thay đổi ngay tại chính những tế bào não bởi vì bạn đã phá vỡ cái khuôn mẫu. Và cái khuôn mẫu đó phải được phá vỡ ngay lúc này, không phải bốn mươi năm hay một trăm năm sau.\n\n\n`\n - [Xem phần 1: Con đường sáng](https://kipalog.com/posts/Functional-Programming---Phan-1---Con-duong-sang)\n - [Xem phần 2: Nhập đạo](https://kipalog.com/posts/Functional-Programming---Phan-2---Nhap-dao) \n"
                }, {
                "id": "ssSCkkMXsKiF7M8ba0Kn2g",
                "title": "Lightning Network là cái quái gì vậy?",
                "content": "### Blockchain chậm và đắt đỏ\r\n**Bitcoin** xử lý tối đa 7 giao dịch mỗi giây, không phải cho từng người tham gia, mà là toàn mạng lưới.  \r\n**Ethereum** xử lý 15 giao dịch chuyển tiền, 3-5 hợp đồng thông minh mỗi giây.  \r\n\r\nĐây là một con số quá nhỏ so với nhu cầu giao dịch toàn cầu (so sánh với con số giao dịch bằng thẻ Visa trung bình 2000 lượt mỗi giây).  \r\n\r\nNếu phải mất hàng giờ (cùng với một khoản phí giao dịch đắt đỏ) để một giao dịch chuyển tiền đơn giản được thực hiện, ai còn muốn sử dụng Bitcoin nữa.  \r\n\r\n**Lighting Network** là một trong các ý tưởng về giải pháp cho vấn đề này.  \r\nTrước khi đi vào tìm hiểu giải pháp này, chúng ta cần hiểu được vấn đề gì đang diễn ra.  \r\n\r\n### Tại sao Blockchain lại chậm?\r\n\u003e \"I am a slow walker, but I never walk back.\" - Abraham Lincoln\r\n\r\nTưởng tượng **Blockchain** như 1 tập hồ sơ (**chain**), bao gồm nhiều tờ giấy (**block**), mỗi tờ giấy ghi chép các giao dịch.  \r\nNgay sau khi một tờ giấy được ghi đầy các giao dịch, nó cần thiết được đưa vào tập hồ sơ trước khi bắt đầu ghi chép giao dịch mới vào tờ giấy tiếp theo.  \r\nTrước khi tờ giấy (block) được cho vào tập hồ sơ (chain), có một vài thao tác cần phải làm để đảm bảo tất cả mọi người tham gia đều đồng ý với nội dung trong tờ giấy đó.  \r\nCác thao tác này thường mất khoảng **10 phút** (với Bitcoin) cho mỗi block.  \r\n(Tìm hiểu thêm về các thức hoạt động của Blockchain ở [đây](https://1upnote.me/post/2018/01/block-chain-la-gi) nhé)\r\n\r\nGiả sử bạn gửi 1 BTC cho bạn mình là Joe. Giao dịch sẽ trông như sau:  \r\n![alt](https://1upnote.me/images/2018/02/1*y24i5MVq6YNUPwrRqqRwuw.png)\r\n\r\nGiao dịch bao gồm thông tin về người gửi, người nhận, số lượng gửi, và phí giao dịch.  \r\n\r\n### Phí giao dịch là cái quái gì vậy?\r\n\u003e \"A consultant is someone who saves his client almost enough to pay his fee.\" - Arnold H. Glasow\r\n\r\nBạn sẽ phải trả phí cho việc giao dịch.  \r\nPhí này để thưởng cho các thợ mỏ nhằm giúp cho giao dịch của bạn được thêm vào block càng sớm càng tốt.  \r\nKhông có giá chung, nhưng nếu bạn càng trả nhiều thì giao dịch của bạn sẽ càng được ưu tiên cao và càng nhanh được thực hiện.  \r\n\r\nTrong cùng một thời điểm, sẽ có rất nhiều các giao dịch xếp hàng để được thực hiện.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*6xcxo4rHHzUQhutAy_6MKw.png)\r\n\r\n**Thợ mỏ** (hiểu nôm na là các máy tính kết nối vào mạng Blockchain) sẽ quyết định xem giao dịch nào được thêm vào block hiện tại. Tiêu chí để quyết định sẽ làm giao dịch nào có phần thuưởng nhiều nhất, tương ứng với việc phí giao dịch được trả cao nhất.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*1XZuQ_jUdMXVyuwKXSlrBg.png)\r\n\r\nNếu số lượng giao dịch với phí giao dịch cao hơn giao dịch của bạn lấp đầy block, giao dịch của bạn sẽ xếp hàng đợi.  \r\nTuỳ theo tình trạng lúc đó mà bạn chỉ phải chờ vài phút, hoặc vài giờ, vài ngày.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*cUMcKGZx7p-OQKUlMUcGJA.png)\r\n\r\nĐó là lý do tại sao Blockchain lại trở nên chậm và đắt sau khi càng nhiều người bắt đầu sử dụng nó. Điều này trở thành rào cản cho việc Blockchain được sử dụng rộng rãi vào các giao dịch thường nhật.  \r\n\r\n**Và Lightning Network được cho là giải pháp khả thi cho vấn đề này.**\r\n\r\n### Lighting Network (LN) là gì?\r\n\u003e “Thunder is good, thunder is impressive; but it is lightning that does the work.” — Mark Twain\r\n\r\nÝ tưởng của LN là không phải tất cả các giao dịch cần thiết phải ghi lại trên Blockchain.  \r\n\r\nTưởng tượng rằng tôi và bạn giao dịch qua lại với nhau nhiều lần. Vậy chúng ta có thể bỏ qua việc ghi chép các giao dịch ở giữa mà chỉ ghi chép lại kết quả lên Blockchain.  \r\nNói đơn giản LN sẽ mở một kênh giao dịch giữa hai người và lưu lại việc kênh được mở lên Blockchain. Kênh này có thể giữ trạng thái mở trong vài giờ, vài ngày, vài tuần hay thậm chí vài thế kỷ.  \r\nHai người sẽ giao dịch thông qua kênh này. Và chỉ khi nào kênh được đóng lại, kết quả cuối chùng sẽ được ghi lại vào Blockchain.  \r\n\r\nBằng cách này, chúng ta có thể tạo một mạng lưới các kênh giao dịch, mà không cần kết nối liên tục đến Blockchain.  \r\n\r\nTưởng tượng rằng ta có 3 nhân vật: Xan, Yelena và Zeke.  \r\nNếu giữa Xan và Yelena mở một kênh giao dịch, giữa Yelena và Zeke cũng mở một kênh giao dịch, Xan có thể gửi tiền cho Zeke thông qua Yelena.  \r\nĐó là ý tưởng của **Lightning Network**. Bằng việc không thường xuyên chạm đến Blockchain, giao dịch sẽ được diễn ra với tốc độ ánh sáng (lighting speed).\r\n\r\n### Kênh giao dịch hoạt động như thế nào ?\r\n\u003e“Individually, we are one drop. Together, we are an ocean.” — Ryunosuke Satoro\r\n\r\nKênh giao dịch giống như một chiếc hộp an toàn đựng tiền của 2 người. Họ cùng cho vào đó một khoản tiền giống nhau, và cùng đặt khoá lên đó.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*d7Sg7eEAADFRnay2qRg_NQ.png)\r\n\r\nHành động 2 người cùng bỏ một khoản tiền vào chiếc hộp được ghi lại trên Blockchain, dưới hình thức **Mở kênh giao dịch**.  \r\nÝ tưởng của việc khoá khoản tiền vào chiếc hộp là để không ai có thể tiêu khoản tiền nếu không có sự đồng ý của người kia. Khoản tiền  mỗi người cho vào trong chiếc hộp sẽ chỉ được dùng để giao dịch giữa 2 người với nhau.  \r\n\r\nQuay lại ví dụ, Xan va Yelena mỗi người bỏ 10 BTC vào chiếc hộp chung. Giờ nếu Xan muốn chuyển 2 BTC cho Yelena, anh ta chỉ việc hứa sẽ chuyển quyền sở hữu 2 BTC của anh ta trong chiếc hộp cho Yelena.  \r\n\r\n\u003e Đây chưa phải là quyền sở hữu thật mà chỉ là **hứa hẹn**.  \r\n\u003e Quyền sở hữu thật sẽ chỉ được chuyển khi giao dịch được **ghi lại trên Blockchain**. \r\n\r\nSau giao dịch này, nếu chiếc hộp được mở, quyền sở hữu sẽ được chuyển đổi, Xan sẽ được lấy 8 BTC, Yelena sẽ được lấy 12 BTC từ nó.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*-aRVAsOvGsL5gcdV0I2sKA.png)\r\n\r\nNếu họ không mở chiếc hộp ngay họ có thể tiếp tục giao dịch. Đây là điểm mấu chốt.  \r\nVào ngày hôm sau, Yelena muốn gửi 1 cho Xan, cô ta làm điều tương tự, hứa hẹn chuyển quyền sở hữu 1 BTC của cô ta trong chiếc hộp cho Xan.  \r\nSau 2 giao dịch, nếu chiếc hộp được mở, Xan sẽ được lấy 9 BTC, Yelena được lấy 11 BTC.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*zmg15wB-gP9NvL5muudfNQ.png)\r\n\r\nTóm lại kênh giao dịch đơn giản là sự kết hợp của việc cùng góp chung một khoản tiền và chuyển giao qua lại hứa hẹn quyền sở hữu số tiền góp chung đó.  \r\nXan hoặc Yelena đều có thể đóng kênh giao dịch. Đóng kênh giao dịch đơn giản là mở chiếc hộp ra và lấy số tiền bên trong nó.  \r\nMở chiếc hộp sẽ lưu lại thông tin quyền sở hữu lên Blockchain.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*sMdtU5-5tE7pwrKVN2MEKQ.png)\r\n\r\nĐó là cách kênh giao dịch hoạt động.  \r\nNhưng nó chỉ thực sự phát huy sức mạnh khi mà có nhiều kênh giao dịch hoạt động cùng nhau tạo thành mạng lưới - **Lightning Network**.\r\n\r\n### Lighting Network hoạt động như thế nào?\r\n\u003e “Great things are done by a series of small things brought together.” — Vincent Van Gogh\r\n\r\nLighting Network hoạt động thông qua việc thay đổi từ chuyển giao quyền sở hữu sang **hứa hẹn** chuyển giao quyển sở hữu.\r\nĐây là một bước đi quan trọng. \r\n\r\n\r\n3 người: Xan, Yelena, Zeke có 2 kênh giao dịch được mở giữa Xan và Yelena, Yelena và Zeke.  \r\nXan muốn chuyển 2 BTC cho Zeke, anh ta yêu cầu Yelena chuyển hứa hẹn quyền sở hữu 2 BTC cho Zeke thông qua kênh của Yelena và Zeke, sau đó anh ta chuyển hứa hẹn quyền sở hữu 2 BTC của anh ta cho Yelena thông qua kênh của Xan và Yelena.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*N3z_ylP8YpGy1DFAalhWlA.png)\r\n\r\nBằng cách này, hàng ngàn giao dịch có thể được thực hiện mà không cần chạm đến Blockchain, đồng nghĩa với việc đẩy nhanh tốc độ giao dịch và giảm phí thực hiện giao dịch.  \r\n\r\n--------------------------------------\r\nDịch nôm na từ bài viết của pro Mohit Mamoria ở [đây](https://hackernoon.com/lightning-network-explained-d4615c12ad09).\r\nBài cùng nội dung trên blog của mình ở [đây](https://1upnote.me/post/2018/02/lighting-network-la-gi/)."
                }, {
                "id": "tTu_m5wf1Gy2jWuRyk0wQw",
                "title": "Mô hình MVC ? (Cụ già của Php,...) , và thư viện Css,JavaScript",
                "content": "![alt](https://i.stack.imgur.com/SFdgC.png)\r\n\r\n\r\n## Tổng quan về  mô hình MVC \r\n\r\n\u003e Thường thường, mình thấy mọi người thường nói về khái niệm rồi mới sang chức năng \r\n bla bla..... , nhưng theo mình nó không ổn khi như vậy nó làm khó hiểu cho người đọc nên mình sẽ nói về chức năng trước nhé !!\r\n \r\n \r\n##chức năng (tầm quan trọng)\r\n \r\n - MVC có các trình tự xử lý dữ liệu rất rõ ràng \r\n - ngoài ra, MVC còn giúp người dùng dễ hình dung \r\n - nó áp dụng vào thực tiễn khá nhiều,khá dễ bảo trì\r\n - đây là một mô hình rất lâu dài đến bây giờ nó vẫn là môt mô hình khá hay \r\n\r\n\r\n## Nhược điểm \r\n\r\n\u003echúng ta không thể không nghi ngờ về khả năng của nó được chúng ta cần biết nó có nhược điểm không sau đây mình xin nói : \r\n\r\n- MVC áp dụng trong một dự án khá nhỏ nó không khả dụng với một số dự án lớn\r\n- MVC đôi lúc vẫn gây khó hiểu =)) và gây rắc rối\r\n\r\n## Khái niệm\r\n- MVC tức là sao ??\r\n- M tức là model ,model xử lý các data bằng các funtion,bla bla... \r\n- V tức là View nơi đây là nơi nhận hàng từ C  nó sẽ view cho user\r\n- C tức là control là nơi tương tác với người dùng và nơi tương tác với M \r\n\r\n## Cơ chế hoạt động\r\n\r\n\r\n- Cái này thì nó khá dễ vì liên quan tới thực tế khá nhiều chúng ta cùng xem nhé \r\n\r\n\r\n\u003e cái này hơi ngoài lề :))) c\r\n\r\n\r\n  \r\n Ai cũng đã từng ăn cơm mẹ nấu chưa nhỉ ??? ( đếch cần hỏi ) để nấu nó thì cũng là một quá trình đấy \r\n \u003eđầu tiên câu bạn thốt lên là gì ? mình thì đóng vai trò làm user nhé !!! khi con đói thì nó nói câu :\r\n \r\n \r\n -  mẹ ơi !! con đói rồi mẹ ạ !! \r\n\r\n\r\n \u003e sau đố mẹ sẽ đóng vai trò làm Control sẽ nhận request từ user là con  và gửi lên M(model) khi đó model sẽ xử lý là lấy gạo đổ vào nồi rồi cho nước vào nấu lên , và trong lúc nấu thì mẹ sẽ nói : \r\n \r\n - đợi xúy nhé con !\r\n\r\n\r\n\r\n \u003ekhi nấu xong sẽ có thành quả và V(View) sẽ up data lên user và request cảu user đc xử lý , cũng như mẹ đưa cơm cho xon ăn thôi !!\r\n \r\n\r\n\r\n\r\n\r\n## Hết ăn cơm rồi sang ăn thư viện thôi =(((\r\n\r\n\u003ephần này mình sẽ viết bằng tiếng anh để luyện trình độ tiếng anh nếu có sai sót thì mọi người góp ý nha !!!\r\n\r\n### What is library ??????\r\n- library is a extension that they can help you code master and better and you don't need to code css,or some animation ,it variable in library =))\r\n\r\n### What is Famous Library ??\r\n- AOS is the library that this can help you help a event of Scroll by JavaScript or Jquery ,this can help you Css if you don't want css you can add this\r\n- Trowel is the library that this can have all yours Css it can make yours Css code easy to read \r\n\r\n![alt](https://viblo.asia/uploads/4d82ca3d-e2f2-4938-a860-d7a5c221ef4d.jpg)\r\n\r\n\r\n\u003ethis Img I copy in viblo,this have many library in viblo \r\n\r\n## have a good day !! =)) \r\n "
                }, {
                "id": "Ae18_lCEx_fg9pL1PSLN0w",
                "title": "Two-Factor Authentication và ứng dụng",
                "content": "Trong thế giới của việc thông tin cá nhân đang ngày càng bị xâm phạm và tấn công, đến thời điểm này đã có gần [10 tỷ](https://breachlevelindex.com/) accounts bị leaked thì chuyện phải implement một phương pháp đăng nhập có tính bảo mật cao hơn là một chuyện bất cứ cá nhân/tổ chức nào cũng aware được.\r\n\r\nTwo-factor Authentication là một trong số đó. Trong bài này mình sẽ chia sẻ những kiến thức đã tổng hợp được trong quá trình làm việc với 2FA.\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7gklibkwls_image.png)\r\n\r\n## Two-Factor Authentication (2FA) là gì?\r\n\r\nTwo-Factor Authentication (2FA) hay còn gọi là Bảo mật 2 lớp, là một phương thức để chứng thực user bằng việc combine 2 factors khác nhau từ bộ source:\r\n- Một cái gì đó bạn biết.\r\n- Một cái gì đó bạn có.\r\n- Một cái gì đó mà nó mặc nhiên như vậy.\r\n\r\nMột ví dụ khá cơ bản của 2FA đó là khi bạn rút tiền ở ATM, bạn cần 2 thứ, một là cái thẻ (bạn có) và mã PIN (bạn biết) mới có khả năng thực hiện rút tiền.\r\n\r\nNhư vậy nó áp dụng trong online authentication như thế nào?\r\n\r\nVới bảo mật thông thường, bạn chỉ cần nhập username và password để đăng nhập tài khoản của mình, thứ bảo vệ duy nhất của bạn là mật khẩu. Đây là cái mà \"bạn biết\". 2FA sẽ thêm một extra layer để bạn cần provide cái mà \"bạn có\" nữa.\r\n\r\n## Các loại 2FA\r\n- Hardware Token\r\n- SMS/Voice based\r\n- Software Token\r\n- Push notification\r\n- Các loại khác\r\n\r\nNhư bạn thấy, có rất nhiều cách để mô phỏng cái mà \"bạn có\". \r\n\r\nChẳng hạn, SMS là một sự lựa chọn không tồi, server gửi SMS về cho user để đăng nhập. Nhưng SMS lại không quá an toàn (có thể bị intercepted), và bị vấn đề về network, việc delay có thể làm ảnh hưởng tới authentication process.\r\n\r\nVì nhiều lí do khác nhau nên team quyết định chọn dùng Software Token cho 2FA. Và từ bây giờ trong bài viết mình 2FA cũng được ám chỉ tới phương pháp sử dụng cryptographically key của Software Token.\r\n\r\n## 2FA hoạt động như thế nào?\r\nMình lấy ví dụ gitlab.\r\nĐây là lúc đăng nhập, mình sẽ provide user và password.\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/qg21xb61c9_Screen%20Shot%202018-05-25%20at%203.15.24%20PM.png)\r\n\r\nSau khi đăng nhập xong, vì mình có enable 2FA nên nó sẽ redirect mình tới trang điền code (soft token).\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/wi0hndhayn_Screen%20Shot%202018-05-25%20at%203.15.33%20PM.png)\r\n\r\nCode này sẽ được lấy từ Authentication application, có thể là Authy, Google authenticator ...\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mui8qfsb9c_Screen%20Shot%202018-05-25%20at%204.43.50%20PM.png)\r\n\r\nVí dụ như mình dùng Authy để lấy được code. Mỗi code sẽ được thay đổi sau 30s.\r\n\r\nVới code này mình sẽ đăng nhập thành công.\r\n\r\n\r\n## Cơ chế hoạt động internally của 2FA\r\nKhi bạn enable 2FA cho tài khoản của mình, bạn sẽ nhận được một secret key based 32. Tùy vào mức độ security, độ dài của secret key có thể là 80, 128 hoặc 160 bit.\r\n\r\nCác authenticator application sẽ scan secret này dưới dạng QR code (hoặc manually) và dùng nó để generate ra một HMAC-SHA1. Chuỗi HMAC này có thể là một trong 2 dạng:\r\n- [TOTP](https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm) \r\n- [HOTP](https://en.wikipedia.org/wiki/HMAC-based_One-time_Password_algorithm)\r\n\r\nSau đó HMAC này sẽ được extracted và lấy ra 1 số int 4 byte, đó chính là code.\r\n\r\nMột mã code sẽ valid trong 30 giây. Tuy nhiên không phải ai cũng có clock synced giống nhau, vì network latency các kiểu nên thường mọi người hay cho phép ở phạm vi cộng trừ 1 code, tức là 1 code sẽ valid trong 1 phút 30 giây. Điều này có thể giảm tính an toàn, nhưng lại tăng sự trải nghiệm đáng kể.\r\n\r\n### Backup codes\r\nBackup codes hay recovery codes sẽ được sử dụng trong trường hợp bạn không thể sử dụng điện thoại, bạn có thể dùng chúng để đăng nhập. Có 2 loại backup codes:\r\n- Multiple backup codes: Ví dụ github sẽ cho bạn 10 codes, và mỗi code sẽ được sử dụng 1 lần.\r\n- Single backup code: Bạn dùng cái code này đồng nghĩa với việc bạn có thể đăng nhập, nhưng phải setup lại 2FA (nó assume bạn bị mất điện thoại).\r\n\r\n\r\n## Làm thế nào để apply 2FA vào dự án của mình?\r\nKhá đơn giản, hầu hết ngôn ngữ đều open source implementation của mình. Mình code Go, library mà mình chọn là `github.com/dgryski/dgoogauth` được viết bởi Damian Gryski, một gopher rất nổi tiếng.\r\n\r\nFlow chương trình \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hnxlni0dqr_Screen%20Shot%202018-05-25%20at%206.07.49%20PM.png)\r\n\r\nKhi một user muốn enable 2FA, App sẽ gọi `RequestGenerate2FA` API. \r\n\r\nTrong API này sẽ generate ra một temporary secret và lưu vào redis, trong thời gian expire 5 phút.\r\n\r\nGenerateSecret thì khá đơn giản thôi.\r\n```go\r\n// GenerateSecret generates a 10 byte secret string.\r\nfunc GenerateSecret() (string, error) {\r\n\trandom := make([]byte, 10)\r\n\t_, err := rand.Read(random)\r\n\tif err != nil {\r\n\t\treturn \"\", err\r\n\t}\r\n\treturn base32.StdEncoding.EncodeToString(random), nil\r\n}\r\n```\r\n\r\nSau khi app nhận được secret, sẽ turn thành QR code và đưa cho user. QR code này sẽ được user dùng Authenticator application để quét.\r\n\r\nKhi đã có code, user input vào và app sẽ tiếp tục make request lên API `Generate2FA`. Nếu thành công thì user đã được enable 2FA.\r\n\r\nTrong hàm `Generate2FA` chúng ta cần verify được code gửi lên và secret lấy từ redis có valid hay không. Sử dụng library trên như sau:\r\n\r\n```go\r\notpc := \u0026dgoogauth.OTPConfig{\r\n      Secret:      info.Secret,\r\n      WindowSize:  3,\r\n      HotpCounter: 0,\r\n}\r\n\r\nvalid, err := otpc.Authenticate(req.Code)\r\nif err != nil || !valid {\r\n\treturn errors.New(\"Invalid authenticate code\")\r\n}\r\n\r\n// success validation\r\n\r\n```\r\n\r\n(Các bạn có thể đọc thêm source code để biết function Authenticate hoạt động như thế nào, chỉ có 1 file go thôi).\r\n\r\nSau khi validate xong thì mình trả về Recovery codes luôn (cho tiện ở phía application). \r\n\r\nCòn đây thì flow khi login, nếu cần thêm 2FA thì sẽ require code từ user, sau đó upgrade cái access token đó (simply add thêm 1 fields `2fa: true`) để nhận dạng là đã 2FA authenticated rồi.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gvri4aj6di_Screen%20Shot%202018-05-25%20at%206.11.36%20PM.png)\r\n\r\n\r\n## Kết luận\r\n\r\n2FA là một kĩ thuật dùng để enhance security layer của một application. Hay nói cách khác, bạn khóa 1 cửa bằng 2 cái khóa luôn an toàn hơn 1 cái. Trong xã hội đầy loạn lạc này thì ứng dụng nào quan trọng, chứa nhiều sensitive data và liên quan tới tiền bạc thì cứ auto bật 2FA thôi.\r\n\r\n## References\r\n\r\n- https://engineering.gosquared.com/building-two-factor-authentication\r\n- https://authy.com/what-is-2fa/\r\n\r\nBài viết được trích ra từ blog [Runikitkat](http://runikitkat.com/post/2fa/)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
                }, {
                "id": "jV4qra2tZtGQNc6t8slITQ",
                "title": "12 cách tối ưu hoá website - thời đại của mobile-first",
                "content": "Lập trình viên sau khi phát triển xong một website, website chạy ổn định, không bug thì coi như đã hoàn thành. \r\n\r\nCâu chuyện của năm 2018 có đơn giản như vậy?\r\n\r\n## Tại sao phải tối ưu hoá website?\r\n_Theo [số liệu cung cấp bởi google](https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/)_\r\n\r\n![fact-1](https://qmau.me/uploads/ltfWITVaamwum4CC.jpg)\r\n\r\n- User facts:\r\n  - **47%** người dùng muốn trang web load **dưới 2 giây** và **40%** sẽ bỏ cuộc nếu trang web mất **trên 3 giây** để load.\r\n  - **79%** người dùng sẽ không ghé thăm lại một website có performance tồi.\r\n  - **52%** người dùng cho rằng website load nhanh ảnh hưởng trực tiếp đến độ trung thành của họ.\r\n  - **44%** người dùng than phiền về tốc độ web với bạn của họ.\r\n  - **1 giây** tăng lên trong load-time giảm **16%** độ hài lòng của người dùng.\r\n\r\n![fact-2](https://qmau.me/uploads/pxvo1NJb9KnMlUCu.png)\r\n- Website facts:\r\n  - **79%** có kích thước trên 1MB, **53%** trên 2MB và **23%** trên 4MB.\r\n  - \u001dMobile load-time đã **giảm 7 giây** nhưng vẫn tốn khoảng **15 giây**, **53%** websites tốn hơn **3 giây** để hiển thị.\r\n  - Mobile traffic chiếm hơn một nửa web traffic trên toàn thế giới, nhưng tỷ lệ chuyển đổi thành lợi nhuận lại thấp hơn trên các thiết bị máy tính.\r\n\r\n  → **speed equals revenue**\r\n  - **70%** landing page mất **hơn 5 giây** để hiển thị.\r\n  - Google sử dụng một deep neural network với độ chính xác 90% để cho ra kết quả sau:\r\n    - **giảm load-time được 10 giây**, tỷ lệ người dùng tiếp tục sử dụng website **tăng 123%**\r\n    - ngược lại, số lượng elements trên trang web **tăng từ 400 lên 6000**, tỷ lệ chuyển đổi thành lợi nhuận **giảm 95%**\r\n\r\n  → **faster is better and less is more**\r\n  - Thử nghiệm thực tế:\r\n    1. Walmart:\r\n      - Mỗi **1 giây** load-time giảm, số lượng đặt hàng **tăng 2%**\r\n      - Mỗi **100ms** load-time giảm, lợi nhuận tăng **1%**\r\n      - Tỉ lệ đặt hàng có thể **giảm 25%** với mỗi **1 giây** tăng trong load-time.\r\n    2. Amazon A/B Test:\r\n      - Chỉ **100ms load-time** có thể khiến lợi nhuận **giảm đáng kể**.\r\n    3. Google\r\n      - Traffic **giảm 20%** nếu load-time tăng thêm **0.5 giây**\r\n      - Google đã rank các website theo [mobile-first index](https://searchengineland.com/finally-going-mobile-friendly-collision-course-googles-mobile-first-index-case-study-265227), tốc độ load trang trên di động sẽ ảnh hưởng trực tiếp đến kết quả index trên Google search engine.\r\n\r\n\r\n### SPEED DOES MATTER\r\n![fact-3](https://qmau.me/uploads/xM14N65sTTJpIBaq.jpg)\r\n\r\nLoad-time tăng 1 giây:\r\n- **Giảm 11%** lượng pageviews\r\n- **Giảm 16%** sự hài lòng của khách hàng\r\n- **Giảm 7%** lợi nhuận\r\n\r\nỞ Việt Nam, website của [Thế giới di động](https://www.thegioididong.com/) được giao KPI hiển thị dưới 300ms, còn [tiki và đặc biệt là sendo có vẻ không quan tâm đến](https://toidicodedao.com/2018/04/03/tiki-sendo-tai-trang-cham-sen-bo/) việc này lắm. Các bạn có thể dễ dàng thấy trải nghiệm người dùng ở đâu tốt hơn, ở đâu mọi người mua đồ nhiều hơn.\r\n\r\nDù sao thì trong tương lai, các website chắc chắn sẽ phải để ý đến việc optimize webservice. Đây vừa là cơ hội và cũng là thách thức với các lập trình viên. Liệu tất cả những lý do trên đã khiến các bạn phải ngồi vào bàn và bỏ thời gian ra làm một website chạy nhanh hơn 1-2 giây?\r\n\r\nLong story short:\r\n\u003e Hãy làm trang của bạn chạy thật nhanh trên các thiết bị di động và bắt đầu tư duy theo hướng mobile-first.\r\n\r\nCùng nhìn lại một chút quá trình vào một trang web của người dùng theo một flow đơn giản:\r\n\r\n![flow](https://qmau.me/uploads/jQyWIfh6TnBtl1wi.jpg)\r\n\r\n1. người dùng nhập địa chỉ web → chuyển đến mạng Internet\r\n2. DNS server (Domain Name Service server) chuyển từ URL thành địa chỉ IP →　trỏ đến server có IP yêu cầu\r\n3. server nhận request, xử lý request\r\n4. chuyển lại response cho người dùng → browser hiển thị kết quả.\r\n\r\nTin tốt là chúng ta có thể optimize trang web ở tất cả các bước còn tin xấu là ở mỗi bước, thời gian cải thiện có thể chỉ được tính bằng ms (1/1000 giây ). Có nên thực sự quan tâm?\r\n\r\n- Nếu trang web của bạn là một blog cá nhân, không có giá trị kiếm tiền, có \u003c 50 người truy cập cùng lúc (như blog này) thì việc optimize không mang lại nhiều giá trị.\r\n\r\n- Bạn kiếm tiền từ trang web của bạn và có trung bình vài nghìn hoặc vài trăm nghìn lượt truy cập cùng lúc. Ngoài lý do về lợi nhuận, nếu không optimize web service, server có thể bị quá tải do requests của khách hàng → bottle neck → load-time kéo dài, thậm chí out of service. Thay vì bỏ tiền mua server khủng hơn, hãy bỏ chút thời gian để sắp xếp và thiết kế lại service để đem lại performance ổn định với chi phí rẻ hơn.\r\n\r\n## Làm thế nào?\r\n\r\n- Đầu tiên hãy xem website của bạn đang có vấn đề gì bằng [công cụ của Pagespeed của google](https://developers.google.com/speed/pagespeed/insights/)\r\n\r\n- Tham khảo các rules của google cho việc tăng tốc độ load trang:\r\n  - [Hạn chế việc redirect tại landing page](https://developers.google.com/speed/docs/insights/AvoidRedirects)\r\n  - [Enable compression](https://developers.google.com/speed/docs/insights/EnableCompression)\r\n  - [Cải thiện tốc độ phản hồi của server](https://developers.google.com/speed/docs/insights/Server)\r\n  - [Tận dụng bộ nhớ cache của browser](https://developers.google.com/speed/docs/insights/LeverageBrowserCaching)\r\n  - [Tối giản hoá các tài nguyên](https://developers.google.com/speed/docs/insights/MinifyResources)\r\n  - [Tối ưu hiển thị ảnh](https://developers.google.com/speed/docs/insights/OptimizeImages)\r\n  - [Tối ưu hoá việc load CSS](https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery)\r\n  - [Ưu tiên các nội dung cần được hiển thị trước](https://developers.google.com/speed/docs/insights/PrioritizeVisibleContent)\r\n  - [Xoá bỏ các Javascript gây ra render-blocking](https://developers.google.com/speed/docs/insights/BlockingJS)\r\n\r\nSau tất cả, google là công cụ tìm kiếm lớn nhất thế giới, làm mọi thứ theo chuẩn của họ chắc chắn không phải một lựa chọn tồi.\r\n\r\nĐể đầy đủ hơn, mình sẽ thêm một số phương pháp và chia thành 4 loại tương ứng với từng giai đoạn khi người dùng truy cập website.\r\n\r\n## Loại 1: User → Internet\r\nHoàn toàn nằm ngoài khả năng của chúng ta, tuy nhiên vẫn có thể đảm bảo việc khác hàng có được trải nghiệm đủ tốt với tốc độ mạng cực chậm bằng việc [xây dựng progressive web app và sử dụng service-worker](https://qmau.me/blog/post/progressive-web-apps-qmau-me-cho-ios) cho trang web của bạn.\r\n\r\n## Loại 2: Internet → Server\r\n\r\n### 1. Sử dụng DNS server\r\n\r\n![DNS-server](https://qmau.me/uploads/jAOAsuDFTd9l0zPK.jpg)\r\n\r\nViệc chuyển từ URL sang địa chỉ IP server do DNS server đảm nhận, và nó cũng chỉ là một máy tính, nhanh chậm khác nhau. Các dịch vụ cung cấp host thường cũng sẽ có kèm theo dịch vụ cung cấp DNS, tuy nhiên tốc độ có thể khác nhau → tốc độ load trang cũng bị phụ thuộc.\r\n\r\n**Cách khắc phục**\r\n- Để tiết kiệm được khoảng **20-30ms** load-time, bạn nên cân nhắc chuyển qua dùng DNS server của một số nhà cung cấp khác.\r\n- Một số nhà cung cấp dịch vụ DNS (như cloudflare) cho phép bạn sử dụng DNS service miễn phí, tuy nhiên hãy tìm hiểu xem ở khu vực địa lý mà website của bạn hay được sử dụng [DNS nào có tốc độ nhanh nhất](https://www.dnsperf.com/).\r\n\r\n### 2. Sử dụng CDN\r\n\r\n![CDN-services](https://qmau.me/uploads/luVNJqudPakH-jpc.jpg)\r\n\r\nContent Delivery Network (CDN) là hệ thống các edge servers được đặt tại các vị trí địa lý khác nhau để có thể truyền tải nội dung từ một origin ở khoảng cách xa nhanh chóng hơn nhờ cơ chế cache.\r\n\r\nThay vì đến tận server (origin, ở xa) để lấy các tài nguyên thì người dùng có thể lấy ngay tại CDN (distribution, ở gần), chính vì thế load-time sẽ được giảm đáng kể.\r\n\r\nĐể hiểu rõ hơn những lợi ích của việc sử dụng CDN bạn có thể đọc [bài viết vô cùng có tâm của sempai Đinh Hoàng Long về CDN](https://viblo.asia/p/su-dung-cdn-de-giam-tai-cho-server-ymwGXOxoM4p1).\r\n\r\nTheo [cdnperf.com](https://www.cdnperf.com/), tính đến thời điểm này JSDELIVR đang dẫn đầu trong việc cung cấp dịch vụ CDN trên toàn cầu. Ở châu Á, vị trí quán quân thuộc về CDNetworks. Cloudflare CDN, Azure và CloudFront của AWS cũng lọp top 10.\r\n\r\n_Cloud CDN (của google) mà mình đang dùng ở vị trí nào đó không xuất hiện trong bảng xếp hạng_ \r\n\r\n## Loại 3: Server\r\n\r\n### 3. Hosting\r\n\r\n![](https://qmau.me/uploads/yvVGAtFtpTp2qnbr.png)\r\n\r\nThời đại của cloud computing, các service hầu hết được đưa lên mây. Việc chọn một hosting service phù hợp với nhu cầu của trang web cũng là một yếu tố quan trọng ảnh hưởng đến tốc độ của trang web.\r\n\r\n- Nhu cầu nhỏ →　shared hosting.\r\n- Nhu cầu vừa phải → VPS hosting.\r\n- Nhu cầu lớn → Dedicated server.\r\n\r\nNếu có thể, hãy tham khảo ý kiến từ một lập trình viên, nhân viên quản trị hệ thống hoặc sử dụng dịch vụ của một số nhà cung cấp lớn như [Amazon web service](https://aws.amazon.com/websites/), [Microsoft Azure](https://www.microsoft.com/en-us/CloudandHosting/Azure_Hosting.aspx), [Google cloud](https://cloud.google.com/),...\r\n\r\n_[qmau.me](https://qmau.me) đang được host với 300$ free của Google cloud VPS, CPU trung bình khoảng 1%_ \r\n\r\n\r\n### 4. Cải thiện tốc độ phản hồi của server\r\nGoogle rất khó tính, họ cho rằng phản hồi của server nên **dưới 200ms**. Việc server phản hồi chậm có thể do một trong những lý do sau:\r\n- Sử dụng framework, ngôn ngữ không tối ưu\r\n- Logic quá phức tạp → việc xử lý chậm\r\n- Các components của server tốn nhiều thời gian để liên kết\r\n\r\n  Ví dụ: sử dụng web server và database server riêng → mất thêm độ trễ của network vào thời gian phản hồi của webserver.\r\n- Mạng chậm (lý do khách quan, bỏ tay trả về).\r\n\r\n**Cách khắc phục**\r\n- Low level:\r\n  - Sử dụng các ngôn ngữ, framework có tốc độ xử lý tốt (không dùng fortran để code web).\r\n  - Đơn giản hoá code, sử dụng kiến thức về cấu trúc dữ liệu, giải thuật \r\n  - Với website có thể dùng cache (redis, memcached), cache trong database để tăng tốc độ phản hồi (tối ưu cache memory lại là một câu chuyện khác)\r\n- High level:\r\n  - Xây dựng hệ thống với độ trễ giữa các clusters thấp → việc của quản trị viên hệ thống.\r\n\r\n### 5. Tối giản hoá các tài nguyên\r\nKhi load trang web, các file `html, css, js, script` sẽ được load để hiển thị trên browser. Tuy không quá nặng nhưng việc đơn giản hoá, không sử dụng thừa code trong các tài nguyên được load cũng sẽ cải thiện tốc độ load cho trang web.\r\n\r\n**Cách khắc phục**\r\n- [Minify HTML](https://github.com/kangax/html-minifier)\r\n- [Minify CSS](https://github.com/ben-eb/cssnano)\r\n- [Minify Javascript](https://github.com/mishoo/UglifyJS2)\r\n- Có thể cài [PageSpeed Module](https://developers.google.com/speed/pagespeed/module/) của google cho webserver (apache, nginx) và mọi thứ cứ để module lo.\r\n- Học sử dụng [gulp](https://gulpjs.com/) và viết gulp task cho việc minify tài nguyên (worth it).\r\n\r\n### 6. Tối ưu hiển thị ảnh\r\nẢnh có thể coi là tài nguyên chiếm nhiều load-time nhất của một trang web, việc tối ưu được hiển thị ảnh đóng vai trò quan trọng trong việc cải thiện load-time của một trang web.\r\n\r\nNgày nay người dùng sử dụng rất nhiều các thiết bị khác nhau để có thể truy cập vào trang web của bạn. Với layout bạn có thể giải quyết bằng responsive design, còn với ảnh câu chuyện sẽ rắc rối hơn một chút.\r\n\r\n**Cách khắc phục**\r\n- Sử dụng ảnh phù hợp với kích cỡ màn hình người dùng. Tham khảo [các best practices](https://developers.google.com/web/fundamentals/design-and-ux/responsive/images) cho việc hiển thị ảnh responsive để tiết kiệm tài nguyên.\r\n- Sử dụng các phương thức nén ảnh phù hợp:\r\n  - GIF, PNG là phương thức nén lossless, ảnh sau khi nén sẽ có chất lượng gần như ảnh gốc, tỉ lệ nén thấp.\r\n  - JPEG là phương thức nén lossy, ảnh sau khi nén có chất lượng giảm so với ảnh gốc tuy nhiên tỉ lệ nén có thể **gấp 10 lần** GIF và PNG.\r\n  - Sử dụng các phương thức nén hiện đại hơn như JPEG 2000, JPEG XR hoặc WebP để tăng tốc độ load.\r\n\r\n### 7. Tối ưu hoá việc load CSS\r\nMột trang web sẽ được hiển thị khi load đầy đủ html, css, js. Nếu file css, js có kích thước quá lớn sẽ khiến trang web bị render-blocking, khiến tốc độ load trang tăng đáng kể.\r\n\r\n**Cách khắc phục**\r\n- [Inline các file css hoặc js nhỏ](https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery#example) bằng thẻ `\u003cstyle\u003e` trong phần `\u003chead\u003e`. Các code này sẽ được load cùng html thay vì phải load từng file nhỏ. ps: khai báo ở đầu trang chứ không phải khai báo trong html tag (`\u003cp style=...\u003e`) nhé.\r\n- Nên nhớ rằng việc chia css, javascript thành các file nhỏ sẽ giúp project có cấu trúc code tốt hơn, tuy nhiên với mỗi file, browser sẽ tốn thêm 1 request đến server của bạn, đôi khi thấy đọc code thấy css hay script inline thì đừng vội chửi dev ngu nhé.\r\n\r\n### 8. Tổ chức thứ tự load\r\nTrong Lighthouse audits của Chrome, tốc độ hiển thị first page của trang web là một trong nhưng tiêu chí được đánh giá rất cao trong mục Performance. Để người dùng có trải nghiệm tốt nhất thì việc ưu tiên hiển thị những nội dung cơ bản (above-the-fold - ATF) của trang web là rất quan trọng.\r\n\r\n**Cách khắc phục**\r\n- Hãy tổ chức html thật tốt, quyết định đâu là thành phần quan trọng cần load trước (html load theo thứ tự từ trên xuống dưới)\r\n  - Chia css thành 2 phần, 1 phần inline dành cho các nội dung ưu tiên hiển thị để tăng tốc độ load, 1 phần dành cho các nội dung còn lại\r\n  - Nếu sidebar và nội dung cùng đặt song song, ưu tiên hiển thị nội dung trước khi hiển thị sidebar\r\n- Giảm lượng tài nguyên cần load xuống bằng cách:\r\n  - Minify tài nguyên\r\n  - Sử dụng css thay cho ảnh khi có thể\r\n  - Sử dụng nén\r\n- [Sử dụng lazy load](https://github.com/verlok/lazyload) cho các tài nguyên chưa cần được hiển thị (vd: các ảnh chưa có trong khung hình)\r\n\r\n### 9. Xoá bỏ các Javascript gây ra render-blocking\r\nTrong khi browser tạo ra các DOM tree, nếu gặp một script, nó sẽ dừng lại và thực hiện xong script đó rồi mới tiếp tục tạo ra các DOM. Chính vì thế javascript có thể coi là một nguyên nhân khiến tốc độ tải trang bị chậm đi rất nhiều.\r\n\r\n**Cách khắc phục**\r\n- Inline script giống như đã làm với css, tuy nhiên hãy chắc chắn được các script được inline có tốc độ thực hiện nhanh và không gây ra render-blocking.\r\n- Sử dụng asynchronous (không đồng bộ) cho javascript, khi gặp script, browser sẽ không dừng lại thực hiện mà sẽ tiếp tục parse HTML đồng thời thực hiện script → tránh bị render-blocking.\r\n- Mạnh hơn nữa chúng ta có thể [defer javascript](https://www.w3schools.com/tags/att_script_defer.asp), các script sẽ được thực hiện khi trang được load xong.\r\n- Cơ chế load javascript:\r\n  - Nếu có async: script sẽ được thực hiện song song với parse html.\r\n  - Nếu có defer: script sẽ được thực hiện sau khi parse html.\r\n  - Nếu không có: script sẽ được thực hiện ngay, sau đó mới tiếp tục parse html.\r\n\r\n### 10. Hạn chế redirect tại landing page\r\nViệc redirect người dùng tại landing page sẽ đem lại trải nghiệm xấu và tăng thời gian load time của trang/\r\nVí dụ:\r\n- example.com sử dụng thiết kế responsive không đòi hỏi redirect, nhanh và tối ưu.\r\n- example.com → m.example.com/home - sẽ tốn thời gian cho multi-roundtrip.\r\n- example.com → www.example.com → m.example.com - người dùng mobile sẽ có trải nghiệm rất tệ do load time quá lâu.\r\n\r\n**Các khắc phục**\r\n- Học cách thiết kế một giao diện responsive và hạn chế việc redirect.\r\n- Nếu buộc phải redirect, tham khảo [hướng dẫn của google](https://developers.google.com/search/mobile-sites/mobile-seo/separate-urls#automatic-redirection).\r\n\r\n## Loại 4: Server → User\r\n\r\n### 11. Sử dụng nén dữ liệu\r\nHầu hết các browser hiệnt tại đều hỗ trợ và sử dụng gzip cho việc nén dữ liệu, nhờ lượng dữ liệu truyền tải qua network ít đi → tăng tốc độ tải trang.\r\n\r\n**Cách khắc phục**\r\n- Config server cho phép dữ liệu được ném nhằm giảm, một số config mẫu cho các web server:\r\n  - Apache: Use [mod_deflate](http://httpd.apache.org/docs/current/mod/mod_deflate.html)\r\n  - Nginx: Use [ngx_http_gzip_module](http://nginx.org/en/docs/http/ngx_http_gzip_module.html)\r\n\r\n- Dữ liệu được nén\r\n\r\n|Library|\tSize|\tCompressed size|\tCompression ratio|\r\n| :------------- | :------------- |:------------- |:------------- |:------------- |\r\n|jquery-1.11.0.js |\t276 KB |\t82 KB |\t70%|\r\n|jquery-1.11.0.min.js |\t94 KB\t| 33 KB |\t65%|\r\n|angular-1.2.15.js |\t729 KB\t| 182 KB |\t75%|\r\n|angular-1.2.15.min.js |\t101 KB |\t37 KB |\t63%|\r\n|bootstrap-3.1.1.css |\t118 KB |\t18 KB\t| 85%|\r\n|bootstrap-3.1.1.min.css |\t98 KB |\t17 KB\t| 83%|\r\n|foundation-5.css |\t186 KB | 22 KB\t|88%|\r\n|foundation-5.min.css |\t146 KB |\t18 KB |\t88%|\r\n\r\n### 12. Tận dụng bộ nhớ cache của browser\r\nMỗi lần người dùng truy cập một trang nào đó, toàn bộ tài nguyên của trang sẽ được load. Điều đó có nghĩa là nếu trang web của bạn không sử dụng cache, mỗi lần load trang sẽ load lại toàn bộ các file css, script dù nó có thể giống y hệt trang trước đó → tăng load-time.\r\n\r\nCác browser đều có bộ nhớ cache nên hãy tận dụng nó để tăng tốc độ load trang của bạn, nhưng tuyệt đối không [dùng máy của khách để đào bitcoin](https://coinhive.com/).\r\n\r\n**Cách khắc phục**\r\n- [Sử dụng Cache-Control và ETags để thiết lập cache-policy](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#cache-control) cho trang web của bạn.\r\n- Sử dụng [service-worker trong progressive web app](https://qmau.me/blog/post/progressive-web-apps-qmau-me-cho-ios) để precache tài nguyên trong lần load đầu tiên.\r\n\r\n## Challenge\r\n- Lighthouse audits của qmau.me đạt 100.\r\n- Tìm hiểu về AMP - công nghệ mới của google để load trang nhanh chóng.\r\n- KPI load-time qmau.me \u003c 500ms\r\n- Viết một bài cụ thể hoá tất cả những kiến thức ở trên.\r\n\r\n## TL;DR\r\n- Load-time của website ảnh hưởng rất lớn đến trải nghiệm người dùng, từ đó cũng ảnh hưởng đến lợi nhuận, vị trí trên google và tỉ lệ quay lại trang.\r\n- Quá trình tối ưu hoá load-time của website có rất nhiều bước, đòi hỏi nhiều công sức nhưng đáng để được quan tâm.\r\n- Keep everything simple at first, hãy cố gắng phát triển ứng dụng web có tâm, không sử dụng những gì không cần, tư duy mobile-first và trong sáng nhất có thể.\r\n\r\n## Refs\r\n- [Google pagespeed](https://developers.google.com/speed/docs/insights/v4/reference/)\r\n- [Speed up your website](https://www.crazyegg.com/blog/speed-up-your-website/)\r\n- [Google webspeed](https://developers.google.com/speed/)\r\n- [Sử dụng CDN để giảm tải cho Server](https://viblo.asia/p/su-dung-cdn-de-giam-tai-cho-server-ymwGXOxoM4p1)\r\n- [Find out how you stack up to new industry benchmarks for mobile page speed](https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/)\r\n\r\n## Bài viết gốc tại blog cá nhân\r\n https://qmau.me/blog/post/12-cach-toi-uu-hoa-website-thoi-dai-cua-mobile-first\r\n \r\nPeace, sớm gặp lại mọi người."
                }, {
                "id": "h86Tem0xTQr5DyqJmoXJGw",
                "title": "Mô hình Polyglot trong Microservice",
                "content": "Giaosucan's blog chia sẻ kiến thức theo cách bá đạo\r\n\r\n### http://www.giaosucan.com/\r\nmicroservice polyglot\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/s3tv5pkwn5_image.png)\r\n##Polyglot là gì?\r\nPolyglot vốn là một từ trong đời thường ám chỉ những người có khả năng nói được nhiều ngôn ngữ khác nhau. Chẳng hạn một người châu âu có thể nói 3 , 4 thứ tiếng Anh Pháp Trung Nhật, một anh Việt Nam nói được chục thứ tiếng cỡ như Mán, Mường, H’ mông, Ê đê. Họ trở thành những polyglot. Đại loại những thanh niên nào đa tài, đa zi năng, cái gì cũng biết thì gọi là Polyglot.\r\nKhái niệm Polyglot trên cũng được áp dụng vào Microservice. Trong mô hình này, chúng ta không sử dụng duy nhất một loại database như kiến trúc đơn khối mà sử dụng một tập hợp nhiều loại database khác nhau như NoSQL, Graph, ElasticSearch…Cũng giống như anh Tây xài được nhiều ngoại ngữ\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hygx3azk4n_image.png)\r\n##Cần Polyglot để làm gì\r\nHãy xem xét một bài toán thực tế sau\r\nBạn có một website bán hàng, user truy cập tìm kiếm sản phẩm, order và thực hiện payment. Website sử dụng kiến trúc microservice với các service Search, Order và Payment, và chỉ dùng duy nhất một loại database quan hệ như sau\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/zmdmn3x0lh_image.png)\r\nDo số nhọ nên bạn gặp toàn khách hàng chơi lầy, search, order sản phẩm thì rất nhiều nhưng đến  giai đoạn payment thì quịt. Như vậy thì service Search phải handle 1 số lượng lớn request tìm kiếm từ phía user, trong khi tốc độ query data trong database relational thì chậm (do số lượng record quá lớn), dẫn tới quá tải và service ngủm củ tỏi luôn.\r\nHệ thống hoạt động không ổn định, khách hàng thì chơi lầy nên ko bao lâu thì bạn sạt nghiệp, phải vác bơm ra hè kiếm cơm.\r\nLúc này thì mô hình Polyglot sẽ phát huy tác dụng, tận dụng được tính độc lập của kiến trúc microservice, bạn chỉ cần thay thế Database quan hệ Search bằng loại database khác hỗ trợ tìm kiếm tốc độ cao như ElasticSearch, MongoDB là xong, khỏi phải lo optimize SQL query, nâng cấp database….\r\nĐối với kiến trúc đơn khối truyền thống, bạn bị bó buộc vào việc chỉ sử dụng được 1 loại DB duy nhất\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/iict2z2arw_image.png)\r\nthì microservice cung cấp cho chúng ta một giải pháp linh hoạt hơn. Tùy theo nghiệp vụ của service bạn tự lựa chọn loại database cho phù hợp\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/6skwij6rx4_image.png)\r\nVí dụ service chuyên tìm kiếm thì sử dụng NoSQL, service chuyên đọc ghi CRUD thì dùng relational database, service làm việc với dữ liệu quan hệ phức tạp thì dùng Graph (Neo4J) database. Tóm lại đông tây y kết hợp đủ cả.\r\n##Nhược điểm của Polyglot\r\nCái gì hiện đại thì cũng hại điện, mọi thứ đều có mặt trái của nó. Polyglot cũng vậy, sử dụng quá nhiều loại database khác nhau đồng nghĩa với bạn phải làm quen với nhiều loại công nghệ đi kèm, chi phí phát triển và bảo trì hệ thống cũng tăng lên.\r\nHơn nữa, mỗi loại database lại sử dụng những format data khác nhau (NoSQL thì dùng JSON, document, SQL thì dùng record, Graph database dùng data dạng graph gồm node, edge…) nên việc xử lý data consistency giữa các database cũng là một thách thức lớn.\r\n##Kết luận\r\nHiểu được ưu nhược điểm của Polyglot sẽ giúp bạn có cách trade off, lựa chọn database phù hợp. Tốt nhất là service của bạn cần thế nào thì chọn database theo thế đấy. Lời khuyên là cũng không nên cố xài lắm database làm gì. Nó có thể dẫn bạn đến tình trạng cái gì cũng chơi, chơi quá độ đến mức liệt, cuối cùng là chẳng chơi nổi cái gì. \r\n"
                }, {
                "id": "slYU0NPnPoW67bhvUhpg7A",
                "title": "Phương pháp thần thánh cho kì thi TOEIC",
                "content": "##1, TOEIC là cái gì ? , nó có thể giúp ích cho chúng ta những gì ??##\r\n![alt](http://www.cleverlearnvietnam.vn/wp-content/uploads/2015/06/toeic.jpg)\r\n- TOEIC (viết tắt của Test of English for International Communication – Bài kiểm tra tiếng Anh giao tiếp quốc tế) ,đây là một bài thi nhằm đánh giá trình độ của các người học tiếng anh ,\r\nđặc biệt là những ngưởi yêu thích công nghệ,code....vì để có môt cái gọi là pro trong IT thì phải có cái pro trong tiếng anh\r\n- Tiếng anh là một thứ tiếng rất quan trọng , nó như một thứ tiếng thứ 2 vậy , nên cái mình muốn là : ai cũng học tiếng anh =)) (có cả mình nữa !!), ngoài TOEIC ra thì chúng ta còn phải nói về IELTS,đây cũng là một kì thi giúp chúng ta nâng cao trình độ tiếng anh của mình lên \r\n\r\n\r\n# IELTS và TOEIC có gì khác nhau ??\r\n- về IELTS thì nó khó hơn TOEIC rất nhiều vì TOEIC là tiếng anh thường nhật ,công sở     nên nó chỉ dùng khi đi xin việc\r\n\r\n- TOEIC  chỉ có nghe và đọc\r\n- TOEIC chỉ có trắc nhiệm \r\n- vốn từ của TOEIC là nhứng từ thường nhật,công sở nên khá dễ nhớ\r\n- IELTS thì nó có những câu tự luận để trả lời và điền từ vào đấy!!\r\n- IELTS thì có cả 4 cái kĩ năng reading,speaking,listening,writing:smile:\r\n- IELTS còn dùng những từ trong academic rất khó để nhớ\r\n\r\n##2.Cách ôn thi TOEIC  và một số mẹo khi chúng ta thi TOEIC ?\r\n###Trước khi đi vào thì các bạn hãy xem video này nhé!!\r\n[link](https://www.youtube.com/watch?v=dEe6aAqjSrA)\r\n- Đây cũng là một câu hỏi mình cũng đã thắc mắc rất lâu rồi ?? nhưng nhờ sự mày mò kiếm tài liệu về TOEIC  thì mình cũng có một số mẹo và cách ôn thi của nó (mình mò mất 1 tuần đấy) sau đây mình sẽ chia sẻ bạn cách ôn thi TOEIC nhé :\r\n\u003e Khi chúng ta học TOEIC thì mất tầm khoảng 2 ,3 thắng gì đấy nên cái quan trọng nhất chính là kiên trì và thói quen =))\r\n\r\n#### - Nó gồm 3 giai đoạn\r\n- giai đoạn 1 : mở đầu chúng ta phải ôn tập về từ vững và các cấu trúc,luyện tập các kĩ năng nghe và đọc,vì trong TOEIC chủ yếu là đọc và nghe nên từ vựng là một yếu tố rất quan trọng đấy\r\n\u003eMình cũng đã từng đăng kí thi B1,nó cũng có 1 số cái na ná như TOEIC ,B1 nó đầu tư rất nhiều về từ vựng và cấu trúc , và nó đánh giá rất cao về kĩ năng nghe và nói  \r\n\r\n- giai đoạn 2 : Theo em thì đây là một trong những giai đoạn quan trọng nhất trong các giai đoạn khác vì đây là thời gian mà chúng ta cần luyện đề và làm quen với nó để chúng ta luyện đề thì mình cũng đã xem tài liệu nên lấy từ đâu:\r\n-Cuốn sách Starter TOEIC (trích trong \"Code dạo kí sự\"), Cuốn sách này rất đẽ tìm tên các ebook,facebook,theo mình các bạn nên tải file PDF về đọc nó có cả Mp3 nên vẫn rất thoải mái đấy đây chính là hình dạng của nó\r\n![alt](http://www.mshoatoeic.com/uploads/images/userfiles/13299688568683.jpg)\r\nCuốn sách này rất thích hợp cho những bạn mới khởi đầu khi thi TOEIC =)) ,bề ngoài của nó là một hình cờ vua nhưng bên trong nó là những kiến thức khá hay đấy ,nó có các dạng bài tập rất tốt và thuận tiện cho việc ôn thi,\r\n- ngoài ra các bạn còn có thể tìm đọc những cuốn sách như \r\n-Target TOEIC\r\n-TOEIC Analyst\r\n![alt](http://toeicacademy.com/wp-content/uploads/2016/08/target-toeic.jpg)\r\n![alt](https://vcdn.tikicdn.com/cache/550x550/media/catalog/product/t/o/toeic-analyst-second-edition-a.jpg)\r\n\r\n- giai đoạn 3 : là thời gian hầu hết bạn dánh để thi thử và đếm thời gian nhé , trong các cuốn mình đã chia sẻ thì cũng đã có đề rồi nha !!!!\r\n\r\n\u003enếu các bạn cảm thấy không có động lực để  học ý thì đăng ký đi rồi thi cũng dc =))\r\n\t\r\n[Link](https://www.youtube.com/watch?v=1h_K0sUTAoc)\r\n\r\n\u003e đây là video nói về các từ vựng trong TOEIC nha !! nếu bạn có thời gian thì có thể tìm các tips của TOEIC nhé ,nhưng bạn phải nhớ điều quan trọng nhất là : NĂNG LỰC !\r\n\r\n\r\n#Chúc mọi người thi tốt !!\r\n\r\n\r\n"
                }, {
                "id": "fm0C9R7TWsvWbCj0Z5FHwA",
                "title": "Tại sao các công ty không gửi mail báo \"rớt\" cho bạn là những công ty có HR tệ nhất quả đất?",
                "content": "# Chuyện của tôi\r\nVào đợt nghỉ lễ giỗ tổ Hùng-King vừa rồi, mình có nhận được một mời phỏng vấn ở một công ty A nọ. Mặc dù thời điểm phỏng vấn không tốt lắm, 1h30PM, thời tiết khá nắng nóng vào hôm đó, nhưng mình vẫn quyết định tới tham gia buổi phỏng vấn đúng giờ. Kết thúc buổi phỏng vấn, mình nhận được feedback là công ty sẽ gửi bài test cho mình. Và sau hơn một tuần chờ đợi thì mình không nhận được thông tin gì cả! Có thể là sau buổi phỏng vấn đó, công ty đó đã thấy là mình không phù hợp và không tiếp tục với mình. Ok, fine. Nhưng tại sao không thông báo cho mình? Trong khi mình đang ngồi chờ một bài test nào đó từ họ?\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/5d0wvv6h1k_waiting-mail.gif)\r\n\r\nCó thể rất nhiều bạn đang có những câu chuyện giống mình. Các bạn gửi CV, rồi nhận được thông báo từ HR và bắt đầu quy trình phỏng vấn. Có thể là bài test online hay là một vòng phỏng vấn trực tiếp. Sau đó bạn về nhà, chờ đợi và chờ đợi. Sau 1 tuần mà không thấy một email phản hồi nào cả, bạn đành tự hiểu rằng, \"**à, thế là mình tạch**\".\r\n\r\n# Tại sao vậy?\r\nTheo mình, có thể người HR của công ty đó cho rằng \"mình đã không gửi mail trả lời, ứng viên sẽ tự hiểu là họ rớt\". Hoặc có thể là họ đang bận ngồi xem cv của một ai đó, hay tiến hành phỏng vấn với một ứng viên khác ngon lành hơn. Nhưng tóm lại, là vào lúc này, bạn đã không còn giá trị trong mắt họ. Họ không tuyển được bạn, không kiếm được tiền từ bạn, chả có lý do gì để họ tiếp tục một cuộc nói chuyện vô nghĩa, hay phải tốn tầm 15-20 giây để copy một cái format email nào đó để gửi cho bạn!\r\n\r\nMột tình huống khác là HR muốn giữ lại như một lựa chọn backup. Nếu một ứng viên khác ngon hơn nhưng đã từ chối offer, họ có thể sẽ quay lại với ứng viên bị rớt như một lựa chọn thay thế. Thường việc này diễn ra sau vài tháng.\r\n\r\n# Tại sao tôi nói đó là những HR tệ?\r\nTôi từng phỏng vấn ở một công ty G. Phải nói chị HR ở công ty đó là người \"nice\" nhất tôi từng gặp. Chị gọi điện, thông báo chi tiết về từng step, địa điểm tòa nhà. (Cái công ty A kia, tui phải hỏi loanh quanh mấy người bảo vệ ở nơi khác mới biết được nơi vào văn phòng của công ty đó. Họ còn thắc mắc là sao ngày nghỉ vẫn đi phỏng vấn!). Khi tôi tạch ở vòng cuối cùng, chị cũng có gọi điện và giải thích nguyên nhân tạch, abc xyz. Rõ ràng, chị đã thể hiện rõ sự chuyên nghiệp trong công việc, cũng như sự tôn trọng đối với bất kỳ ứng viên nào. Qua đó, mang lại những hình ảnh tốt đẹp về công ty.\r\nDù là tôi đã trượt, nhưng ấn tượng tôi về công ty đó rất là tốt. Nếu có ai hỏi, tôi vẫn cho rằng đó là một công ty có văn hóa, dù rằng tôi chưa làm việc ở đó ngày nào. Còn với công ty A kia, nếu có ai đó hỏi...  hmm chắc bạn biết câu trả lời của tôi rồi đó.\r\n\r\nTưởng tượng là bạn đang nói chuyện với một ai đó. Rồi bỗng nhiên người kia im lặng. Và rồi khi time-out tới, bạn đành tự hiểu là \"người ta đã không tiếp tục với bạn\". Bạn có cảm thấy đó là **bất lịch sự** không? \r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lk5b4tstyl_facebook_seen-980x420.jpg)\r\nQuy trình phỏng vấn cũng như một cuộc nói chuyện vậy. Đã có bắt đầu, thì hãy nên có một kết thúc. Hoặc là bạn sẽ từ chối những vòng phỏng vấn tiếp theo. Hoặc là HR sẽ báo cho bạn việc bạn chưa đạt một số tiêu chí. Dù là theo cách nào đi nữa, để một cuộc nói chuyện trở nên **tử tế**, hãy kết thúc một cách tử tế!\r\n\r\nNgoài ra, các bạn ứng viên đã phải dành rất nhiều thời gian cho buổi phỏng vấn. Từ việc chuẩn bị kiến thức, quá trình đi lại, rồi sắp xếp công việc trên công ty. Không thể cho rằng vì HR quá bận, hay thời gian của HR *quý* hơn của ứng viên được.\r\n\r\n# Kết\r\nViệc gửi một email thông báo tới ứng viên là tạch, không hề mất thời gian của HR. Một ứng viên, đã phải giành rất nhiều thời gian để phỏng vấn ở công ty. Họ phải chuẩn bị CV này, phải ôn tập kiến thức trước buổi phỏng vấn. Thậm chí phải xin nghỉ trên công ty hiện tại để đi phỏng vấn ở chỗ các bạn. Chưa kể quá trình đi lại trên đường cho kịp giờ phỏng vấn còn có thể gặp những rủi ro tai nạn giao thông nữa. Những việc đó tốn của ứng viên rất nhiều thời gian, công sức, và tâm huyết. **Vậy lý do gì mà HR lại tiết kiệm 15 giây trong cuộc đời mà không gửi email cho ứng viên?**\r\nThế nên, các bạn HR ạ, xin hãy dành cho những ứng viên, sự tôn trọng tối thiểu. Hãy cho họ một kết quả, để họ không phải chờ đợi trong một sự im lặng!\r\n\r\nLePhongVu 18-05-2018"
                }, {
                "id": "fxIPj2Q99PRQWojlCG_L3g",
                "title": "DB Transaction",
                "content": "Trong tuần vừa rồi, mình có đọc chương 7 cuốn sách [Designing data-intensive applications](https://dataintensive.net/buy.html). Bài viết này nhằm mục đích giúp mình tổng hợp lại những kiến thức đã học được về chương này.\r\n\r\n# 1. Các thuộc tính của Transaction\r\n\r\n## 1.1. Atomic\r\n\r\nNếu một transaction bao gồm nhiều hoạt động khác nhau để thay đổi dữ liệu, thì các hoạt động này sẽ phải hoặc là (1) tất cả đều được thực hiện thành công, hoặc (2) không có hoạt động nào được thực hiện thành công. \r\n\r\nVí dụ nếu như transaction thực hiện 2 hoạt động viết vào DB. Nếu sau khi hoạt động số 1 thành công, DB bị crash, thì transaction sẽ bị coi là thất bại. DB sẽ rollback về trạng thái trước khi hoạt động số 1 thành công.\r\n\r\n## 1.2. Consistency\r\n\r\nConsistency có nghĩa là trạng thái của DB trước và sau transaction luôn thỏa mãn một số bất biến về dữ liệu. Bất biến về dữ liệu có thể là các khóa ngoại, hoặc các primary keys, hoặc các constraint, hoặc là các bất biến do tầng ứng dụng yêu cầu.\r\nCác ứng dụng dựa vào các đặc tính khác của DB (như Atomic, Isolation) để đảm bảo tính Consistency của dữ liệu. \r\n\r\nTầng ứng dụng có thể yêu cầu một số bất biến như sau: trong một ứng dụng về notification, nếu chúng ta sử dụng denormalize để add thêm 1 trường unseen_notification_count cho mỗi user, khi user có thểm một notification chưa được đọc, thì trường `unseen_notification_count` sẽ được tăng lên 1. Ứng dụng notification này sẽ yêu cầu bất biến là: giá trị của `unseen_notification_count` của mỗi user phải bằng với số lượng hàng trong bàng Notification mà có `user_id` = id của user và có cột `is_seen` = false\r\n\r\n## 1.3. Isolation\r\n\r\nCùng một lúc, DB có thể được truy cập bởi nhiều clients. Nếu các clients cùng truy xuất vào một phần dữ liệu, thì sẽ nảy sinh các vấn đề liên quan đến concurency.  Ví dụ: trong DB có một biến đếm, có 2 clients cùng muốn tăng biến đếm này lên một. Giả sử giá trị ban đầu của biến đếm là 10, sau khi 2 transactions thực hiện xong, chúng ta mong muốn biến đếm phải nhận giá trị là 12. \r\n\r\nIsolation nghĩa là các transaction là được phân tách với nhau. Có nhiều mức độ về việc phân  tách (isolate) của dữ liệu. Chúng ta sẽ cùng xem xét một số mức độ ở phần tiếp theo\r\n\r\n## 1.4. Durability \r\n\r\nDurability đảm bảo rằng một khi transaction đã được commit thành công, thì dữ liệu được thay đổi bởi transaction này sẽ được lưu trữ an toàn.\r\n\r\nĐối với trường hợp của DB trên một máy, điều này có nghĩa là dữ liệu được lưu trữ vào ổ cứng (HDD, hoặc SSD), nó cũng bao gồm việc dữ liệu được lưu vào một WAL, hoặc một cấu trúc dữ liệu tương tự (BTree)\r\n\r\nĐối với trường hợp của hệ thống phân tán, durability có nghĩa là dữ liệu sẽ được lưu trữ thành công trên một hoặc một vài máy (replicate)\r\n\r\n# 2. Các mức độ về Isolation\r\n\r\n## 2.1. Read Committed\r\n\r\nRead Committed đảm bảo DB sẽ không có 2 hiện tượng Dirty Read và Dirty Write\r\n\r\n### 2.1.1. Dirty Read\r\n\r\nDirty Read là hiện tượng mà transaction đọc thấy dữ liệu chưa commit từ một transaction khác.\r\n\r\nDirty Read sẽ dẫn tới 2 hệ quả:\r\n\r\n+ Nếu `txn1` cập nhật nhiều bản ghi, `txn2` thực hiện cùng sẽ nhìn thấy một số cập nhật của `txn1` , điều này sẽ khiến users băn khoăn. Ví dụ, Khi có một notification mới tới, hệ thống phải làm 2 việc:\r\n\t1. tạo mới một notification, cập nhật trường `is_read` trong notification là `false`\r\n\t2. tăng giá trị của trường `notification_count` trong bảng User\r\n\r\nVì Dirty Read, `txn2` sẽ thấy có thêm một notification mới, nhưng notification_count vẫn là 0\r\n\r\n![figure-1](https://www.planttext.com/plantuml/img/NT31Yi8m40RW-pp5qDDw46oz5H4bddEG7XRKGsn63BGJIISi2truqwfWUmlvv_-OPDU92HBR1a2SD8G75-GVZsJicSyCZvIwsZqC2rQ_EaVJOPLFhhKVZaQSvo7Lap3xJfMFB1IoSKpDxMAq2m0JnNDihnGmsrotFwj51bMEootg4kj0HWYP_f0JVNFroxxvWB5BbJreNARPAYznh9tkpbhYIwghSgAll_pYxIVUeccQcHvyE-EBnFTz_zbCbUXuMAwZQRL-FHgq-gm5i2EswS-V)\r\n\r\n\r\n+ Nếu `txn2` đọc dữ liệu từ `txn1` nhưng `txn1` bị rollback, `txn2` sẽ đọc thấy những dữ liệu chưa được rollback của `txn1`. Ví dụ khi thực hiện việc chuyển tiền từ user A sang user B, `txn1` làm 2 việc:\r\n\t1. giảm balance của user A\r\n\t2. tăng balance của user B\r\n\r\nNếu `txn2` đọc dữ liệu, sẽ thấy balance của user B được tăng lên, tuy nhiên do `txn1` bị rollback, nên thực chất balance của user B là chưa thay đổi\r\n\r\n![figure-2](https://www.planttext.com/plantuml/img/RP0_2y8m4CNt-nIFBkeWs8v5n0Hd1udWu79fCmHZb2GTX7vuszBw3zVtVlVkxcrZuf2QgoDADZc3dGtfWOFX6lg1S7DEStKv-xCduYRTV7FL9Y1RwyryjSZetetRojxP9wZJFWT7gFnBpewncn1PRua_ZXmS-HjL35454QaSomr4YTfKmN0q49X5Q7RiAqC2oyvMUOcHb2Mi7qdvISg9fBPjIHKZ7FflFq5CP36Iqm5J7-z5BuMsnjTTaKy0)\r\n\r\n### 2.1.2. Dirty Write\r\n\r\nKhi nhiều transaction cùng cập nhật vào một dữ liệu, thông thường transaction thực hiện sau sẽ ghi đè lên dữ liệu của transaction thực hiện trước. Dirty write là hiện tượng các transaction bao gồm việc cập nhật lên nhiều (\u003e 1) bản ghi, và transaction sau có chứa bản ghi cũng bị ghi đè bời transaction trước. \r\n\r\nVD: trong hệ thống bán hàng online, một sản phẩm khi mua sẽ bao gồm 2 hành động:\r\n\r\n+ cập nhật trường `buyer_id` trong bảng listing cho sản phẩm đó \r\n+ cập nhật trường `buyer_id` trong bảng invoice cho sản phẩm đó\r\n\r\nNếu 2 user A và B cùng thực hiện việc mua hàng thông qua 2 transaction `txn1` và `txn2`. `txn1` thực hiện việc cập nhập listing trước `txn2` , nhưng cập nhật invoice sau `txn2` \r\n\r\nTheo quy tắc ghi đè dữ liệu, cuối cùng listing cho sản phẩm sẽ có `buyer_id`  là user B, nhưng invoice cho sản phẩm đó, sẽ có `buyer_id` là user A\r\n\r\n![figure3](https://www.planttext.com/plantuml/img/ZT51IyD040NW-_oAHqvwABWv1YrLl2o4dXRqK91DCkX0kWcRsKeXFzxOe1X1oVKzveF7x0RrKTEn9LBHbl4eKSzuYg9y28T0FcaNqh7YYEossbxTN6VKJoTII--3mZtl3Vm0PnPnLigW4bwppwvSLZQSEgdvKjdVM7x1SY9o1fijoWAfRxmosbd4m8egdJc-I8CxtEFzZIEZZrsJQfr3GoKsqxKp1MWSHtBvAkpXNomlVbZssv9vpqhBBYspolfZfFqQIRJZq4nl_000)\r\n\r\n### 2.1.3. Cách cài đặt\r\n\r\nĐể tránh Dirty Write, chúng ta sẽ sử dụng các lock. Mỗi một bản ghi sẽ được cấp một lock. Một transaction khi muốn cập nhật bất cứ bản ghi nào, sẽ phải giữ lock cho bản ghi đó, lock này chỉ được trả lại sau khi transaction đã commit hoăc bị rollback. Nếu lock của bản ghi đang bị giữ bởi transaction khác, transaction hiện tại sẽ phải đợi cho tới khi lock đó được trả lại.\r\n\r\nHình vẽ sau mô tả thuật toán dùng lock để tránh Dirty Write\r\n\r\n![figure4](https://www.planttext.com/plantuml/img/bP4nJyCm48Lt_ugdJZ1K8XahL3LLvawMOEXoSLngOVk2SwP2oe_7gK2eGGmCjznzxzqxtMuKIfA3LqgSU8l6lt1oSWuG1hspwz6x91zuAbrxZCUebA8i77FeRCBgiTlUFTolr51yd743HO5-FbIW4RgwQRSarD5evr6xNohggw8kzhh2Ubk83SYOj-nIKS2pUGMVaFY21YTEkCo9bAx_0RTxh0kjgmsIbPpYabNJD5th9qCUUXBxDVvjq2nmmo4umItfxNosdErYspTK_vb7xMpioty-0G00) \r\n\r\nĐể tránh Dirty Read, chúng ta có 2 giải pháp:\r\n\r\n+ Sử dụng cùng lock như đã mô tả ở phần trên. Khi một transaction muốn read dữ liệu tử một bản ghi, transaction này sẽ phải cầm lock của bản ghi đó, sau khi đọc dữ liệu xong  (chứ không phải là sau khi transaction commit hoặc rollback như ở phần trên), transaction sẽ trả lại lock. Nếu lock bị giữ bởi transaction khác (do read hoặc write), transaction này sẽ cũng phải đợi cho tới khi lock được trả lại. Giải pháp sử dụng lock như trên khiến cho performance của hệ thống bị giảm. Một thao tác ghi sẽ làm tất cả các thao tác đọc bị ngừng lại, dẫn tới latency cho việc đọc bị tăng lên. \r\n\r\n![figure5](https://www.planttext.com/plantuml/img/ZP4_QyCm4CLtVOf7fdO8r1v32N7mM3eK3Hsod2sb4T4VLpur1FpXUmaj9Iw53XfEztlltd6RaIbp2LufTkmj6l-MikD302VGHt86ncK-uyMIGNV6K-gFkxYBIYagd689dSrOF7RhkuVxXHh4plLkeCZGhyyLQ8IkRhvROkfej9TMkvqhwgkY5djTORaMOWNg-_VYiYZWPJpI7ZcTq62VCauIrofT_mlEieLgjrWAhAkLr5nodADgcgRh-ubG1aDilzg_3PePtgSG7EEMzFQoDH_iRDetLF-PHsriD7AbJm00)\r\n\r\n+ Giải pháp khác có hiệu năng tốt hơn đó là mỗi một bản ghi sẽ có 2 phiên bản: phiên bản trước khi được cập nhật, và phiên bản đang chờ commit. Khi đọc dữ liệu, DB sẽ luôn trả về phiên bản trước khi được cập nhât. Sau khi transaction thực hiên thành công, phiên bản trước khi được cập nhật sẽ được update giá trị mới. Giải pháp này giúp cho các thao tác đọc không cần đợi lock từ thao tác ghi. \r\n\r\n![figure6](https://www.planttext.com/plantuml/img/VP6nQWCn38PtFuN8r0o1tbfAICAD9KEueKEWw6odCJrRXotVKRY7ZvmRchIaWq7ebxvVaZU9CNBsdLBikBEmxJufEZvxO08So1amBl8t72mQ64MXpF16-kiOZa4fXPafPD_Q28lNTltql5oeNfXEknu3G_E-1qpGL7VP6XbRJBP8zKumJGMhjOGl48kH4HrEaJn46c6hwXsiH6-gedEE0QWp7uEDoP749ocPfkdwVaYZB69db2mpWr2p6r3IubgWSsNkJSdbeCbxQRf7b-vWnolfPX9bx2tjb_bCWWU6IIwfpt-MA4uFXlZ7U6E3aI-y0000)\r\n\r\n## 2.2. Snapshot Isolation\r\n\r\nRead Commited có thể tránh được các vấn đề của Dirty Read và Dirty Write, tuy nhiên nó vẫn không đảm bảo tính toàn vẹn của dữ liệu trong một số trường hợp. Chúng ta sẽ xem xét các trường hợp lỗi mà Read Committed có thể gây ra dưới đây\r\n\r\n### 2.2.1. Read Skew\r\nQuay trở lại bài toán về Notification được mô tả trong phần 2.1.1. Về phía ứng dụng, chúng ta muốn: số lượng notification chưa đọc = với giá trị của `notification_count`. Tuy nhiên xét tính huống sau:\r\n\r\n![figure7](https://www.planttext.com/plantuml/img/RP6nZi8m38PtFuNLYHkGICSA8QJk6UuoCB24O7GHr4698vO-FA7GWvww-l_ynR-oJMAZvEu285ukXDzaZ_XpfjkUzmm0DalWt1qeOhK-R1QhhmgkPSKxVxKiQ7PQeKrer6IiW_YJTrPyu4Ui9sarYTkGMIXM0zV-jzU3lIwd68NB3Ue6JoJk5pCd8aR-K2NGk2oCKGr6aXnvdkhx7apzilb2H46csxohRd24smVj8jb44nRTimA2RiUbzmCkT9sN3yThC5oXnk6pr9prJ_fkDOl1blXOll8E)\r\n\r\nTrong tình huống này chúng ta có 2 transaction: `txn1` và `txn2`. Ở bước (1), `txn1` query vào bảng Notification để lấy ra các unseen notification. Lúc này DB trả về 0. \r\nNgay sau đó, trong `txn2` tại bước (3) và bước (5), một Notification mới được tạo ra, đồng thời `notification_counter` cũng được cập nhật (tăng lên 1). Sau khi `txn2` commit, tại bước (9), trong `txn1`, nếu user fetch lấy giá trị từ `notification_counter`, `txn1` sẽ thấy giá trị là 1. \r\n\r\nTuy nhiên điều này dẫn tới việc trong `txn1`, số lượng unseen notification (lấy ra ở bước 1) là khác với giá trị của biến đếm unseen notficiation. \r\n\r\nHiện tượng này được gọi là Read Skew. Nguyên nhân của Read Skew là do dữ liệu một transaction nhìn thấy trong suốt thời gian tồn tại của nó, là bị thay đổi bởi transaction khác thực hiện cùng lúc. Giải pháp cho vấn đề này chính là: mỗi một transaction chỉ được nhìn thấy một snapshot của DB trong suốt thời gian tồn tại, bất cứ dữ liệu nào được thêm mới, là phải do chính bản thân transaction đó.\r\n\r\nChính vì thế, mức độ này còn được gọi là Snapshot Isolation\r\n\r\n### 2.2.2. Sử dụng MVCC để cài đặt Snapshot isolation\r\n\r\nSnapshot Isolation còn có tên gọi khác là MVCC (mutliple version concurrent control). Thuật toán này có thể coi là sự tổng quát hóa của thuật toán chống Dirty Read ở mục 2.1.3. Với mỗi bản ghi, thuật toán chống Dirty Read chỉ sử dụng 2 version: old_data, và uncommited_data. Tuy nhiên trong thuật toán MVCC, mỗi một bản ghi sẽ có nhiều phiên bản. \r\n\r\n+ Mỗi một transaction khi bắt đầu thực hiện sẽ được gán cho một ID. ID của transaction là duy nhất và tăng dần theo thời gian.\r\n\r\n+ Mỗi một bản ghi trong DB sẽ được lưu lại 2 trường: trường `created_txn` lưu lại ID của transaction tạo ra bản ghi này, và trường `deleted_txn` lưu lại ID của transaction xóa đi bản ghi này.\r\n\r\n+ Mỗi thao tác update bản ghi sẽ được chuyển thành 2 thao tác: thao tác xóa bản ghi cũ và thao tác tạo ra bản ghi mới. \r\n\r\n+ Một bản ghi được cho là valid nếu như trường `created_txn` của bản ghi đó  \u003c trường `deleted_txn` \r\n\r\n+ Một transaction với id `txn_id`, chỉ có thể nhìn thấy các bản ghi valid và đã được commit mà có trường `created_txn` \u003c `txn_id`, hoặc là các bản ghi chưa được commit nhưng có `created_txn` = `txn_id`. Hay nói cách khác, transaction chỉ nhìn thấy các bản ghi được tạo ra trước, hoặc trong bản thân transaction này. \r\n\r\nBiểu đồ sau biểu diễn cách hoạt động của MVCC trên bảng Notification\r\n\r\n![figure10](https://www.planttext.com/plantuml/img/fPB1JuCm5CRl_IjUE869oOex6LssGLKIWGIANaYM0ZLfmif2YthWZxTC4fdpW7feclHzlxxlVUrQQTRgRbyZf8MkEOHFdfVBN2BMwKPs-uAtODqKAtlXMEXWjA8K1oOrM9ao9Mm1Kv3XavBFD2kOuaF9t_v0kP-KYn3AC5okZEeQjkG-Y80ccoZTU3I8erpgTxaJ5Tm2HfaxG-V2yRvH64GfIQZPQ0nHeyMBA9aMZLGsTd9PjfnfNkqCEpI0OuUHJCaZyIXSm5qIXwSiF3-GXC0hgpi-SBcq5z0sRygPZEB5OHZGYUVneE_xuver35pD36VvT-juiEvCG_CDJybClk8r_yfmUJxmMII_Jk3VZ_BTqfhBolpt3m00)\r\n\r\n### 2.2.3. Nhược điểm của MVCC\r\n\r\nMVCC có một số nhược điểm: \r\n\r\n+ Một bản ghi không thực sự bị xóa trong DB trong MVCC. Nó chỉ bị đánh dấu `deleted_txn` mà thôi. Điều này dẫn tới nhiều bản ghi sẽ bị lưu giữ thừa. \r\n\r\n+ Các transaction ID là tăng liên tục, nếu giả sử chúng ta lưu trữ transaction ID bằng một số 32bit, thì hệ thống chỉ có thể xử lý 2^32 transactions. Số lượng transaction ID quá lớn, nó sẽ bị rotate về 0. Tuy nhiên điều này làm cho transaction 0 không nhìn thấy các transaction được thực hiên trước nó?\r\n\r\n+ Thêm vào đó, liệu rằng MVCC đã thỏa mãn hết các điều kiện về isolation của Transaction hay chưa? Các trường hợp như Lost Update, hay là Write Skew sẽ ảnh hưởng như thế nào?\r\n\r\nTôi hy vọng có thể trả lời thêm về những vấn đề trên trong bài viết tiếp theo\r\n"
                }, {
                "id": "4ADL9ipfc0d1pYOiAu5-1w",
                "title": "Bài toán phân quyền vấn đề muôn thuở và rất khó hiểu.",
                "content": "(* Trong bài viết này mình chỉ nêu quan điểm và những thứ mình đã từng làm với việc phân quyền trên thực tế, chỉ mang tính tham khảo cho mọi người. Nếu có bất kỳ ý kiến góp ý nào hãy bình luận ở dưới để chúng ta cùng thảo luận thêm.)\r\n\r\nPhân quyền công việc mang đầy tính năng nề đối với dev nhưng lại đầy sáng tạo cho người dùng. Như bạn biết khi phần mềm được dựng lên là có vô vàn rắc rối xoay quanh quyền hạn người sử dụng, Vì thế lập trình viên đã tạo ra một thứ mang tên phân quyền để tránh tình trạng mọi người đều là vua trong chương trình đó đơn giản với việc \"Bạn được quyền làm việc đó hay không?\".\r\n### 1. Phân quyền là gì?\r\nTưởng tượng đơn giản như này nhé. \r\n\r\n- Bạn là sếp bạn có toàn quyền với nhân viên của mình\r\n- Bạn là trưởng phòng bạn chỉ có quyền với nhân viên trong phòng của mình\r\n- Bạn là trưởng nhóm dự án bạn chỉ có quyền với các thành viên trong nhóm\r\n- Và Nhóm \u003c Phòng \u003c công ty.\r\n- Như vậy bạn có thể thấy trong công ty này có 3 loại quyền hạn và chúng ta cần phân quyền theo nó\r\n\r\n### 2. Bạn thường dùng loại phân quyền như thế nào?\r\n- Câu hỏi này mình đặt ra ban đầu là \"Có các loại phân quyền nào?\" nhưng thật sự việc phân quyền này rất ít được public do nó mang tính chất riêng tư của những dự án. Nên nếu bạn search thì chủ yếu sẽ chỉ tìm được cách tạo tài khoản sử dụng cho user trong các HQTCSDL.\r\n- Ở bài viết này mình sẽ nói về việc phân quyền bằng nhóm quyền (Group) Và đưa ra 1 số cách dựng CSDL (db).\r\n\r\n### 3. Phân quyền theo group là gì và làm như thế nào ?\r\n- Phân quyền theo group là cách gọi chung của mình cho việc bạn nhóm nhiều thành viên trong 1 tổ chức có cùng một quyền hạn thực thi công việc. Lúc đó ta có thể nhóm họ vào 1 group để dễ dàng trao quyền hạn.\r\n- Như vậy từ cách phân quyền theo group này ta có thể sử dụng với \"3 nấc\" khác nhau.\r\n\r\nVí dụ đơn giản về 3 cách này nhé :D\r\n\r\n#### 1. Phân quyền theo cấp bậc\r\n- Loại hình này chúng ta thường thiết kế db đơn giản như sau\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/c6i21irvwu_image.png)\r\n\r\n- Khi đó dữ liệu bạn dùng sẽ có dạng như thế này.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/qvim1d53xl_image.png)\r\n\r\n- role ở đây là 1, 2, 3 tức là có 3 mức quyền hạn và lớn nhất hay bé nhất còn tùy thuộc vào quy định của mỗi công ty. Ví dụ\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/3bh7ltgo2p_image.png)\r\n\r\n##### - Ưu điểm\r\nViệc sử dụng kiểu phân quyền này dễ dàng cho những người mới bắt đầu. Những nhóm quyền được lập lên nhanh chóng có thể sử dụng luôn, Và việc phải check cũng tương đối là đơn giản, bạn chỉ cần 1 cần \r\n````\r\nselect count(*) from tbl_... where id = ? and role = ?\r\nhoặc\r\nselect role from tbl_... where id = ?\r\n````\r\nRất dễ dàng để sử dụng đúng không. :D\r\n##### - Nhược điểm\r\nBạn biết đó việc sử dụng dữ liệu như này tồn tại 1 số nhược điểm rất lớn sau\r\n- Rất khó có thể mở rộng dự án\r\n- Trong thực tế không phải lúc nào cũng có 3 role. Nó có thể phát sinh nhiều role kì dị. Ví dụ: **Thư ký giám đốc ngoài quyền đuổi việc ra còn lại nó sẽ có quyền của giám đốc** vậy trường hợp này thuộc role 1 hay 2 ?.\r\n- Rất khó để phân quyền chi tiết.\r\n\r\n#### 2. Phân quyền theo chức năng\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/96k4geh52a_image.png)\r\n\r\nLoại phân quyền này được sử dụng rất nhiều trong thực tế. Nó rất hiệu quả và dễ thao tác đối với người cấp quyền.\r\n\r\nTa thiết kế db đơn giản trong ví dụ này như sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/vp345fhxdr_image.png)\r\nNhưng để Demo mình sẽ tóm gọn 2 bảng **tbl_action** và **tbl_per_action** thành bảng **tbl_per_detail** để dễ thao tác. Và ta có một Database như sau.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ugp2lz5646_image.png)\r\nChi tiết của việc thiết kế DB như sau:\r\n\r\n* **tbl_user**: bảng lưu người dùng bao gồm các thuộc tính như ID, Name,.... Bảng không có khóa ngoại.\r\n* **tbl_permision**: bảng chứa nhóm quyền hạn. bao gồm các thuộc tính, ID nhóm quyền hạn, tên nhóm quyền hạn.\r\n* **tbl_permision_detail**: là bảng sẽ chứa những quyền hạn cụ thể dành cho nhóm quyền hạn. Trường **action_name** không cần thiết bạn có thể bỏ. Trường **action_code** là để khi lập trình mình định nghĩa một thao tác nhất định trong bằng code này ví dụ quyền sửa thì code nó là **EDIT** chẳng hạn.\r\n* **tbl_per_relationship**: là bảng lưu mối liên hệ giữa người dùng và nhóm quyền hạn. Mục đích của bảng này không phải là để một người dùng có nhiều nhóm quyền mà để không phải truy vấn lại bảng user chứa thông tin nhạy cảm như username và password. Bạn cũng có thể **bỏ qua** bảng này và liên hệ trực tiếp giữa bảng user và permision luôn, nhưng mình khuyên bạn nên sử dụng thêm bảng này vì có nhiều trường hợp **user có nhiều quyền hạn**.\r\n\r\n**1. Kiểm tra dữ liệu trong các bảng**\r\n\r\n- **tbl_user**\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/vdb3rspaej_image.png)\r\n\r\n- **tbl_permision**\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/949j9mp1r5_image.png)\r\n\r\n- **tbl_per_detail**\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/yvo02saoht_image.png)\r\n\r\n- **tbl_user_per**\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/6al33komme_image.png)\r\n\r\n**2. Làm một số ví dụ**\r\n\r\n- Kiểm tra quyền của người dùng ví dụ: Hãy kiểm tra quyền của user có id là 1:\r\n\r\n```\r\nDECLARE @result NVARCHAR(1000)\r\nSET @result = N'Những quyền hiện tại của user ('\r\n\r\nselect @result = @result + name_user + ') là: ' from tbl_user where id_user = 1\r\nselect @result = @result + action_name + ', ' from tbl_user as u\r\n\tjoin tbl_user_per as up on u.id_user = up.id_user\r\n\tjoin tbl_permision as p on up.id_per = p.id_per\r\n\tjoin tbl_per_detail as pd on p.id_per = pd.id_per\r\n\twhere u.id_user = 1 and up.licensed = 1 and pd.check_action = 1\r\nselect @result = substring(@result, 0, len(@result))\r\n\r\nprint @result\r\n```\r\n- kết quả\r\n\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/x8xbv0eitj_image.png)\r\n\r\n- Kiểm tra xem user 2 có quyền xóa bài viết không ?\r\n\r\n\r\n```\r\nDECLARE @result bit\r\nselect @result = check_action from tbl_user as u\r\n\tjoin tbl_user_per as up on u.id_user = up.id_user\r\n\tjoin tbl_permision as p on up.id_per = p.id_per\r\n\tjoin tbl_per_detail as pd on p.id_per = pd.id_per\r\n\twhere u.id_user = 2 and up.licensed = 1 and action_code = 'DELETE'\r\n\r\nbegin\r\n\tif @result = 1\r\n\t\tprint N'Bạn CÓ quyền xóa post'\r\n\telse\r\n\t\tprint N'Bạn KHÔNG có quyền xóa post'\r\nend\r\n```\r\n- kết quả\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gf719a8e3c_image.png)\r\n\r\n- Đó là một số ví dụ đơn giản tron tình huống này khi sử dụng phân quyền theo nhóm (group)\r\n\r\n**3. Kết luận**\r\n##### - Ưu điểm\r\n- Việc phân quyền này như mình có nêu ngay từ ban đầu rất dễ thao tác đối với những admin khi họ muốn chuyển nhóm quyền hoặc thỏa sức sáng tạo trong việc tạo ra những quyền mới từ những quyền ban đầu. Ví dụ như người dùng vừa có thể **EDIT** và **DELETE**,....\r\n- Ngoài ra việc thực hiện những câu querry cũng rất dễ dàng cho những lập trình viên.\r\n\r\n\r\n##### - Nhược điểm\r\n- Vấn đề sử dụng quyền hành động rất dễ khi chúng ta làm việc trên 1 group, nhưng nếu trong chương trình của bạn có nhiều group và phân cấp nhiều tầng thì nó lại là một vấn đề nan giải khác, khi bạn không chỉ phải check quyền hành động mà bạn còn phải check xem quyền hành động này của người dùng có thể áp dùng được trong group khác hay không?.\r\n\r\n\r\n#### 3. Phân quyền theo *Hành động* của các *nhóm Group* theo những *cấp bậc* khác nhau\r\n- Đây là loại phân quyền lằng ngằng nhất nhưng lại là quan trọng nhất, bởi các lý do sau đây:\r\n- Các tổ chức sử dụng phần mềm để thực hiện thao tác của họ đều có phân cấp rõ ràng\r\n- Trong những tổ chức có những người nắm full quyền của nhiều nhóm\r\n- Có những thành viên thuộc nhiều nhóm\r\n- Có những thành viên tuy chỉ là nhân viên nhưng lại có quyền của các sếp (thư ký)\r\n- Chính vì có nhiều trường hợp như vậy những lập trình viên sinh ra được rất nhiều case trong code.\r\n\r\nGiải quyết vấn đề này bạn có thể tìm hiểu cách thự hiện phân quyền trong odoo.\r\n- Phân quyền theo model: Có nghĩ là người dùng được thao tác thực hiện với những bảng dữ liệu nào\r\n       \r\n       Ví dụ: Admin có thể thực hiện với thao tác với bảng user của họ\r\n- phân quyền theo raw: Người dùng được thực hiện việc thao tác với các raw được chỉ định\r\n\r\n\r\n        Ví dụ: Leader A chỉ có thể thực hiện thao tác với những thành viên của mình trong bảng user\r\n- phân quyền theo column: Người dùng sẽ được quyền thao tac với nhưng column đó\r\n\r\n        Ví dụ: Chỉ giám đốc mới có thể đuổi việc nhân viên, ở đây ta sẽ có 1 column tên là is_working để biết việc nhân viên đó còn đi làm hay không :D\r\n\r\n### 4. Kết luận\r\n- Việc bạn sử dụng cách nào hay thứ tự ra sao tưởng rằng không quan trọng nhưng nếu nhìn xa hơn trong việc mở rộng cũng như update phần mềm thì đó có thể là cực hình cho người sau.\r\n- Nếu bạn được quyền tham gia vào thiết kế database (thường là review và góp ý) thì hãy xem xét đến các vấn đề về việc những trường hợp phát sinh đề phòng những người tạo ra DB thiếu sót.\r\n\r\nLoại phân quyền thứ 3 có rất nhiều kiểu biến hóa trong từng phần mềm của từng công ty, Và mình sẽ cố gắng tìm hiểu thêm để viết một bài nói về kiểu này ngoài ra mình cũng sẽ cố gắng viết 1 bài nói về kiểu phân quyền của odoo. Thực chất nó cũng gần giống kiểu phân quyền trong group thôi :D.\r\nCảm ơn các bạn đã đọc bài viết của mình. Văn phong hơi lủng củng nên mong các bạn thông cảm!."
                }, {
                "id": "TgsclDi5aE2aQJgdYWcx8g",
                "title": "Zone trong Angluar và các thiết kế ở front-end framework",
                "content": "![zone in angular](https://i.imgur.com/po98H7T.png)\r\n\r\n# Chất vất bản thân\r\n\r\nKhi làm việc với `Angular`, bạn có bao giờ hỏi là =\u003e thế beep nào mà mình phải cần xài thằng `zone.js` để chạy một ứng dụng Angular? Why why why? Mịa nó chiếm space của ứng dụng bố mà chả hiểu **cần nó làm cái méo gì?** Có thấy `React` hoặc `Vue` có cần cái dependencies nào để chạy chung đâu hè. \r\n\r\nNói tới đây chắc fan của Vue và React sẽ nháo nhào chê bai Angular là: *đang mệt, Angular như shệt, qua học React hay Vue gì đê bác ưiiiii !!!!!*\r\n\r\n**Vậy `zone.js` là gì?** mà các kỹ sư thiên tài ở `Google` phải bắt buộc sử dụng đến cho library nài. Để trả lời câu hỏi trên chúng ta nên quay lại một chút về các khái niệm thiết kế cơ bản của Angular.\r\n\r\n# React, Angular và Vếu... nhầm Vue\r\n\r\nTại đây mình chỉ đề cập đến 3 frameworks này, vì mặc dù có nhiều framework khác làm những việc tương tự, mình không đề cập không phải là vì nó không tốt bằng 3 anh này, nhưng về độ phổ biến thì 3 anh này không ai bằng, chẳng khác nào bộ 3 huyền ảo `Zara`, `HM` và `Uniqlo`. Còn ánh xạ cho ai thì tùy bạn :D\r\n\r\nNhư chúng ta đỡ biết, `React` và `Vue` và nhiều framework khác sử dụng **virtual DOM** để detect, và sau khi **tính toán sự thay đổi**, cuối cùng là update lại **những thứ thật sự cần thay đổi** lên trên `ĐƠM thật`. Cơ bản là vậy đó, vì mấy cái zụ `ĐƠM ảo` này mình cũng không rành lắm, biết zậy thôi.\r\n\r\nNhưng Angular **lại không sử dụng thiết kế đó (VDOM)** để phát triển, mà bọn họ lại chọn **change detection** để làm cái việc detect, và render lại view.\r\n\r\n**Vậy tại sao họ lại lựa chọn thiết kế nài?** Xin trả lời là mình **đếu biết**. \r\n\r\nMình nghĩ chắc họ có lý do của họ, tìm hiểu nhiều tài liệu nhiều cuộc tranh luận mình cũng không thấy cái nào là rõ ràng và thật sự chính xác. Nhưng có lẽ nói như thế này là đúng nhất\r\n```\r\nIs chocolate ice cream better than vanilla ice cream?\r\n```\r\nMình cũng ếu biết kem nào ngon hơn luôn, mình ghét ăn kem, mình ăn bưởi hơn, vì nó tốt cho sức khỏe? Mình nghĩ ae coder cũng thích ăn bưởi hơn, chắc vậy? còn ai thích ăn kem thì tùy, thế giới giờ cũng thoáng. **Mà suy cho cùng thoái mái với cái gì thì mình cứ làm với đó thôi.**\r\n\r\nNhưng có 1 điều mình **chắc chắn** là chạy Angular **sẽ tốn memory** hơn là `React` và `Vue`, mà cũng đơn giản thôi vì nó là 1 framwork hoàn chỉnh từ render đến routing và làm được thêm nhều thứ khác mà không cần đến các 3rd party.\r\n\r\nMà vấn đề quản lý `memory` ở javascript thì framework nào cũng vậy, không nắm được rõ cái mình đang làm thì `best framework` cũng `out of memory` thôi. `Webpack` là 1 ví dụ, chạy `build build run run` một hồi lâu là out of memory liền.\r\n\r\nQuay lại vấn đề thiết kế, từ các thông tin trên chúng ta có thể **đúc kết lại như này:**\r\n\r\n- `React` và `Vue` đều dùng **`VDOM`**. **Lưu ý** dù đều dùng VDOM nhưng 2 fw này lại có cách implement khác nhau nhé. React là `setState` còn Vue là `Object.definedProperty`. Các bác có thể tự tìm hiểu thêm nhóe.\r\n- còn `Angular` thì sử dụng `Change Dectection` và `zone.js` (được implement thành `NgZone` trong Angular)\r\n\r\n\u003e https://angular.io/api/core/NgZone \u003cbr\u003e \r\n\u003e https://github.com/angular/zone.js/\r\n\r\n## Performance thì sao nhỉ?\r\nTheo như mình tìm hiểu thì bác [`IgorMinar`](https://github.com/IgorMinar) một trong core member của dự án `Angular` sau khi được hỏi là tại sao `Angular` không sử dụng `VDOM`?, cũng như tại sao lại chọn thiết kế như hiện tại thì trả lời đại loại như thế này.\r\n\r\n## Igor said\r\n**Um.... ơ hờm... thật khó để so sánh các thiết kế với nhau mấy pa ơi** vì nó giống như bạn ăn tô `bún bò` với tô `phở` vậy, bạn người Bắc có lẽ thích phở hơn, còn nếu bạn là người Trung (miền trung nhé, không phải tung của nhóe) chắc thích bụn bọ huệ hơn. Còn mình mình thích bún bò huệ hơn (kệ cmm -__- =\u003e nói tiếp đi anh Igor). Và với lại team chúng tôi vẫn cảm thấy thoải mái với thiết kế này cũng như vẫn thoái mái với hiệu suất thực thi (`runtime performance`) mà chúng tôi mong đợi và chúng tôi cũng đang có những cải tiến để tăng hiệu năng ứng dụng ở các phiên bản tiếp theo...bla bla, nên chọn dùng gì vẫn là **lựa chọn là ở các bạn**.\r\n\r\n\u003e Chỗ bún bò vs phở anh `IgorMinar` không cón nói nhé hehe.\r\n\r\nCác bạn có thể xem thêm cuộc tranh luận ở đây:\r\nhttps://github.com/angular/angular/issues/22587\r\n\r\n**Bảng so sánh hiệu năng**\r\n![Benchmarks](https://i.imgur.com/r5NU0ey.png)\r\n\r\nXem thêm: https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html\r\n\r\n## Tổng kết\r\n\r\nTừ bản so sánh hiệu năng ở trên thì ít nhiều chúng ta có thể thấy thì 3 anh này tốc độ cũng same same nhau thôi ah. Nên không thể nói thiết kế nào tốt hơn thiết kế nào cạ. Tùy sở thích mỗi người và dự án yêu cầu thì chơi thôi nhể.\r\n\r\n- React, Vue thì `VDOM`\r\n- Angular thì `change detection`\r\n\r\n# Vậy `Change Detection` trong Angular là gì? Và tại sao lại cần `zone.js`\r\n\r\nXét đoạn code dưới này nè:\r\n``` js\r\n// \u003cdiv id=\"content\"\u003e\u003c/div\u003e\r\nconst content = document.getElementById('#content');\r\nupdateText = function () {\r\n    input.innerHTML = text + \": \" + Date.now();\r\n}\r\nlet text = \"Hello\";\r\nupdateText();\r\n```\r\n\r\nSau khi chạy thì cái cái `div` kia sẽ có giá trị là: `Hello: 1526665390423`. Hàm `updateText` đã update lại text cho input đó. Ok nothing.\r\n\r\nThêm tiếp đoạn này nựa:\r\n``` js\r\nconst btn = document.getElementById('btn1');\r\nbtn.addEventListener('click', () =\u003e {\r\n    text = \"Aquanicap\";\r\n})\r\n```\r\n\r\nQuá rõ ràng là sau khi click button xong thì **chả có cái méo gì xảy ra cả**. Giỏ giàng quá rồi, object đúng là được cập nhật nhưng html của div **thì không biết điều đóa**. Đáng là phải như này mới đúng chớ.\r\n\r\n``` js\r\nconst btn = document.getElementById('btn1');\r\nbtn.addEventListener('click', () =\u003e {\r\n    text = \"Aquanicap\";\r\n    updateText();\r\n})\r\n```\r\n\r\n**Đúng !!** bạn đoán y chóc, hàm `updateText` đó chính là mô phỏng cho việc `change detection` trong `Angular`. Và tụi Mẽo gọi đó là `monkey patch` hay là `open heart surgery` gì đó.\r\n\r\nMọe kiếp khó nhớ kinh. Kiu mình search từ khóa `monkey patch` rồi đọc mớ giải thích chắc cũng méo hiểu nó nói gì và chắc lại nghĩ chết mẹ cái gì mà lại cao siêu vậy rồi lại hành hạ, chì chiết bản thân nựa ??? \r\n\r\nNhưng hông lẽ **Angular implement đơn giản như quại sao?** \r\n\r\nĐể trả lời câu hỏi này, chúng ta nên suy nghĩ một chút là **thật sự các sự thay đổi** ở view được thay đổi ở **những trường hợp** nào? Tổng kết nó chỉ nằm trong **3** trường hợp nài:\r\n\r\n1. **Events** - User events like click, change, input, submit,...\r\n2. **XMLHttpRequests/fetch** - E.g. when fetching data from a remote service\r\n3. **Timers** - setTimeout(), setInterval()...\r\n\r\nThẩm một chút chúng ta có thể nhận ra: **AH, đang mệt, tụi này nó có gì gì đó chung chung phải không ta?**, chết mẹ đúng rồi đó là **tụi nó toàn là `ASYNCCHRONOUS`** (móa phát hiện vĩ đại quá ha -__-)\r\n\r\nCó thể mổ phỏng lại trong `Angular` như nầy nè:\r\n``` js\r\nconst btn = document.getElementById('btn1');\r\nbtn.addEventListener('click', () =\u003e {\r\n    text = \"Aquanicap\";\r\n    runAngularsChangeDetection(); \r\n})\r\n```\r\n\r\n## Vậy làm cách nào Angular `detect` được khi nào `update lại data và view` trong 3 cái actions này?\r\n\r\nQuay lại một chút về thiết kế của Angular một chút để ứng với mỗi action Angular cung cấp các công cụ gì:\r\n\r\n1. **Events**: Angular support `(click)`, `(change)`, `(keyup)`...\r\n2. **XMLHttpRequests** : Chính là module `Http` và sau này là `HttpClient`\r\n3. **Timers**: Các hàm từ `rxjs`... cũng như `setTimeout interval` của native.\r\n\r\nThì như trên đa phần các action này đều được Angular wrap bởi khuôn khổ framework của mình, nghĩa là sự kiện `click` không chỉ còn mỗi việc là gọi lại cái `callback` của chúng ta rồi làm mỗi cái việc của chúng ta trong đó.\r\n\r\nMà bản chất là nó sẽ làm thêm những việc như gọi `change detection`, `updade view`, update `life cycle`... sau khi hàm `callback` của chúng ta run xong, nói chung là kiểu kiểu vậy. Người ta (tụi Mẽo) gọi đó là: đang mệt, `monkey patch` hay là `phẩu thuật tim hở` gì gì đó... -__-\r\n\r\n**\u003e\u003e\u003e Và để làm cái việc trời đánh này, Angular đã sử dụng thư viện và nó được gọi là `zone.js`**\r\n\r\n# Vậy `zone.js` là cái méo gì?\r\n\r\nHomepage: https://github.com/angular/zone.js/\r\n\r\n**A Zone is an execution context that persists across async tasks. You can think of it as thread-local storage for JavaScript VMs.**\r\n\r\nHiểu nôm na nó sẽ tạo ra một vùng context để thực hiện các thao tác bất đồng bộ (async). Nghĩa là bây giờ các thao tác async sẽ được **chạy trên một vùng** mà chúng ta có thể **quản lý, sờ nắn và tác động được**.\r\n\r\nVí dụ một đoạn code sau:\r\n```js\r\nfunction bar() {\r\n    console.log('bar')\r\n}\r\nfunction foo() {\r\n    console.log('foo')\r\n}\r\nfunction baz() {\r\n    console.log('baz')\r\n}\r\n```\r\n\r\n```js\r\nvar start,\r\n    time = 0;\r\n    timer = Date.now;\r\n\r\nstart = timer();\r\nfoo();\r\nbar();\r\nbaz();\r\ntime = timer() - start;\r\n\r\n// log time in ms\r\nconsole.log(Math.floor(time*100) / 100 + 'ms');\r\n```\r\n\r\nSau khi chạy thì chúng ta có thể detect được thời gian mà 3 functions thực thi. Nhưng rõ ràng là không có gì đặc biệt hết, bây giờ chúng ta xét đoạn code khác dưới này, chúng ta update lại `function baz` với `setTimeout()`: \r\n```js\r\nfunction bar() ...\r\nfunction foo() ...\r\n// Update lại function baz với timeout\r\nfunction baz() {\r\n    setTimeout(() =\u003e {\r\n        console.log('baz')\r\n    }, 1000)\r\n}\r\n```\r\nChạy lại đoạn code đo thời gian thực thi bên trên, nó sẽ tốn hơn một xíu thời gian so với đoạn code `sync` ở trên, nhưng rõ ràng là thời gian thực thi này không thể hiện đúng những gì chúng ta đang chạy vì hàm `setTimeout()` sẽ là một `tác vụ không đồng bộ` được trình duyệt thêm vào **event queue** sau đó cuối cùng sẽ được **event loop** xử lý khi hết thời gian chờ `1000 ms`.\r\n\r\n**Vậy làm cách nào để giải quyết vấn đề với các tác vụ bất đồng bộ?** Do đó cái chúng ta cần là làm một cách nào đó `hook` để **cho phép chúng ta biết khi nào** mà một tác vụ không bộ **xảy ra.** \r\n\r\nSuy nghĩ đơn giản một chút là chúng ta sẽ thêm thủ công các hàm đo đếm trong từng hàm `async`, **nhưng ai mà đi làm vậy?** thật là lộn xộn, cứ phải thêm trong mỗi cuối hàm `async`.\r\n\r\n\u003cstrong style=\"color:red\" \u003eĐÂY CHÍNH LÀ NƠI MÀ ZONE RA ĐỜI ĐỂ GIẢI QUYẾT\u003c/strong\u003e. \r\n\r\nXem đoạn code dưới đây, nhưng bạn có thể tham khảo thêm tài liệu của [Zone API homepage](https://github.com/angular/zone.js/blob/master/dist/zone.js.d.ts) để biết thêm chi tiết. Mình sẽ không đề cập chi tiết ở đây. \r\n```js\r\nfunction bar() { console.log('bar') };\r\nfunction foo() { console.log('foo') };\r\nfunction baz() {\r\n    setTimeout(() =\u003e {\r\n        console.log('baz')\r\n    }, 1000)\r\n}\r\nfunction bazz() {\r\n    setTimeout(() =\u003e {\r\n        console.log('bazz')\r\n    }, 1000)\r\n}\r\n\r\n// Wrap các hàm lại nằm trong hàm main\r\nfunction main() {\r\n    bar();\r\n    foo();\r\n    baz();\r\n    bazz();\r\n}\r\n\r\nconst rootZone = Zone.current;\r\nconst zoneA = rootZone.fork({\r\n    name: 'zoneA',\r\n    onInvokeTask: function (parentZoneDelegate, currentZone, targetZone, task) {\r\n        console.log('Run async') // Run trước khi hàm được gọi\r\n        task.callback(); // Original method đc gọi ở đây\r\n        //... run sau khi hàm được gọi\r\n    }\r\n})\r\n\r\nzoneA.run(main);\r\n```\r\nKết quả sau khi chạy các hàm trong `Zone`:\r\n\r\n![Zonejs](https://i.imgur.com/61ZrE3G.png)\r\n\r\nChắc qua ví dụ trên chúng ta ít nhiều hiểu sơ sơ thằng zone làm cái gì rồi phải hôn? Đại loại các `async methods` sẽ được thằng `Zone` ôm lại hết vào lòng để quản lý và sau đóa cung cấp cho chúng ta các methods để **làm cái gì đó chúng ta muốn ahihi** trước sau những async method đó. Các bác thể gọi là thằng zone là **Zone tú bà**.\r\n\r\n## Zone hữu dụng khi nào và `why` lại dùng nó?\r\n\r\n1. Zones are useful for debugging, testing, profiling.\r\n2. Zones are useful for frameworks to know when to render.\r\n3. Zones are useful for tracking resources which persist across async operations and can automatically release/cleanup the resources. \r\n4. Zones are composable\r\n\r\nSau khi google dịch 4 cái câu trên, em rút ra được một điểm chung đó là...... 4 cầu này đều là thì hiện tại đơn thì phải, và cái quan trọng nhất khi được google dịch dùm câu này\u003cbr\u003e\r\n`Zones are useful for frameworks to know when to render.` =\u003e \u003cbr\u003e\r\n`Các khu vực rất hữu ích cho các khung công tác để biết thời điểm hiển thị.` -__- dù hơi hơi là khó hiểu một chút nhưng... **đúng gòi, chính xác**, đây chính là cái `Angular` cần và cũng đang sử dụng cho thiết kế của mình. Nó giúp framework biết khi nào `async funtions` thực thi xong để gọi các hàm `re-render` view cũng như gọi các hàm trong `life cycle` của bản thăn nó.\r\n\r\n**=\u003e Angular đang xài combo `Change Detection` + `Zone.js`** \r\n\r\n# Cuối cùng Zone.js hoạt động trong Angular như thế nào?\r\n\r\nSau những hà hồ sa số giải thích ở trên thì các bạn cũng nhận ra là `Angular` đang sử dụng `Zone.js` để hỗ trợ cho việc update lại state của application và render lại view của ứng dụng. \r\n\r\nThì trong một ứng dụng Angular, Angular sẽ tạo ra một vùng zone được fork từ rootZone (thường là zone của window ở browser) và sẽ tự thân quản lý nó có thể được gọi là `AngularZone`. Thì những `actions, events...` mà hoạt động dưới **các thao tác bất đồng bộ** sẽ được Angular quản lý và xử lý các thay đổi này. Từ đó update lại tầng view cho ứng dụng.\r\n\r\nAngular không sử dụng library `zone.js` native mà sẽ wrap nó trên một class gọi là **`NgZone`**, thì nó sẽ cung cấp các `state` để chúng tracking, cũng như là chúng ta cũng có thể chạy **bất cứ một hàm nào nằm ngoài vùng kiểm soát** của `Angular Zone`.\r\n\r\nChẳng hạn như là khi chúng ta sử dụng chức năng `scroll` trong browser chẳng hạn, `scroll` sinh ra và call liên tục các sự kiện, rõ ràng nó sẽ khiến vấn đề performance có trục trặc. Nhưng mà nó lại là một vấn đề khác nữa và nếu cơ hội mình sẽ làm một khác về vấn đề performance của `Angular`. Bài viết cũng khá là dài dài rồi nên chắc mình phải kết thúc tại đây thôy.\r\n\r\nChi tiết class NgZone của Angular:\u003cbr\u003e\r\nhttps://angular.io/api/core/NgZone\r\n\r\n```ts\r\nclass NgZone {\r\n  static isInAngularZone(): boolean\r\n  static assertInAngularZone(): void\r\n  static assertNotInAngularZone(): void\r\n  constructor(__0)\r\n  get hasPendingMicrotasks: boolean\r\n  get hasPendingMacrotasks: boolean\r\n  get isStable: boolean\r\n  get onUnstable: EventEmitter\u003cany\u003e\r\n  get onMicrotaskEmpty: EventEmitter\u003cany\u003e\r\n  get onStable: EventEmitter\u003cany\u003e\r\n  get onError: EventEmitter\u003cany\u003e\r\n  run\u003cT\u003e(fn: (...args: any[]) =\u003e T, applyThis?: any, applyArgs?: any[]): T\r\n  runTask\u003cT\u003e(fn: (...args: any[]) =\u003e T, applyThis?: any, applyArgs?: any[], name?: string): T\r\n  runGuarded\u003cT\u003e(fn: (...args: any[]) =\u003e T, applyThis?: any, applyArgs?: any[]): T\r\n  runOutsideAngular\u003cT\u003e(fn: (...args: any[]) =\u003e T): T\r\n}\r\n```\r\n\r\n# Túm lại cái váy bài này đê\r\n\r\nSau bài này mình rút ra được vài điều như này mà mình thấy:\r\n\r\n1. React, Vue xài `VDOM`, Angular xài `change detection`.\r\n2. Hiệu suất 3 frameworks là khá tương đồng nhau, không thể nói thiết kế nào tốt hơn thiết kế nào.\r\n3. Sử dụng framework là do sở thích và là cái diên.\r\n4. Tất cả các hoạt động thay đổi đều thuộc về các thao tác bất đồng bộ.\r\n5. Angular sử dụng `zone.js` để hỗ trợ việc `change detection`.\r\n\r\nThanks các bác đã đọc đến tận đây nhóe !!!\r\n\r\n# Tham khảo\r\n\r\n1. https://blog.thoughtram.io/angular/2016/01/22/understanding-zones.html\r\n2. https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html\r\n3. https://github.com/angular/zone.js/\r\n4. https://github.com/angular/angular/issues/22587\r\n\r\nBài viết gốc được đăng ở blog của mình:\r\nhttps://www.jinhduong.com/post/zone-in-angular/\r\n"
                }, {
                "id": "CnzyYfdPlGYEHHnwCSKMZg",
                "title": "Một số câu hỏi phỏng vấn JavaScript hay và khó 1 - Chắc ai đó sẽ cần !",
                "content": "Xin chào bạn! \n\nCó thể bạn đã biết, JavaScript là một ngôn ngữ lập trình rất mạnh, nhưng lại vô cùng rắc rối, phức tạp. Để có thể nắm vững được JavaScript, bạn sẽ cần phải mất một thời gian khá dài để học và thực hành nó. \n\nVà một trong số những cách thực hành hiệu quả nhất, đó là trả lời các câu hỏi, giải đố, quiz. Thông qua việc trả lời mỗi câu hỏi, bạn sẽ tự kiểm tra lại kiến thức của bản thân, đồng thời học hỏi thêm nhiều kiến thức mới.\n\nBài viết này mình sẽ chia sẻ với bạn một số câu hỏi phỏng vấn JavaScript rất hay. Mời bạn theo dõi!\n\n## Câu 1\n\n```js\nconst x = [1, 2, 3];\nx[-1] = -1;\nconsole.log(x[x.indexOf(10000)]);\n```\n\nHỏi console in ra kết quả như thế nào?\n\n## Câu 2\n\n```js\n//let i = ?\n \nconsole.log(i * i); // =\u003e 0\nconsole.log(i + 1); // =\u003e 1\nconsole.log(i - 1); // =\u003e -1\nconsole.log(i / i); // =\u003e 1\n```\n\nTìm số i thỏa mãn đồng thời 4 câu lệnh trên?\n\n## Câu 3\n\n```js\nlet a = [1, 2, 3] + [4, 5, 6];\nconsole.log(a);\n```\n\nHỏi console in ra kết quả như thế nào?\n\n## Câu 4\n\n```js\n(function() {\n  let x = 100;\n})();\n \nconsole.log(x);\n```\n\nHỏi console in ra kết quả như thế nào?\n\n## Đáp án và giải thích\n\nĐể tránh tình trạng bạn chưa suy nghĩ kĩ mà đã xem lời giải, mình sẽ không để đáp án và giải thích tại đây. \n\nThay vào đó, mời bạn xem đáp án và giải thích chi tiết tại [Xoắn não với phỏng vấn JavaScript 1](https://completejavascript.com/xoan-nao-voi-phong-van-javascript-1/).\n\nXin chào và hẹn gặp lại!\n\n---\nTheo dõi [Lam Pham](https://completejavascript.com/gioi-thieu/) trên [Kipalog](https://kipalog.com/users/Lam%20Pham/mypage) để nhận thông báo khi có bài viết mới nhất:\n\n  * **Facebook Fanpage:** [Complete JavaScript](https://www.facebook.com/completejavascript/)\n  * **Facebook Group:** [Hỏi đáp JavaScript VN](https://www.facebook.com/groups/HoiDapJavascriptVN)\n  * **Portfoflio** : [Lam Pham](http://about.phamvanlam.com)"
                }, {
                "id": "oj5IltosQPlnlcJJdF-2XA",
                "title": "Functional Programming - Phần 2 - Nhập đạo",
                "content": "Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta:\r\n\r\n- sử dụng functions để điều khiển workflow\r\n- tuân thủ 2 nguyên tắc immutability và purity\r\n\r\nNói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến.\r\n\r\nNhưng làm thế nào để cảm ngộ \"phân sần ý cảnh\"? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn.\r\n\r\n\r\n### Higher-order function\r\n\r\nHigher-order function là một khái niệm đến từ Toán học. Bất cứ hàm nào tiếp nhận 1 function như tham số, hoặc trả về 1 function như kết quả, thì đều được coi là higher-order function.\r\n\r\nDưới đây là 1 ví dụ, hàm  `getItem` nhận vào hàm `by` mô tả điều kiện, lại trả về 1 hàm khác. Nó thừa tiêu chuẩn để gọi là higher-order function.\r\n\r\n```\r\nconst getItem = by =\u003e arr =\u003e by;\r\n\r\n// hoặc phiên bản chi tiết\r\nconst getItem = (by) =\u003e {\r\n  return (arr) =\u003e {\r\n\treturn by(arr);\r\n  };\r\n};\r\n```\r\n\r\nLập trình phong cách Functional Programming là khiêu vũ với các functions. \r\n\r\nTrong Functional Programming, hầu như mọi functions đều là higher-order function, vì chúng đều có thể nhận vào và ném ra các functions. \r\n\r\nNhưng như vậy thì có lợi ích gì? Nó đơn giản cung cấp cho ta một cách khác để lập luận và suy diễn. Chẳng hạn như với hàm `getItem` trên kia cho phép bạn biến hóa rất nhiều dạng, tùy vào cách bạn thao túng `by`.\r\n\r\nKhi bạn viết `getItem`, bạn không cần biết sau này sẽ phải kiểm tra điều kiện ra sao, cũng không quan tâm sẽ nhận được đầu vào như thế nào.  \r\n\r\nBạn có thể tạo ra hàm tìm số lớn nhất trong 1 mảng toàn số như sau:\r\n\r\n```\r\n// tạo hàm engine lấy max number từ mảng\r\nconst maxNumber = (arr) =\u003e {\r\n  return Math.max(...arr);\r\n};\r\n\r\n// rồi truyền vào getItem để được hàm cần thiết\r\nconst getMaxNumber = getItem(maxNumber);\r\n\r\n// thử xem sao\r\ngetMaxNumber([4, 6, 2, 3, 1, 8, 7, 5]);\r\n// =\u003e 8\r\n```\r\n\r\nThế sao không truyền thẳng cái mảng số kia vào `maxNumber` cho khỏe? Vì trong thiết kế này ta đang cư xử với `maxNumber` như plugin. Còn nhiều plugins khác nữa. Ta không gọi trực tiếp plugin mà gọi qua 1 giao diện tổng quát hơn.\r\n\r\nGiờ ta lại có dữ liệu 1 nhóm người như sau:\r\n\r\n```\r\nconst members = [\r\n  {\r\n\tname: 'Alice',\r\n\theight: 165,\r\n  },\r\n  {\r\n\tname: 'Bob',\r\n\theight: 152,\r\n  },\r\n  {\r\n\tname: 'Celina',\r\n\theight: 178,\r\n  },\r\n  {\r\n\tname: 'Dan',\r\n\theight: 194,\r\n  },\r\n  {\r\n\tname: 'Eric',\r\n\theight: 187,\r\n  },\r\n];\r\n```\r\n\r\nTa muốn tìm người cao nhất trong nhóm thì sao? Hãy thêm 1 plugin khác.\r\n\r\n```\r\n// bạn tạo 1 hàm engine lấy max height từ mảng\r\nconst maxHeight = (people) =\u003e {\r\n  return people.reduce((prev, current) =\u003e {\r\n    return prev.height \u003e current.height ? prev : current;\r\n  });\r\n};\r\n\r\n// rồi truyền vào getItem để được hàm cần thiết\r\nconst getTallestPerson = getItem(maxHeight);\r\n\r\n// thử xem sao\r\ngetTallestPerson(members);\r\n// =\u003e { name: 'Dan', height: 194 }\r\n```\r\n\r\nVí dụ trên tuy tầm thường, nhưng có thể là gợi ý tốt để bạn dùng higher-order function thiết kế những chương trình linh hoạt, dễ mở rộng.\r\n\r\n\r\n\r\n### Function Composition\r\n\r\nĐây là [khái niệm Toán học](https://www.mathsisfun.com/sets/functions-composition.html) mà tiếng Việt ta gọi là \"hàm hợp\", hay \"hàm phức hợp\". Mọi thứ trong Functional Programming đều có nguồn gốc Toán học.\r\n\r\nFunction Composition là sự phối hợp, liên kết nhiều hàm lại với nhau, thành một hàm lớn, nhiều chức năng hơn. \r\n\r\nCó 2 kỹ thuật căn bản trong Function Composition là `compose` và `pipe`.\r\n\r\n#### Compose\r\n\r\nHãy nhớ lại, trong không gian Functional Programming tồn tại vô số pure functions nhỏ gọn, đơn giản. Đúng triết lý \"do one thing and do it well\" của UNIX.\r\n\r\nVì mỗi hàm chỉ làm 1 việc, khi muốn thực hiện nhiều hành động lên cùng một input, ta chỉ việc kết hợp các hàm cần thiết lại với nhau.\r\n\r\nBây giờ chúng ta hãy tạm ngừng tu luyện, tạm quên tu vi để nhập phàm, quan sát và cảm ngộ nhân sinh. \r\n\r\nLần này, bạn hóa thành con trai thứ 4 trong gia đình một thôn dân sinh sống dưới  chân núi Tản Viên bằng nghề bán thịt...\r\n\r\nMột hôm bạn xin được khúc cây lớn ở chỗ ông chú làm kiểm lâm kiêm lâm tặc. \r\n\r\n![enter image description here](https://i.imgur.com/OQofkz2.jpg)\r\n\r\nTừ khúc gỗ này, bạn muốn làm ra cái thớt cho nhà dùng. \r\n\r\nLà tu sĩ mới nhập môn tu luyện Functional Programming, tuy không có tu vi, nhưng bạn vẫn hình dung được sẽ cần đến các pure functions sau:\r\n\r\n- `cưa()`: nhận vào khúc gỗ, trả về từng khoanh tròn\r\n- `sấy()`: nhận khoanh gỗ tươi, trả về khoanh gỗ khô\r\n- `bào()`: nhận vào khoanh gỗ, trả về khoanh gỗ bằng phẳng\r\n- `khoan()`: nhận vào khoanh gỗ, trả về khoanh gỗ có 2 lỗ (để gắn quai treo/móc lên cho gọn)\r\n- `chà()`: nhận vào khoanh gỗ, trả về khoanh gỗ trơn láng (dùng giấy nhám, miền ngoài gọi giấy giáp, để đánh cho nhẵn bề mặt)\r\n- `móc()`: nhận thớt không quai, trả về thớt có quai\r\n\r\nMỗi hàm chỉ làm đúng 1 việc. Không hơn. Không kém. Khi đi qua chừng đó công đoạn, ta sẽ được sản phẩm mong muốn. \r\n\r\n![enter image description here](https://i.imgur.com/qKYfPYA.jpg)\r\n\r\nDĩ nhiên chúng ta đang muốn khúc gỗ được sửa đổi nên tạm bỏ qua vấn đề immutability.\r\n\r\nĐây là phiên bản mô phỏng:\r\n\r\n```\r\nconst cưa = (x) =\u003e {\r\n  return `${x} đã cưa`;\r\n};\r\n\r\nconst sấy = (x) =\u003e {\r\n  return `${x} đã sấy`;\r\n};\r\n\r\nconst bào = (x) =\u003e {\r\n  return `${x} đã bào`;\r\n};\r\n\r\nconst khoan = (x) =\u003e {\r\n  return `${x} đã khoan`;\r\n};\r\n\r\nconst chà = (x) =\u003e {\r\n  return `${x} đã chà`;\r\n};\r\n\r\nconst móc = (x) =\u003e {\r\n  return `${x} đã gắn móc`;\r\n};\r\n```\r\n\r\nĐể tạo ra 1 cái thớt, ở thời viễn cổ xa xưa, các man sĩ thường code thế này:\r\n\r\n```\r\nvar thớt = cưa('khúc gỗ');\r\nthớt = sấy(thớt);\r\nthớt = bào(thớt);\r\nthớt = khoan(thớt);\r\nthớt = chà(thớt);\r\nthớt = móc(thớt);\r\n\r\nconsole.log(thớt);\r\n// =\u003e khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc\r\n```\r\n\r\n![](https://i.imgur.com/nBLW7ye.jpg)\r\n\r\n5 vạn năm sau, khi đã xuất hiện Toán học, các tộc nhân bộ lạc Giao Chỉ thời đại Hồng Bàng lại thích code như thế này:\r\n\r\n```\r\nvar thớt = móc(chà(khoan(bào(sấy(cưa('khúc gỗ'))))));\r\nconsole.log(thớt);\r\n// =\u003e khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc\r\n```\r\n\r\nĐây chính là Toán học cơ bản. Với `y = f(g(x))`, ta tính `g(x)` trước, được bao nhiêu truyền vào  `f()`  là ra kết quả. Việc tính toán đi từ ngoặc trong cùng ra ngoài, mắt thường nhìn thấy là từ phải sang trái, từ `g` đến `f`.\r\n\r\nLại thêm 5 ngàn năm nữa trôi qua. Lúc này đã có ES6. Một số cường giả Functional Programming sáng tạo ra phương thức `compose`, như thế này:\r\n\r\n```\r\nconst compose = (...fns) =\u003e {\r\n  return fns.reduce((f, g) =\u003e (x) =\u003e f(g(x)));\r\n};\r\n```\r\n\r\nBạn có thể dùng [Babel](https://babeljs.io/repl) dịch sang ES2015 cho dễ hiểu.\r\n\r\nÝ tưởng của `compose`  là xếp cuốn chiếu các hàm lại với nhau, theo thứ tự từ trái sang phải để tạo ra một hàm mới, mà khi được thực thi, nó sẽ lần lượt gọi các hàm đã truyền vào trước đó theo thứ tự ngược lại, từ phải sang trái. \r\n\r\nTức là nếu `y = compose(f, g)`, thì `y(x) = f(g(x))`; \r\nNó sẽ tính `g(x)` trước rồi truyền kết quả cho `f`;\r\nGiả sử `g(x) = z` thì `y(x) = f(z)`;\r\n\r\nNếu bạn vẫn thấy mơ hồ thì cứ xem cái này là Đạo. Chỉ có thể cảm ngộ, không thể giảng được bằng lời!\r\n\r\nTrở lại với cái thớt. Hàm `compose` tất nhiên là higher-order function. Ta sẽ thử xem nó làm việc ra sao:\r\n\r\n```\r\nconst quăng_cho_tao_cái_thớt = compose(móc, chà, khoan, bào, sấy, cưa);\r\nconsole.log(quăng_cho_tao_cái_thớt.toString());\r\n// =\u003e bạn đoán xem log ra thứ gì?\r\n```\r\n\r\nBây giờ ta có 1 hàm, gọi là `quăng_cho_tao_cái_thớt()`, kết quả của sự lắp ghép bằng `compose` tất cả các pure functions ở trên. \r\n\r\nTa biết `compose` sẽ gọi từ phải sang trái, nên công đoạn nào làm trước thì để bên phải.\r\n\r\nChạy thử 1 phát:\r\n\r\n```\r\nconst thớt = quăng_cho_tao_cái_thớt('khúc gỗ');\r\nconsole.log(thớt); \r\n// =\u003e khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc\r\n```\r\n\r\nVậy là đủ công đoạn, khúc gỗ đã trở thành một cái thớt tốt. \r\n\r\nNhưng chưa hết. Khi bạn treo cái thớt đó ở nhà, nhiều người quen đến chơi thấy đẹp hỏi mua. Nhiều đến mức bạn quyết định kinh doanh thớt.\r\n\r\nLàm thớt kinh doanh thì phải gán nhãn, vậy là bạn tạo ra một pure function mới và dùng `compose` để làm khuôn sản suất loại thớt commercial này. \r\n\r\nDễ ợt, không ảnh hưởng gì đến loại thớt cho nhà dùng.\r\n\r\n```\r\nconst nhãn = (x) =\u003e {\r\n  return `${x} đã dán nhãn`;\r\n};\r\n\r\nconst làm_thớt_để_bán = compose(nhãn, móc, chà, khoan, bào, sấy, cưa);\r\n```\r\n\r\nHoặc tận dụng lại khuôn mẫu cũ:\r\n\r\n```\r\nconst làm_thớt_để_bán = compose(nhãn, quăng_cho_tao_cái_thớt);\r\n```\r\n\r\nThử xem sao:\r\n\r\n```\r\nconst thớt_bán = làm_thớt_để_bán('khúc gỗ');\r\nconsole.log(thớt_bán);\r\n// =\u003e khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã móc đã dán nhãn\r\n```\r\n\r\nĐể mở rộng thị phần, hướng đến phân khúc giá rẻ, bạn tạo ra dòng sản phẩm thớt tầm trung, dùng chip MediaTek, bỏ qua bước sấy khô và đánh bóng để giảm giá thành. Rất đơn giản:\r\n\r\n```\r\nconst làm_thớt_loại_hai = compose(nhãn, móc, khoan, bào, cưa);\r\n```\r\n\r\nThử xem sao:\r\n\r\n```\r\nconst thớt_loại_hai = làm_thớt_loại_hai('khúc gỗ');\r\nconsole.log(thớt_loại_hai);\r\n// =\u003e khúc gỗ đã cưa đã bào đã khoan đã móc đã dán nhãn\r\n```\r\n\r\nLập trình như vậy phải nói là vô cùng tao nhã, lịch thiệp! Đôi khi tôi cảm thấy phong cách lập trình Functional Programming có sự thanh tịnh đầy chất quý tộc, vừa bình dân lại vừa hàn lâm, đẹp đến mức khó hiểu!\r\n\r\nNếu dùng OOP, có thể chúng ta còn đang loay hoay giữa một đống class Máy Cưa, Máy Bào, Máy Khoan... Hoặc 1 class Máy Làm Thớt khổng lồ có đủ methods cưa, bào, khoan... Rồi còn một mớ properties mà ta phải cân nhắc xem cái nào public, cái nào private. Rồi phải tạo instance, thừa kế qua lại mấy vòng may ra mới làm được cái thớt. Muốn thêm dòng sản phẩm lại càng khó khăn. Phải tạo class `Thớt_nhà_dùng`, extend ra `Thớt_để_bán`, `Thớt_để_bán_loại_2`, phiền phức không sao kể xiết!\r\n\r\nFunctional Programming thì chỉ cần mấy hàm đơn giản, rời rạc, dùng `compose` lắp ráp lại như lắp ráp dây chuyền công nghệ là chế được các kiểu thớt.\r\n\r\nFunction Composition tựa như một nhà máy hiện đại, mỗi chi tiết linh kiện được xử lý bằng một robot chuyên trách, kết hợp lại với nhau một cách khoa học để tạo ra sản phẩm hoàn thiện.\r\n\r\n\r\n#### Pipe\r\n\r\nMột biến thể của `compose` là `pipe`, vận hành theo chiều ngược lại. Ta có thể implement bằng cách đảo vị trí `f` và `g` thế này:\r\n\r\n```\r\nconst pipe = (...fns) =\u003e {\r\n  return fns.reduce((f, g) =\u003e (x) =\u003e g(f(x)));\r\n};\r\n```\r\n\r\nHoặc giữ nguyên code của `compose` nhưng thay `reduce` bằng `reduceRight`:\r\n\r\n```\r\nconst pipe = (...fns) =\u003e {\r\n  return fns.reduceRight((f, g) =\u003e (x) =\u003e f(g(x)));\r\n};\r\n```\r\n\r\nVì `pipe` tổ hợp các hàm theo chiều ngược lại so với `compose` nên ta viết:\r\n\r\n```\r\nconst làm_thớt_dỏm = pipe(cưa, bào, nhãn);\r\n```\r\n\r\nThử xem sao:\r\n\r\n```\r\nconst thớt_dỏm = làm_thớt_dỏm('khúc gỗ');\r\nconsole.log(thớt_dỏm);\r\n// =\u003e khúc gỗ đã cưa đã bào đã dán nhãn\r\n```\r\n\r\nDùng `pipe` có vẻ thuận mắt hơn. Thứ tự các bước cưa, bào... trông khá tự nhiên. Nếu bạn quen với cách suy luận Toán học thì bạn sẽ thích `compose`. Còn nếu bạn muốn trực quan dễ hiểu thì cứ dùng `pipe`.\r\n\r\n`compose` và `pipe` là những thuật pháp nhập môn dễ học, dễ dùng, nhưng không kém uy lực, thư viện Functional Programming nào cũng có. Trong Ramda.js, ngoài [compose](http://ramdajs.com/docs/#compose) và [pipe](http://ramdajs.com/docs/#pipe), các tác giả còn bổ sung thêm `pipeK`, `pipeP`, `composeK`, `composeP`.\r\n\r\nKhi đã thông thạo, bạn hoàn toàn có thể tạo ra `compose` theo cách của bạn. Ví dụ `composeBinary` liên kết các hàm từ giữa sang 2 bên thay vì từ đầu này đến đầu kia, `composeRandom` liên kết các hàm không theo trật tự cố định...  Đó là không gian sáng tạo thuộc về riêng bạn.\r\n\r\n\r\n### Currying function\r\n\r\nThuật ngữ `currying` và các dạng  `curry`,  `curried` của nó trong khoa học máy tính được [Christopher Strachey](https://en.wikipedia.org/wiki/Christopher_Strachey) đặt ra từ năm 1967 để ghi nhớ công lao của [Haskell Brooks Curry](https://en.wikipedia.org/wiki/Haskell_Curry), một nhà Toán học và Luận lý học người Mỹ.\r\n\r\nCurrying function là làm cho 1 function trở thành \"curried function\". \r\n\r\nCái function ban đầu đó hơi ngốc nghếch, nó cần bạn truyền vào N tham số để tính toán, mà nếu thiếu 1 tham số, nó sẽ không chạy.\r\n\r\nVí dụ hàm `sum` thế này:\r\n\r\n```\r\nconst sum = (a, b, c) =\u003e {\r\n  return a + b + c;\r\n};\r\n```\r\n\r\n`sum` cần 3 tham số để cộng dồn lại, nếu thiếu, sẽ không tính toán ra được.\r\n\r\n```\r\n// có thể ra sân\r\nsum(5, 3, 2); // =\u003e 10\r\nsum(4, 4, 2); // =\u003e 10\r\nsum(4, 3, 3); // =\u003e 10\r\nsum(3, 5, 2); // =\u003e 10\r\n\r\n// nhưng\r\nsum(4, 5); // =\u003e NaN\r\n```\r\n\r\nĐây là thiếu tiền đạo cả đội không chịu ra sân tập! Nhưng cuộc sống đâu phải lúc nào cũng thuận lợi, đầy đủ cho chúng ta? Dù cả mấy tiền đạo đều bị chấn thương, treo giò, trốn tập thì các anh còn lại vẫn phải có trách nhiệm ra sân chứ!\r\n\r\nCurrying chính là kỹ thuật biến hàm `sum` ngốc đó trở thành một function vi diệu hơn, nếu bạn gọi nó với 1 tham số, nó sẽ trả về 1 hàm tạm thời, giữ lại tham số đó, chờ khi nào đủ 3 tham số thì mới thực hiện tính toán.\r\n\r\nHình dung bạn tổ chức một buổi party, mời 3 người bạn tham gia. Lúc này đã có mặt 2 người, còn 1 người đến muộn. Bạn quyết định không cần chờ nữa. Bữa tiệc cứ bắt đầu đã, chừng nào người kia đến thì tính tiếp.\r\n\r\nĐây là 1 cách implement cho hàm `curry`:\r\n\r\n```\r\nconst curry = (fn) =\u003e {\r\n  let totalArguments = fn.length;\r\n  let next = (argumentLength, rest) =\u003e {\r\n    if (argumentLength \u003e 0) {\r\n      return (...args) =\u003e {\r\n        return next(\r\n          argumentLength - args.length,\r\n          [\r\n            ...rest,\r\n            ...args,\r\n          ]\r\n        );\r\n      };\r\n    }\r\n    return fn(...rest);\r\n  };\r\n  return next(totalArguments, []);\r\n};\r\n```\r\n\r\nVà `curry` tất nhiên cũng là higher-order function. \r\n\r\nThử dùng với `sum` xem sao:\r\n\r\n```\r\nconst curriedSum = curry(sum);\r\n```\r\n\r\n`curriedSum` bây giờ là phiên bản curried của hàm `sum` trước đó.\r\n\r\n```\r\ncurriedSum(4, 4, 2); // =\u003e 10\r\ncurriedSum(4, 3, 3); // =\u003e 10\r\ncurriedSum(3, 5, 2); // =\u003e 10\r\n\r\n// và\r\ncurriedSum(5, 3); // =\u003e [Function]\r\n```\r\n\r\n`curriedSum(5, 3)` là 1 function. Nó đang chờ đợi tham số cuối cùng xuất hiện. Nếu bây giờ ta gọi nó với 1 tham số thì kết quả sẽ được tính toán ra:\r\n\r\n```\r\ncurriedSum(5, 3)(2); // =\u003e 10\r\n```\r\n\r\nNếu ta truyền nhiều hơn số lượng tham số còn thiếu thì sao? Ở đây là 1 tham số cuối cùng. Theo cách implement trên thì nó sẽ bỏ qua các tham số dư thừa. Các phiên bản  `curry` của [Ramda.js](http://ramdajs.com/docs/#curry) và [Lodash FP](https://lodash.com/docs/4.17.10#curry) cũng hành xử như vậy.\r\n\r\n```\r\ncurriedSum(5, 3)(2, 4, 8); // =\u003e 10\r\n```\r\n\r\nMột điểm quan trọng nữa là ta có thể phân tách hàm gốc ra từ 1 đến N phần, với N là số lượng tham số của hàm gốc đó. Chẳng hạn, nếu hàm gốc có 3 tham số, ta có thể chia nó ra 1, 2 hoặc 3 phần. Những cách viết sau là tương đương:\r\n\r\n```\r\ncurriedSum(3, 5, 2);\r\ncurriedSum(3, 5)(2);\r\ncurriedSum(3)(5, 2);\r\ncurriedSum(3)(5)(2);\r\n```\r\n\r\n`curry`, cũng như `compose` và `pipe` là những kỹ thuật căn bản, ai cũng phải học, phải biết. Mọi ngôn ngữ được thiết kế với tư tưởng Functional Programming như Haskell, Scalla, Elm... đều có sẵn các hàm này. Chúng rất tinh tế và được dùng ở khắp nơi. \r\n\r\nChỉ cần thành thạo 3 pháp quyết này thì bạn đã được xem như đệ tử Functional Programming chân chính.\r\n\r\n\r\n#`\r\nPhần 2 của chuyên đề Functional Progamming xin dừng ở đây. Thanks for reading.\r\n\r\nTrên Kipalog cũng có nhiều bài đề cập những khái niệm trên. Các bạn có thể tìm đọc thêm.\r\n`\r\n - [Xem phần 1: Con đường sáng](https://kipalog.com/posts/Functional-Programming---Phan-1---Con-duong-sang)\r\n - [Xem phần 3: Buông bỏ](https://kipalog.com/posts/Functional-Programming---Phan-3---Buong-bo)"
                }, {
                "id": "mKO7SZFihF2zf3q2sDYQxA",
                "title": "Functional Programming - Phần 1 - Con đường sáng",
                "content": "\nLúc bấy giờ, Tin giới Tây phương xuất hiện 2 lão quái Nguyên Anh hậu kỳ đỉnh phong, chỉ thiếu nửa bước cảm ngộ ý cảnh là đột phá tới cảnh giới Hóa Thần. Một người là Đồ Linh tôn giả - tức Alan Turing, nổi danh với pháp môn Turing Machine.  Người kia là Khâu Kỳ thượng tiên, Alonzo Church, tung hoành tam giới bằng đạo thuật Lambda Calculus  (1).\n\nTuring Machine của Alan Turing và Lambda Calculus của Alonzo Church thực ra là hai cách tiếp cận nguyên lý xử lý tính toán trong computer, thường được giới chuyên môn gọi chung là Luận đề Church - Turing ([The Church-Turing Thesis](https://plato.stanford.edu/entries/church-turing/)). \n\nTuring Machine đặt cơ sở trên việc nắm giữ state machine và trạng thái tiến trình, còn  ý tưởng Lambda Calculus được xây dựng trên các tính chất của hàm toán học. Lấy tu vi của bổn tiên hiện giờ thì chưa lĩnh hội được mấy thứ cao siêu như vậy, nên không dám lạm bàn ở đây. Chỉ biết rằng, 2 thuật pháp kể trên là khởi nguồn của 2 trường phái tu luyện mạnh nhất trong tin giới hiện nay: Object Oriented Programming và Functional Programming.\n\nCó khá nhiều cơ chế lập trình - Programming Paradigm. OOP và Functional Programming chỉ là 2 trong số đó. Trong cuốn \"[Programming Paradigms for Dummies: What Every Programmer Should Know](https://drive.google.com/file/d/1sNAojaDlY4Q9LAMad_2aJLIUBt06ru7U/view)\", tác giả Peter Van Roy đưa ra mô hình tổng hợp quan hệ giữa các cơ chế lập trình như thế này:\n\n![The principal programming paradigms](https://i.imgur.com/1yDCYYq.png)\n\nTrong lịch sử công nghệ, có vẻ OOP chiếm ưu thế hơn so với Functional Programming. Bạn cứ thử nhìn xung quanh mình là biết, từ thời tập tành code đã thấy thiên địa tràn ngập quy tắc OOP rồi. Các job description, các buổi interview đều nhắc đến OOP như pháp thuật căn bản. Thảo luận kỹ thuật hầu hết xoay quanh mấy khái niệm Class, Object, Inheritance, rồi cao hơn thì SOLID, Polymorphism, Encapsulation...\n\nNhưng, trên thế giới, từ thời [Lisp](http://lisp-lang.org/) đến [FP](https://en.wikipedia.org/wiki/FP_%28programming_language%29), rồi [Haskell](https://www.haskell.org/), [Elixir](https://elixir-lang.org/),  chưa bao giờ thiếu vắng những tu tin giả đi theo con đường Functional Programming. Nhất là khoảng sau 2010, không rõ vì sao người ta bắt đầu phàn nàn nhiều hơn về OOP, trích dẫn nhiều hơn luận điểm banana/gorilla của Joe Armstrong (2), theo đó, chủ đề \"Functional Programming\" bắt đầu nóng dần trở lại. \n\nTôi  biết đến Functional Programming vào khoảng 2015 qua một talk show trên YouTube của \"[chú Bob](https://en.wikipedia.org/wiki/Robert_C._Martin)\", nhưng không hiểu lắm nên cũng không chú ý. \n\nPhải sang 2016, tôi mới chính thức tìm hiểu sâu về Functional Programming sau khi đọc 2 loạt bài viết \"[Composing Software](https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea)\" của [Eric Elliott](https://medium.com/@_ericelliott) và \"[So You Want to be a Functional Programmer](https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536)\" của [Charles Scalfani](https://medium.com/@cscalfani) trên Medium. \n\nEric Elliott lần lượt giải thích từng concepts của Functional Programming một cách tường tận, dễ hiểu. Còn Charles Scalfani đúng là fan cuồng Functional Programming. Anh trình bày nó dưới dạng một hệ thống triết lý, thế giới quan đặc sắc. Thậm chí, Scalfani còn đề cao Functional Programming như nấc thang tiến hóa trong lịch sử lập trình. Lối viết của anh gây ấn tượng cực mạnh.\n\n![So You Want to be a Functional Programmer - Charles Scalfani](https://i.imgur.com/e3zKVPq.png)\n\nTrước đó, Scalfani còn có bài \"[Goodbye, Object Oriented Programming](https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53)\" gây tranh luận sôi nổi.\n\nNhưng bạn đọc nên lưu ý, Functional Programming không bài xích OOP. Chúng chỉ là những con đường tu luyện khác nhau, cùng hướng về Đại Đạo. Trong khi viết code, ta hoàn toàn có thể phối hợp nhiều cơ chế lập trình khác nhau, miễn sao đạt đến kết quả Đúng - Nhanh - Ổn - Đẹp. \n\nReactJS là một ví dụ tiêu biểu, có thể coi nó như 7 phần Functional Programming + 3 phần OOP. Về điểm này, [Anjana Vakil](https://twitter.com/anjanavakil) có một bài thuyết trình rất hay ở GOTO 2017.\n\nhttps://www.youtube.com/watch?v=Pg3UeB-5FdA\n\nDù sao, từ đó đến nay, khuynh hướng tư duy Functional Programming vẫn từng bước lan rộng, ảnh hưởng đến thiết kế của rất nhiều chương trình hiện đại.  Chỉ cần để ý một chút, chúng ta có thể nhận ra các đặc tính nổi bật của Functional Programming xuất hiện trong hầu hết frameworks và các bản cập nhật ngôn ngữ mới. Thậm chí, nếu xét kỹ, những khái niệm thoạt nhìn có vẻ không liên quan như WebComponent, Serverless, Microservice... cũng ẩn hiện tư tưởng Functional Programming. Và tôi gần như không còn đụng tới `class`, `new`, `this` nữa.\n\n![DCM tao khinh :))](https://i.imgur.com/LuyuYCU.jpg)\n\n\n### What's Functional Programming?\n\nVậy rốt cuộc Functional Programming là cái gì? Nếu google bạn sẽ tìm thấy hàng tá cách giải thích khác nhau. Còn tôi chủ chương nên định nghĩa ngắn gọn thế này:\n\n*Functional Programming là phương pháp lập trình lấy function làm đơn vị thao tác cơ bản.*\n\nĐúng vậy. Functional Programming xét về lý tưởng thì chỉ có function, function và function. Không  lệnh gán (assignment statements), không cần tới các biến (variables), không lưu giữ trạng thái toàn cục (global state). Trong Functional Programming, chúng ta điều khiển dòng chảy chương trình bằng cách phối hợp các functions lại với nhau. Chúng ta tung hứng các functions qua lại, nhận vào function, nhả ra function, lồng ghép, xâu chuỗi, biến hóa chúng theo mọi cách có thể nghĩ ra.\n\nĐó gọi là không gian \"[first-class functions](https://en.wikipedia.org/wiki/First-class_function)\", nơi lập trình viên đối xử với functions như \"first-class citizens\". Ở đâu functions được coi trọng như vậy, ở đó ta có thể lập trình theo cơ chế Functional Programming. JavaScript, Python, Golang, ngay cả PHP chính là như vậy. Java tính từ v8.0 ra mắt năm 2017 cũng là như vậy. Dù không hoàn hảo như Haskell, F#, etc - những tu chân giới vốn được sinh ra cho Functional Programming - nhưng ta vẫn có thể tu luyện Functional Programming được... \n\nChỉ có điều phải vận dụng khác một chút, linh hoạt hơn một chút. Đó là lý do tại sao trong các chương trình JavaScript, Python, dù viết theo phong cách Functional Programming nhưng vẫn phải dùng đến các biến, lệnh gán để thao tác.\n\nCác tu tin giả tầng thấp muốn bắt đầu con đường Functional Programming cần phải nắm bắt những khái niệm cơ bản như Immutability, Purity, Higher-order functions, Currying function, Function Composition... Sau khi thăng cấp cảnh giới cao hơn thì có thể tìm hiểu Monad, Functor, Setoid, Idempotent, Lens... và nhiều nữa. \n\nNào, bây giờ hãy bắt đầu hành trình...\n\n### Immutability\n\nImmutability nghĩa là tính bất biến. \n\nNguyên tắc thứ nhất trong Functional Programming là: cái nào đã khai báo một lần thì mãi mãi như vậy, không bao giờ thay đổi nữa. Các biến hoặc đối tượng trong kịch bản Functional Programming nếu có thì phải immutable.\n\nCode thế này không phải là Functional Programming vì x và y bị thay đổi.\n\n```\nvar x = 5;\nvar y = 2;\nwhile (x \u003c 10) {\n\ty += x;\n\tx++;\n}\n```\n\nMutable là điều tối kỵ trong Functional Programming. Cần phải hạn chế đến mức thấp nhất. Các mẫu coding convention và best practices thông dụng hiện nay đều khuyến khích sử dụng `const` để khai báo, bỏ hẳn `var` , và dùng `let` đúng liều lượng.\n\nĐối với Object, ta nên dùng `Object.freeze` để lock toàn bộ thuộc tính. Cũng có thể dùng  `Object.defineProperty`, `Object.defineProperties` để lock một số thuộc tính quan trọng. Các giải pháp này đều chỉ hỗ trợ 1 cấp thuộc tính. Phải chủ động code thêm nếu muốn áp dụng lên các thuộc tính con.\n\nNếu dự án đủ phức tạp, hãy cân nhắc sử dụng các thư viện chuyên dụng như [Immutable.js](https://facebook.github.io/immutable-js/), [Baobap](https://github.com/Yomguithereal/baobab)...\n\n\n### Purity\n\nPurity là tính thuần khiết, thuần túy, sự trong sạch, không bị pha tạp. \n\nĐây là nguyên tắc thứ hai trong Functional Programming: tất cả các hàm đều phải là pure function, không có hiệu ứng phụ (side effect), không được tác động lên bất cứ giá trị nào bên ngoài nó, cũng nói không với chỉnh sửa tham số input.\n\nHàm dưới đây không phải pure function vì nó chỉnh sửa DOM element bên ngoài và thay đổi  giá trị chứa trong localStorage.\n\n```\nconst updateView = (html) =\u003e {\n\tlet $view = document.getElementById('panel');\n\t$view.innerHTML = html;\n\tlocalStorage.setItem('panelCache', html);\n\treturn $view;\n}\n```\n\nĐặc điểm quan trọng nữa của pure function là với mỗi tập giá trị đầu vào nhất định, luôn có 1 và chỉ 1 kết quả trả về tương ứng. Đây là tính chất của hàm số toán học.\n\nHàm dưới đây không phải pure function vì trả về kết quả khác nhau cho cùng đầu vào:\n\n```\nconst getDuration = (timestamp) =\u003e {\n\treturn Date.now() - timestamp;\n};\n```\n\nPure function trong Functional Programming thường ngắn gọn, đơn giản và chỉ xử lý duy nhất 1 vấn đề logic.\n\nĐây là 1 pure function kinh điển:\n\n```\nconst add = (a, b) =\u003e {\n\treturn a + b;\n};\n```\n\nDù bạn có gọi hàng triệu lần thì `add(3, 2)` vẫn luôn trả về 5.\n\nViết unit test cho pure function là nhiệm vụ dễ chịu như dạo chơi cùng một thiếu nữ ngây thơ trong trắng vậy!\n\nImmutability và Purity là 2 đặc trưng cơ bản nhất của Functional Programming, cho phép phân biệt với các cơ chế lập trình khác. Tu tin giả tu luyện theo con đường này nhất định phải giữ tâm niệm \"immutable\" và \"pure\" trong từng sát na.\n\n\n#`\nPhần 1 của chuyên đề Functional Progamming xin dừng ở đây. Thanks for reading.\n\n### Chú thích\n\n1, Chữ Tàu ghi Alan Turing là 艾伦图灵 - Ngải Luân Đồ Linh, Alonzo Church là 阿隆佐邱奇 - A Long Tá Khâu Kỳ.\n\n2, \"You wanted a banana but you got a gorilla holding the banana\".\n\n`\n\n - [Xem phần 2: Nhập đạo](https://kipalog.com/posts/Functional-Programming---Phan-2---Nhap-dao) \n - [Xem phần 3: Buông bỏ ](https://kipalog.com/posts/Functional-Programming---Phan-3---Buong-bo)\n\n\n"
                }, {
                "id": "KrcFiHUq3Y4yVJST-h_aAQ",
                "title": "Xử lý assynchronous bằng axios và những lầm lẫn hay gặp khi sử dụng aysnc, await và axios",
                "content": "![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/zfnc4okssz_0_7362QLWAsdyhwsBB.png)\r\n\u003e# Chém gió\r\naxios là thư viện call api rất tuyệt vời, nó hầu như tương thích với mọi trình duyệt,khi mình sử dụng axios thì hầu như mình chả bao giờ phải dùng promise nữa.axios hỗ trợ cho cả npm ,cdn.. :v nói chung là quá tiện cho ai dùng để call api.\r\nĐây là document của [nó](https://github.com/axios/axios)\r\n\u003e# Async/await là gì ??\r\nasync/await là cú pháp mới của javascript khi lên ES7.Bạn có thể tham khảo tại [document](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) của nó  mình rất thích sử dụng nó hơn là promise.Vậy tại sao nên dùng nó .Ta xem đoạn code giới đây\r\nNhư đoạn code dưới đây ta thấy một promise  chỉ try catch đc một lần cho tất cả các callback\r\n```javascript\r\nconst makeRequest = () =\u003e {\r\n  return callAPromise()\r\n    .then(() =\u003e callAPromise())\r\n    .then(() =\u003e callAPromise())\r\n    .then(() =\u003e callAPromise())\r\n    .then(() =\u003e callAPromise())\r\n    .then(() =\u003e {\r\n      throw new Error(\"oops\");\r\n    })\r\n}\r\n```\r\nĐối với await . mỗi callback đều có thể try catch tùy ý\r\n\r\n```\r\nconst makeRequest = async () =\u003e {\r\n  const value1 = await promise1()\r\n  const value2 = await promise2(value1)\r\n  return promise3(value1, value2)\r\n}\r\n```\r\n\r\n\u003e# Cách sử dụng axios\r\naxios cung cấp rất cho ta rất nhiều method sẵn nhưng ở trong bài này mình chỉ nhắc đến ba cái phổ biến hay dùng nhất khi mình sử dụng restful api là get ,post, put. mọi method được gọi từ axios đều là bất động bộ vì vậy đề gán cho một biến nào đó ta phải sử dụng async/await\r\nVd mình muốn gửi request tới server lấy thông tin của một user có id là một chẳng hạn thì:\r\n```javascript\r\naxios.get('/user', {\r\n    params: {\r\n      id: 1\r\n    }\r\n  })\r\n  .then(function (response) {\r\n//response là biến chứa toàn bộ thông tin user\r\n    console.log(response);\r\n  })\r\n  .catch(function (error) {\r\n    console.log(error);\r\n  });\r\n```\r\n\u003e# Các sai lầm phổ biến khi sử dụng axios\r\nDưới đây mình nêu ra các sai lầm khi mình sử dụng axios ,thực ra sai lầm nên cũng tương tự như khi sử dụng promise nếu bạn nào đã dùng rồi chắc sẽ biết\r\n**Thứ 1:**\r\n``` javascript\r\nfunction TestAxios(){\r\n  const data=axios.get('/user', {\r\n      params: {\r\n        id: 1\r\n      }\r\n    })\r\n    .then(function (response) {\r\n  //response là biến chứa toàn bộ thông tin user\r\n      console.log(response);\r\n    })\r\n    .catch(function (error) {\r\n      console.log(error);\r\n    });\r\n  return data;\r\n}\r\n```\r\nOk ở đây hàm này sẽ chả trả về cho bạn cái mịa gì hết vì axios.get là hàm bất động bộ. Nó chưa load data về thì đã gán cho thằng data và return con mịa nó rồi. Vậy ở đây để gán cho data. Thì ta sử lại code đoạn này chút : ))).\r\n``` javascript\r\nasync function TestAxios(){\r\n  const data=await axios.get('/user', {\r\n      params: {\r\n        id: 1\r\n      }\r\n    })\r\n    .then(function (response) {\r\n  //response là biến chứa toàn bộ thông tin user\r\n      console.log(response);\r\n    })\r\n    .catch(function (error) {\r\n      console.log(error);\r\n    });\r\n  return data;\r\n}\r\n```\r\nNếu không muốn sử dụng await/async thì ta có thể return ngay trong then\r\n\r\n``` javascript\r\n function TestAxios(){\r\n axios.get('/user', {\r\n      params: {\r\n        id: 1\r\n      }\r\n    })\r\n    .then(function (response) {\r\n  //response là biến chứa toàn bộ thông tin user\r\n      console.log(response);\r\n      return response;\r\n    })\r\n    .catch(function (error) {\r\n      console.log(error);\r\n    });\r\n\r\n}\r\n```\r\nNói chung bài viết chỉ thế thôi. Bác nào có lỗi gì gặp mà chưa có ở trên thì cmt ở dưới cho em ý kiến.\r\n\r\n\r\n"
                }, {
                "id": "Z4xG2zpNRYz_VKmY3kTjjQ",
                "title": "Tại sao bạn nên học code go?",
                "content": "Tôi có thằng bạn, thời đi học lúc tôi học Java thì nó học C#, sau ra đường kiếm sống tôi xài Python thì nó nhập hội Ruby. Gần đây thấy bảo nó lại âm thầm dụ dỗ người ta về \"Hội thánh đức chúa [Elixir](https://quan-cam.com/posts/elixir-erlang-actors-model-va-concurrency)\". Mà thực ra tôi nói vòng vo vậy thôi chứ mục đích của tôi khi viết bài này là **dụ mọi người học Go**.\r\n\r\n### Go là cái gì?\r\n\r\n\u003e Ngôn ngữ lập trình hiện tại là Golang, một ngôn ngữ scripting và khá mới trên thị trường, nên việc tìm nhân sự sẽ gặp ít nhiều khó khăn so với các ngôn ngữ khác như Java, nhất là ở cấp độ Senior. Việc tổ chức code của  một scripting language cũng sẽ không trong sáng như các ngôn ngữ OOP, khi việc xử lý cho business logic ngày càng nhiều lên. - Người Lạ -\r\n\r\nTrên đây là một hiểu biết khá sai lầm về Go.\r\n\r\nVề cơ bản, Go là một compiled, concurrent, garbage-collected, statically typed language được phát triển tại Google, Open Source và cộng đồng đang phát triển mạnh mẽ, rất nhiều công ty lớn nhỏ trên thế giới đang nghiên cứu và sử dụng nó cho hệ thống của mình. Và tin tôi đi, ít nhiều những thứ bạn đang xài cũng sẽ có chút gì đó liên quan đến Go, bạn đã từng nghe đến Docker, Kubernetes, Prometheus, InfluxDB? Tất cả đều được viết bằng Go.\r\n\r\nGo được xây dựng dựa trên 3 tiêu chí **Effecient**, **Scalable**, **Productive**, nó được sinh ra để giải quyết bài toán ở chính Google, bài toán về multicore processor, network, và những hệ thống clusters khổng lồ, với những web programming model né tránh thay vì đối đầu trực diện với vấn đề.\r\n\r\nĐầu tiên, build time là một điều cực kỳ quan trọng, một project với hàng triệu dòng code cùng hàng trăm kỹ sư có thể làm việc trên đó, thay đổi mỗi ngày và liên tục, thời gian để clean build nếu mất hàng giờ đó là một vấn đề tồi tệ. Go được thiết kế để quản lý `dependencies` thông minh hơn, `dependency analysis` dễ dàng hơn, và giảm thiểu overheads trong quá trình include, preprocessing headers.\r\n\r\nMột vấn đề nữa của Google chính là string processing, Google đọc và phân tích hàng triệu thậm chí hàng tỉ trang web, họ phải xử lý chuỗi rất nhiều, bên trong Go được tích hợp sẵn rất nhiều library với hàng tá hàng hỗ trợ cho việc thao tác với các string. Ngoài ra với việc Garbage collector được tích hợp làm cho việc làm việc với strings dễ dàng và hiệu quả hơn.\r\n\r\nGo có một concurrency model rất tuyệt, điều tôi muốn nói đến chính là Goroutine. Có thể nó không đao to búa lớn, không ở cấp độ thần thánh về mặt thiết kế, nhưng ở khía cạnh end-users, nó dơn giản, trực quan và hiệu quả. Vậy còn data races thì sao? Hãy nhìn qua một chút, bạn có thể dùng phương pháp truyền thống là `sync.Mutex`, hoặc hãy xài một tính năng thời thượng đó chính là `channel` ngay hôm nay đi.\r\n\r\n### Go là một ngôn ngữ tồi!\r\n\r\nBắt đầu từ những vấn đề thực tế, Go được tạo ra để giải quyết những bài toán đến từ real world, tập trung nhiều vào software engineering hơn là research programming language design, nhiều người sẽ cảm thấy vui vẻ để sử dụng nó như một công cụ mạnh mẽ, nhưng số khác thì cho rằng nó là một `boring language`, không sáng tạo, cú pháp dài dòng, xấu xí.\r\n\r\nBạn sẽ không có những siêu cú pháp ảo diệu để biểu diễn cho thằng ngồi đối diện thấy là \"ngạc nhiên chưa?\", không có sẵn những syntactic sugar giúp bạn thực hiện những kỹ thuật phức tạp, mọi thứ luôn tuân theo một khuân mẫu, tuân theo từng cú pháp đơn giản, đôi lúc lại nhàm chán. Thay vào đó bạn phải gần gũi nhiều hơn với nền tảng điện toán, nào là CPU, memory, con trỏ, từng cái buffer, từng bit nhớ...\r\n\r\nTôi vẫn dùng Go, có thể tôi chỉ một lập trình viên tồi, nhưng biết đâu tôi lại là một engineer tốt thì sao? Và vì vẻ đẹp của điện toán nằm ở sự đơn giản.\r\n\r\nBài viết được đăng tại [5 Kilobytes per second](https://5kbps.io/posts/tai-sao-ban-nen-hoc-go/)"
                }, {
                "id": "xVxbFRtJ8FyTJ2Mw8XMJyQ",
                "title": "Bạn đã thực sự hiểu mutable và immutable?",
                "content": "![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/pm37bsw5mn_maxresdefault%20%283%29.jpg)\nLink gốc bài viết [ở đây](http://blog.daovanhung.com/post/ban-da-thuc-su-hieu-mutable-va-immutable)\n# Mở đầu\nBạn đã từng đọc hay nghe đâu đó nói rằng: **mutable** là giá trị có thể thay đổi được còn **immutable** là giá trị không thể thay đổi được. Nhưng bạn đã thực sự hiểu đúng nó chưa?\n```\n\u003e\u003e test = 3\n# =\u003e 3\n\n\u003e\u003e test\n# =\u003e 3\n\n\u003e\u003e test = 2 * test\n# =\u003e 6\n\n\u003e\u003e test\n# =\u003e 6\n```\n\nBạn nghĩ đoạn code trên(trong ruby) chứng tỏ biến **test** có phải là **mutable** không? \n\n\u003eTrong ruby, kiểu number và boolean luôn là immutable \n\nRõ ràng trong ruby, kiểu **number** luôn là **immutable** nhưng ta vẫn thấy **test** ở ví dụ trên có thể thay đổi được. Lý do là vì bạn đã hiểu sai từ **giá trị** trong định nghĩa.\n\nĐể hiểu đúng bạn cần biết được cách bộ nhớ lưu trữ một biến như thế nào.\n\n# Cách bộ nhớ lưu trữ và sử dụng biến\n\n\u003eNguyên lý 2 Von Neumann: Chương trình máy tính chỉ truy cập tới dữ liệu thông qua địa chỉ.\n\nBộ nhớ chương trình gồm có 2 thành phần là **địa chỉ bộ nhớ** và **dữ liệu** được lưu trữ trong bộ nhớ đó.\n\nKhi có một phép toán như phép gán `test = 3`, rõ ràng bộ nhớ cần lưu trữ chữ **test** và giá trị **3** của nó vào bộ nhớ:\n\n| Địa chỉ bộ nhớ   |      Gía trị ô nhớ      |\n|:-------------:|:-------------:|\n|\u001d xxx1       | test |\n| xxx2     | 3|\n\nCần lưu trữ một thứ gì đó trong bộ nhớ để gán `test = 3`, giả sử ví dụ đơn giản bộ nhớ làm như sau để lưu trữ phép gán đó:\n\n| Địa chỉ bộ nhớ   |      Gía trị ô nhớ 1      |  Gía trị ô nhớ 2 |\n|:-------------:|:-------------:|:-------:|\n|\u001d xxx1       | test | |\n| \u001dxxx2 |    3   |   |\n| xxx0 | xxx1 | xxx2|\n\nThế khi nào thì phép toán `test = test * 2` được xem là **mutable**, khi nào thì được xem là **immutable**?\n\nPhép toán trên được xem là **mutable** khi bộ nhớ thành như sau:\n\n| Địa chỉ bộ nhớ | Gía trị ô nhớ 1 | Gía trị ô nhớ 2 |\n|:------------:|:-------------:|:------------:|\n|  xxx1     |  test |     |\n|  xxx2     |   6   |    |\n|  xxx0     | xxx1 | xxx2 |\n \n\nPhép toán trên được xem là **immutable** khi bộ nhớ thành như sau:\n\n|Địa chỉ bộ nhớ|Gía trị ô nhớ 1|Gía trị ô nhớ 2|\n|:------------:|:------------:|:--------------:|\n|xxx1|test||\n|xxx2|3||\n|xxx3|6||\n|xxx0|xxx1|xxx3|\n \n\nNhư bạn thấy, khi giá trị của biến không bị ghi đè mà được copy sang một nơi khác thì đó mới là **immutable** , từ **giá trị** ở định nghĩa này chính là giá trị đi với ô nhớ.\n\nVì sao phải copy sang một ô nhớ khác như thế? Nếu chỉ có một biến tham chiếu tới một ô nhớ thì không có gì đáng nói nhưng khi bạn có nhiều biến tham chiếu tới cùng một ô nhớ thì khi thay đổi giá trị của một biến thì giá trị của các biến kia cũng đều thay đổi theo tương ứng(Xem ví dụ ở phía dưới).\n\nCòn nếu **xxx2** không còn được dùng trong **immutable** sẽ đi về đâu? Trong ruby có chương trình dọn rác **Garbage Collection** sẽ tự động xóa biến này đi khi nó đi thu dọn bộ nhớ.\n\nGiờ bạn có thể hiểu đoạn code ruby ở phần mở đầu rồi, nếu không tin bạn có thể in ra object_id của nó để xác thực:\n```\n\u003e\u003e test = 3\n# =\u003e 3\n\n\u003e\u003e test\n# =\u003e 3\n\u003e\u003e test.object_id\n# =\u003e 7\n\n\u003e\u003e test = 2 * test\n# =\u003e 6\n\n\u003e\u003e test\n# =\u003e 6\n\u003e\u003e test.object_id\n# =\u003e 13\n```\n\nThế vì sao lại phải cần tới **immutable** để làm gì khi nó giảm công suất của bộ nhớ đi như thế? Xem phần dưới.\n\n#Khi nào nên dùng mutable và immutable \n## Khi nào nên dùng mutable\n\n\u003eKhi cần thay đổi một biến trong vòng lặp thì bạn nên dùng mutable\n\nNếu lặp n phần tử mà ta dùng immutable như sau:\n```\nString s = \"\";\nfor (int i = 0; i \u003c n; ++i) {\n    s = s + n;\n}\n```\n\nTrong java, kiểu **String** là **immutable**. Đoạn code trên cứ mỗi lần gán `s = s + n` là phải copy biến **s cũ** thành object khác rồi mới gán vào **s mới** được. Cứ mỗi lần copy **s cũ** là phải lặp số ký tự có trong **s cũ** để copy, dẫn tới thời gian tính toán của thuật toán là **O(n²)**.\n\nTa có thể cải thiện thuật toán trên bằng cách sử dụng mutable:\n```\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i \u003c n; ++i) {\n  sb.append(String.valueOf(n));\n}\n\nString s = sb.toString();\n```\n\n##Khi nào nên dùng immutable\n\nTrong đa số các trường hợp, bạn nên dùng **immutable** vì **immutable** dễ hiểu và không xảy ra bug liên quan tới **reference** còn **mutable** khiến cho code không tuân theo luồng suy nghĩ của lập trình viên, khó đọc, dễ gây bug khó chịu liên quan tới **reference**.\n\nVD1 gây bug:\n```\n/** @return the sum of the numbers in the list */\npublic static int sum(List\u003cInteger\u003e list) {\n    int sum = 0;\n    for (int x : list)\n        sum += x;\n    return sum;\n}\n\n/** @return the sum of the absolute values of the numbers in the list */\npublic static int sumAbsolute(List\u003cInteger\u003e list) {\n    // let's reuse sum(), because DRY, so first we take absolute values\n    for (int i = 0; i \u003c list.size(); ++i)\n        list.set(i, Math.abs(list.get(i)));\n    return sum(list);\n}\n\n\n// meanwhile, somewhere else in the code...\npublic static void main(String[] args) {\n    // ...\n    List\u003cInteger\u003e myData = Arrays.asList(-5, -3, -2);\n    System.out.println(sumAbsolute(myData));\n    System.out.println(sum(myData));\n}\n```\n\n- Hàm `sum` tính tổng các phần tử của list truyền vào\n- Hàm `sumAbsolute` tính tổng giá trị tuyệt đối của mỗi phần tử của list truyền vào. Vì không muốn tạo một mảng tạm trong hàm này nên lập trình viên đã dùng lại luôn list truyền vào để đỡ tốn bộ nhớ và hiệu năng.\n\nVấn để xảy ra khi ai đó gọi hàm `sumAbsolute(myData)` với mảng bất kỳ **myData** rồi gọi tiếp `sum(myData)`, khi gọi `sumAbsolute(myData)` thì hàm này đã làm mảng **myData** bị thay đổi nên hàm `sum(myData)` không còn gọi đúng với **myData** ban đầu như dự kiến nữa.\n\nVD2 gây bug:\n```\nprivate static Date startSpringDate = null;\n\n/** @return the first day of spring this year */\npublic static Date startOfSpring() {\n    if (startSpringDate == null) startSpringDate = getStartOfSpring();\n    return startSpringDate;\n}\n\n\n// somewhere else in the code...\npublic static void partyPlanning() {\n    // let's have a party one month after spring starts!\n    Date partyDate = startOfSpring();\n    partyDate.setMonth(partyDate.getMonth() + 1);\n}\n```\n\n- Kiểu **Date** trong java là **mutable**. \n- Hàm `startOfSpring()` để lấy ngày đầu tiên của mùa xuân, vì hàm `getStartOfSpring()` phía trong có xử lý rất phức tạp và tốn thời gian nên lập trình viên đã gán một biến global **startSpringDate** để lưu giá trị của `startOfSpring()` vào giúp khỏi phải gọi lại khi cần thiết.\n\nVấn đề xảy ra khi một lập trình viên nào đó muốn lấy ngày đầu tiên của mùa xuân và cộng thêm 1 tháng nữa như đoạn code trên. Vì **startSpringDate** và **partyDate** lúc này đang cùng trỏ đến một giá trị và kiểu **Date** trong java là **mutable** nên khi gọi hàm `partyDate.setMonth(...` thì vô tình chung họ đã làm biến **startSpringDate** bị thay đổi, thiết kế ban đầu nhằm mục đích biến này không bị thay đổi nên nó gây ra bug.\n\n\nLink tham khảo:\nhttps://launchschool.com/blog/references-and-mutability-in-ruby\nhttps://en.wikipedia.org/wiki/Variable_(computer_science)\nhttp://web.mit.edu/6.005/www/fa15/classes/09-immutability/"
                }, {
                "id": "aMNqVvwEN8hjpBfZscpf2Q",
                "title": "Làm game Calculator với kỹ thuật currying và React",
                "content": "**Bài viết gốc được đăng ở Ê-ku [https://ehkoo.com/bai-viet/lam-game-calculator-voi-ky-thuat-currying-va-react](https://ehkoo.com/bai-viet/lam-game-calculator-voi-ky-thuat-currying-va-react)**\n\n---\n\n[Calculator](http://www.simplemachine.co/game/calculator-the-game/) là một game giải đố của công ty Simple Machine có cách chơi đơn giản nhưng khá \"hack não\": trong mỗi màn chơi, bạn có một giá trị ban đầu, một giá trị đích, số bước thực hiện cho phép cùng với các nút phép tính. Nhiệm vụ của bạn là đạt được giá trị đích bằng cách bấm CHÍNH XÁC số bước cho phép, như trong hình dưới đây.\n\n![](https://res.cloudinary.com/duqeezi8j/image/upload/v1525863051/Dvfg94g_rlozdw.png)\n_Sử dụng +4, x4, /4 để đạt được giá trị 4 từ giá trị ban đầu là 3 trong 3 bước_\n\nGame rất thú vị, dùng để thử thách trí tuệ và/hoặc giết thời gian khá tốt. Nhưng hôm nay chúng ta sẽ luyện não theo kiểu khác, bằng cách làm một game tương tự với kỹ thuật currying và React.\n\n### Phân tích game\n\nDựa vào hình chụp ở trên, bước đầu ta có thể nghĩ một game bao gồm những thuộc tính sau:\n\n```js\nconst game = {\n  goal: 4,\n  moves: 3,\n  initResult: 3,\n  currentResult: 3,\n  operators: [ Operator('+4'), Operator('x4'), Operator('/4') ]\n}\n```\n\nLuồng của game có thể được biểu diễn theo sơ đồ:\n\n![](https://res.cloudinary.com/duqeezi8j/image/upload/v1525863026/ZlDZJOl_wjhst8.png)\n\nVấn đề đầu tiên chúng ta gặp phải: làm sao để tạo ra các nút phép tính trong game? Bạn có thể khai báo trước nhiều nút với các hành động định trước, ví dụ như `+4`, `x4`, hay `/4`, nhưng sẽ như thế nào nếu số lượng màn chơi nhiều lên? Có cách nào để tạo ra các nút một cách tự động không?\n\n Câu trả lời là: dùng kỹ thuật currying.\n\n### Currying là gì?\n\nCurrying là kỹ thuật tách một hàm nhận nhiều tham số thành một chuỗi các hàm, với mỗi hàm chỉ nhận một tham số. Lấy ví dụ, dưới đây là hàm `add()` bình thường.\n\n```js\nfunction add(a, b) {\n  return a + b\n}\n```\n\nĐể currying hàm `add()`, chúng ta chuyển thành.\n\n```js\nfunction add(a) {\n  return function(b) {\n    return a + b\n  }\n}\n\n// Hoặc với hàm mũi tên\nconst add = a =\u003e b =\u003e a + b\n```\n\nSử dụng\n\n```js\nadd(5)(6) // 11\n```\n\n\"_Hmm, nhìn thấy còn dài dòng hơn. Vậy currying có ứng dụng gì?_\" Nhờ vào đặc tính trả về hàm của nó, bạn có thể tạo hàm mới một cách linh động.\n\n```js\nconst add5 = add(5)\nconst add10 = add(10)\n\nadd5(6) // 11\n```\n\nBằng cách này, bạn có thể tạo ra hàm mới mà không cần phải cặm cụi hard-code từng dòng. Một ví dụ khác, chẳng hạn bạn có object sau:\n\n```js\nconst songs = [\n  { id: 4, name: 'Người nạ ơi' },\n  { id: 5, name: 'Yêu với chả đương' },\n  { id: 6, name: 'Cô gái 5m2' }\n]\n```\n\nGiả sử bạn muốn lấy ra danh sách các ID, bạn có thể dùng hàm `map()`.\n\n```js\nseries.map(item =\u003e item.id) // [4, 5, 6]\n```\n\nMột lúc sau, bạn lại cần danh sách tên các bài hát. Bạn cũng có thể dùng hàm `map` theo cách tương tự.\n\n```js\nseries.map(item =\u003e item.name) // ['Người nạ ơi', 'Yêu với chả đương', 'Cô gái 5m2']\n```\n\nNhưng bạn thấy đó, hàm được đưa vào `map()` ở cả hai trường hợp khá giống nhau, chỉ khác về tên thuộc tính cần lấy ra. Chúng ta có thể dùng currying như sau.\n\n```js\nconst get = attr =\u003e item =\u003e item[attr]\n\nconst getId = get('id')      // curried\nconst getName =  get('name') // curried\n\nseries.map(getId)   // [4, 5, 6]\nseries.map(getName) // ['Người nạ ơi', 'Yêu với chả đương', 'Cô gái 5m2']\n```\n\nVí dụ cuối cùng có liên quan đến React. Có thể không ít lần, bạn phải làm việc với mảng các danh sách.\n\n```jsx\nclass ProductList extends React.Component {\n  handleDeleteProduct = (productId, e) =\u003e {\n    e.preventDefault()\n    this.props.deleteProduct(productId)\n  }\n\n  render() {\n    // ...\n    {this.props.products.map(product =\u003e (\n      \u003cdiv key={product.id}\u003e\n        // ...\n        \u003cbutton onClick={this.handleDeleteProduct.bind(this, productId)}\u003eDelete\u003c/button\u003e\n      \u003c/div\u003e\n    ))}\n  }\n}\n```\n\nĐể truyền vào đúng `productId`, chúng ta dùng `.bind` để đẩy tham số vào `this.handleDeleteProduct`. Hoặc bạn có thể dùng currying.\n\n```jsx\nhandleDeleteProduct = productId =\u003e e =\u003e {\n  e.preventDefault()\n  this.props.deleteProduct(productId)\n}\n\n\u003cbutton onClick={this.handleDeleteProduct(productId)}\u003eDelete\u003c/button\u003e\n```\n\nNhư vậy, mỗi `button` sẽ có một hàm `this.handleDeleteProduct` riêng với giá trị `productId` đã được định trước.\n\nQuay trở lại trò chơi của chúng ta, vì mỗi màn chơi có thể sẽ có những nút phép tính khác nhau, bạn được tạo ra chúng tự động bằng cách dùng currying.\n\n```js\nconst add = a =\u003e b =\u003e a + b\nconst sub = a =\u003e b =\u003e a - b\nconst div = a =\u003e b =\u003e a / b\n\nconst operators = [add(4), sub(4), div(4)]\n```\n\n### Viết code thôi\n\nĐầu tiên, Ehkoo sẽ dùng `create-react-app` để tạo ra một dự án mới.\n\n```bash\nnpx create-react-app calc\ncd calc\nnpm i\nnpm start\n```\n\nSau đó, chúng ta có thể tạo giao diện cho game tương tự như thế này :point_right: [CodeSandbox](https://codesandbox.io/s/r07lx5x2lm?from-embed)\n\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mr6hhcnoyo_image.png)\n\nLúc này một vấn đề khác lại xuất hiện: Chúng ta đã có thể dùng currying để tạo ra một phép tính, làm thế nào để hiển thị nhãn (label) của phép tính đó lên nút bấm? Một cách giải quyết là thay vì chỉ trả về hàm tính toán, chúng ta trả về một object bao gồm cả nhãn và hàm.\n\n```js\n// operators.js\nexport function sub(x) {\n  return {\n    label: `-${x}`,\n    func: y =\u003e y - x\n  }\n}\n\nconst sub4 = sub(4)\n// { label: '-4', func }\n```\n\n\u003e **LƯU Ý**: Bạn có để ý thấy tham số `y` đã được lật ngược lại `y - x` thay vì `x - y` không? Đó là vì trong trò chơi của chúng ta, khi người chơi click vào một phép tính, kết quả hiện tại (tương ứng với tham số `y`) sẽ bị trừ đi giá trị định trước của nút bấm. Do đó chúng ta phải đảo ngược thứ tự tham số ở đây. Khi bạn viết code cho phép tính chia (div), cũng phải làm tương tự.\n\nBạn có thể tự mình viết tiếp hàm để tạo ra phép tính trừ, nhân, chia và lưu vào tập tin `src/operators.js`. Hãy cập nhật  lại `this.state` của `src/App.js` để thử các nút bấm.\n\n```jsx\n// src/App.js\nimport { add, sub, div } from './operators'\n\nclass App extends React.Component {\n  state = {\n    goal: 4,\n    moves: 3,\n    initResult: 3,\n    currentResult: 3,\n    operators: [add(4), sub(4), div(4)]\n  }\n\n  render() {\n    // ...\n    {this.state.operators.map(op =\u003e (\n      \u003cbutton key={op.label} className=\"button\" onClick={this.doClickButton(op)}\u003e\n        {op.label}\n      \u003c/button\u003e\n    ))}\n  }\n}\n```\n\nPhương thức `this.doClickButton` có thể được viết như sau:\n\n```js\ndoClickButton = op =\u003e e =\u003e {\n  e.preventDefault()\n  this.setState(prevState =\u003e {\n    // Áp dụng phép tính lên giá trị hiện tại\n    const currentResult = op.func(prevState.currentResult)\n    // Giảm số bước đi cho phép\n    const moves = prevState.moves - 1\n\n  // Nếu không thể đi được nữa, trò chơi kết thúc\n    if (moves === 0) {\n      console.log(currentResult === prevState.goal ? 'WIN' : 'LOSE')\n    }\n\n  // Ngược lại, cập nhật this.state\n    return { currentResult, moves }\n  })\n}\n```\n\nChúng ta cần thêm một trạng thái để _đánh dấu trò chơi đã kết thúc_ khi `moves === 0` và _hiển thị kết quả_. Do đó Ehkoo khai báo thêm 2 hằng số `WIN` và `LOSE`, đồng thời thêm vào `state` thuộc tính `gameEnd` và `gameResult = WIN | LOSE`.\n\n```js\nconst WIN = 'WIN'\nconst LOSE = 'LOSE'\n\nstate = { ...state, gameEnd: false, gameResult: null }\n\ndoClickButton = op =\u003e e =\u003e {\n  // Nếu trò chơi đã kết thúc, chúng ta không xử lý sự kiện nữa\n  if (this.state.gameEnd) return\n\n  // ...\n  const gameEnd = moves === 0\n  const gameResult = currentResult === prevState.goal ? WIN : LOSE\n  return { currentResult, moves, gameEnd, gameResult }\n}\n```\n\nDựa vào giá trị của `this.state.gameEnd`, ta có thể thêm vào thông báo kết quả khi trò chơi kết thúc bên trong hàm `render()`.\n\n```jsx\n{this.state.gameEnd ? this.state.gameResult : null}\n```\n\n:point_right: [CodeSandbox](https://codesandbox.io/s/jjjxpw7679?from-embed)\n\n![](https://media.giphy.com/media/fCUTG8OEkHJJOJgpzS/giphy.gif)\n\n\nPhần xử lý trò chơi tới đây cũng tương đối ổn rồi. Tiếp theo chúng ta sẽ tạo ra màn chơi mới.\n\n### Tạo màn chơi mới\n\nĐể khởi tạo màn chơi mới, chúng ta sẽ viết một hàm `generate(options = {})`, nhận vào một object chứa các thiết lập cho màn chơi, chẳng hạn như giá trị ban đầu, số lượng phép tính, khoảng giá trị của các phép tính này... Kết quả trả về của hàm `generate()` sẽ được kết hợp vào `state` của `src/App.jsx`.\n\nTham số `options` ở trên bao gồm những thuộc tính sau:\n\n* `initResult`: giá trị ban đầu của màn chơi\n* `numberOfMoves`: số bước đi cho phép. Số bước đi càng nhiều thì trò chơi càng khó\n* `numberOfOperators`: số lượng phép tính\n* `operatorRange`: khoảng giá trị của các phép tính. Trò chơi sẽ dễ hơn nếu bạn chỉ có các phép tính như `+3`, `-6`, `*2`, nhưng sẽ khó hơn nếu là các phép tính `+12`, `*8`, `-23`...\n\nChúng ta sẽ lần được đi qua các bước:\n\n* Khởi tạo options dựa vào thiết lập của người dùng\n* Tạo ngẫu nhiên một mảng các phép tính\n* Áp dụng `moves` lần các phép tính này vào `initResult`\n* Kết quả cuối cùng chính là `goal`\n* Trả về thiết lập cho màn chơi\n\n![](https://res.cloudinary.com/duqeezi8j/image/upload/v1525863188/BccW92d_si140s.png)\n\nHai hàm bên dưới sẽ rất hữu ích để tạo số ngẫu nhiên trong một khoảng định trước, và lấy ra một phần tử ngẫu nhiên trong mảng.\n\n```js\n// src/helpers.js\n// Tạo số ngẫu nhiên trong khoảng định trước. Không đính kèm `max` trong kết quả.\nexport function randomInt(min, max) {\n  // Nguồn: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\n  min = Math.ceil(min)\n  max = Math.floor(max)\n\n  return Math.floor(Math.random() * (max - min)) + min\n}\n\n// Lấy ra phần tử ngẫu nhiên trong mảng\nexport function pickArrayRandom(array) {\n  return array[randomInt(0, array.length - 1)]\n}\n```\n\nDựa vào sơ đồ ở trên, ta có thể viết hàm `generate()` như sau:\n\n```js\n// src/generate.js\nimport { randomInt, pickArrayRandom } from './helpers'\nimport * as allOperators from './operators'\n\nexport default function(options = {}) {\n  const opt = {\n    initResult: randomInt(0, 10),\n    numberOfMoves: randomInt(3, 5),\n    numberOfOperators: randomInt(3, 5),\n    operatorRange: [1, 9],\n    ...options\n  }\n\n  // Vì ES6 import tất cả operators thành một object,\n  // dùng Object.values() để chuyển thành mảng\n  const ops = Object.values(allOperators)\n\n  // Tạo ngẫu nhiên mảng các phép tính -\u003e nút bấm\n  const operators = Array.from({ length: opt.numberOfOperators }, () =\u003e {\n    const op = pickArrayRandom(ops)\n    return op(randomInt(...opt.operatorRange))\n  })\n\n  // Áp dụng ngẫu nhiên các phép tính ở trên vào `initResult`\n  const goal = Array.from({ length: opt.numberOfMoves }).reduce(goal =\u003e {\n    const op = pickArrayRandom(operators)\n\n    return op.func(goal)\n  }, opt.initResult)\n\n  return {\n    goal,\n    operators,\n    currentResult: opt.initResult,\n    initResult: opt.initResult,\n    moves: opt.numberOfMoves\n  }\n}\n```\n\n\u003e**Suy ngẫm**:\n\u003e Trong quá trình tạo ra các phép tính, nếu vô tình có 2 phép nhân ví dụ `*8` hay `*9`, kết quả của `goal` sẽ lớn và khó chơi hơn. Bạn có thể cải tiến hàm `generate()` ở trên để đảm bảo chỉ có một phép nhân duy nhất được tạo ra.\n\u003e \n\u003e Ngoài ra còn có một cách khác để tính `goal` là, bạn xác định `moves = randomInt(3, operators.length)` (phải có ít nhất 3 phép tính, hoặc bạn có thể quy định tối đa 4 phép tính/game mà thôi), sau đó bạn tạo bản sao mảng operators, shuffle mảng này rồi áp dụng các phép tính từ trên xuống `moves` lần. Cách làm này đảm bảo mỗi phép tính chỉ được áp dụng một lần, nhưng đòi hỏi bạn phải có thêm nhiều phép tính nữa. Như trong game gốc, chúng ta có phép đảo dấu, và phép xóa chữ số cuối.\n\nÁp dụng `generate()` vào `src/App.jsx`.\n\n```jsx\nimport generate from './generate'\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      ...generate(),\n      gameEnd: false,\n      gameResult: null\n    }\n  }\n}\n```\n\nKết quả: (bạn click vào nút reload để xem màn chơi thay đổi nhé) :point_right: [CodeSanbox](https://codesandbox.io/s/oon5v9nm85?from-embed)\n\n![](https://media.giphy.com/media/20yBWqSzgedYkwtkw3/giphy.gif)\n\n\n### Thêm nút CLR\n\nNút CLR cho phép khởi động lại màn chơi, trong trường hợp chẳng may tính sai. Không quá khó để làm tính năng này, chúng ta chỉ cần lưu `state` khi khởi tạo game vào một thuộc tính `initState` nào đó, và khi click vào nút CLR thì gọi đến `this.setState(initState)`.\n\n```js\n// src/App.jsx\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    const initState = {\n      ...generate(),\n      gameEnd: false,\n      gameResult: null\n    }\n\n    this.initState = initState\n    // Tạo bản sao của initState\n    this.state = { ...initState }\n  }\n\n  doReset = e =\u003e {\n    e.preventDefault()\n    this.setState(this.initState)\n  }\n}\n```\n\n:point_right: [CodeSandbox](https://codesandbox.io/s/62119rq3ww?from-embed)\n\n![](https://media.giphy.com/media/5YbPugzo9U8Nho35Iu/giphy.gif)\n\n### Kết\n\nTrò chơi của chúng ta tới đây đã tương đối hoàn thành rồi. Chỉ còn một vài tính năng nhỏ, ví dụ như làm cho giao diện hiển thị kết quả đẹp hơn, thêm các phép tính mới, tự động tạo game mới khi người chơi đã thắng màn chơi cũ, hoặc viết code cho nút Help giúp giải thích cách chơi hay tạo nút Hint gợi ý bước đi tiếp theo... nhưng mình sẽ để bạn tự làm nhé.\n\nHi vọng qua bài viết này bạn đã hiểu về kỹ thuật currying và biết cách áp dụng nó vào dự án thực tế. Bạn có thể tìm thấy mã nguồn của game ở đây [https://github.com/ehkoo/calculator](https://github.com/ehkoo/calculator). Nếu bạn có cải tiến cho trò chơi thì đừng ngại ngần gửi PR hoặc comment bên dưới nha.\n"
                }, {
                "id": "3X14SDEy2RkZBDgIJwQsVg",
                "title": "Chém gió về JavaScript Design Pattern - Part 2",
                "content": "GIAOSUCAN'S BLOG - CHIA SẺ KIẾN THỨC KĨ THUẬT THEO CÁCH BÁ ĐẠO\n## http://www.giaosucan.com/\n\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7q6hpsj3dv_image.png)\nTiếp tục chủ đề chém gió về JavaScript Design Pattern. Bài viết này sẽ giới thiệu đến các bạn một số design pattern thông dụng được viết bằng ngôn ngữ JavaScript.\n\n##Factory pattern\n\nMục đích của pattern này là tạo các object\n\nThực hiện các thao tác lặp lại khi tạo các đối tượng tương tự nhau\nCung cấp các phương thức để tạo object mà không cần biết kiểu tạo thời điểm biên dịch\nHãy xem ví dụ sau\n\nConstructor CarMaker\nCar Maker có static method factory() để tạo các car objects\nConstructor đặc biệt như CarMaker.Compact, CarMaker.SUV, and CarMaker.Convertible kế thừa CarMaker. Tất cả constructor trên được định nghĩa như static – properties \nBạn sẽ implement như sau\n```\nvar corolla = CarMaker.factory('Compact');\n\nvar solstice = CarMaker.factory('Convertible');\n\nvar cherokee = CarMaker.factory('SUV');\n\ncorolla.drive(); // \"Vroom, I have 4 doors\"\n\nsolstice.drive(); // \"Vroom, I have 2 doors\"\n\ncherokee.drive(); // \"Vroom, I have 17 doors\"\n\n```\n\nTrong đoạn code trên, đây là phần cần chú ý nhất\n```\nvar corolla = CarMaker.factory('Compact');\n```\n\nBạn chỉ cần truyền tham số vào method factory, CarMaker sẽ trả về object tương ứng. Như vậy bạn không cần phải dùng từ khóa new để tạo object, chỉ cần dùng method để tạo object dựa vào tham số truyền vào\n\nDưới đây là toàn bộ source code đầy đủ\n```\n// parent typeuctor\n\nfunction CarMaker() {}\n\n// a method of the parent\n\nCarMaker.prototype.drive = function () {\n\n  return \"Vroom, I have \" + this.doors + \" doors\";\n\n};\n\n// the static factory method\n\nCarMaker.factory = function (type) {\n\n  var newcar;\n\n  // error if the typeuctor doesn't exist\n\n  if (typeof CarMaker[type] !== \"function\") {\n\n    throw {\n\n      name: \"Error\",\n\n      message: type + \" doesn't exist\"\n\n    };\n\n  }\n\n  // at this point the typeuctor is known to exist\n\n  // let's have it inherit the parent but only once\n\n  if (typeof CarMaker[type].prototype.drive !== \"function\") {\n\n    CarMaker[type].prototype = new CarMaker();\n\n  }\n\n  // create a new instance\n\n  newcar = new CarMaker[type]();\n\n  // optionally call some methods and then return...\n\n  return newcar;\n\n};\n\n// define specific car makers\n\nCarMaker.Compact = function () {\n\n  this.doors = 4;\n\n};\n\nCarMaker.Convertible = function () {\n\n  this.doors = 2;\n\n};\n\nCarMaker.SUV = function () {\n\n  this.doors = 24;\n\n};\n```\n\n##Built-in Object Factory\nJavaScript cung cấp built-in object là Object() constructor. Object này có behavior tương tự như factory, do nó cho phép tạo ra các object khác nhau dựa trên tham số đầu vào. \n\nVí dụ nếu bạn truyền tham số đầu vào là string, Object() sẽ tạo ra string object, truyền vào là số thì tạo ra object kiểu số.\n\nVí dụ\n```\nvar obj = new Object(),\n\n  numberObj = new Object(1),\n\n  stringObj = Object('1'),\n\n  boolObj = Object(true);\n\n// test\n\nobj.constructor === Object; // true\n\nnumberObj.constructor === Number; // true\n\nstringObj.constructor === String; // true\n\nboolObj.constructor === Boolean; // true\n```\n\n\n## Iterator\nTrong pattern này, bạn có một object chứa data có cấu trúc phức tạp, bạn muốn truy cập vào thuộc tính của object này một cách dễ dàng. Người dùng object không cần biết cấu trúc của object, họ chỉ cần làm việc với các thuộc tính riêng lẻ\n\nTrong mô hình này, bạn cần phát triển một method next(),gọi hàm này để lấy phần tử tiếp theo\n```\nvar element;\n\nwhile (element = agg.next()) {\n\n  // do something with the element ...\n\n  console.log(element);\n\n}\n\n```\n\nImplement iterator pattern như sau\n```\nvar agg = (function () {\n\n  var index = 0,\n\n    data = [1, 2, 3, 4, 5],\n\n    length = data.length;\n\n  return {\n\n    next: function () {\n\n      var element;\n\n      if (!this.hasNext()) {\n\n        return null;\n\n      }\n\n      element = data[index];\n\n      index = index + 1;\n\n      return element;\n\n\n\n    },\n\n    hasNext: function () {\n\n      return index \u003c length;\n\n    }\n\n  };\n\n}());\n```\n\nĐể dễ dàng truy cập data, bạn có thể implement thêm một số method sau\n\nrewind() : reset pointer trở về đầu\n\ncurrent(): trả về phần tử hiện tại\n```\nvar agg = (function () {\n\n  // [snip...]\n\n  return {\n\n    // [snip...]\n\n    rewind: function () {\n\n      index = 0;\n\n    },\n\n    current: function () {\n\n      return data[index];\n\n    }\n\n  };\n}());\n```\n\nCòn rất nhiều pattern nữa, đón đọc phần sau nha\n"
                }, {
                "id": "5oE4AtDwd0OugfVJuLnzxg",
                "title": "cách học DỐT tiếng anh cho lập trình viên",
                "content": "google cách học tốt tiếng anh thì ra hàng đống kết quả nhưng đảm bảo không có cái nào dùng được (nếu dùng được thì bạn đã tiến bộ rồi phải không). Vậy thay vì tìm cách học tốt hãy đọc thử những cách học DỐT sau đây xem sao.\r\n\r\nLưu ý: những bài viết thể hiện quan điểm như này vốn không có sự đúng sai tuyệt đối, mọi hệ lụy xảy ra đều là do cơ địa của bạn :smile:\r\n\r\n# 1. Xem/đọc BBC, CNN, xem thời sự, đọc báo thanh niên báo tuổi trẻ, American Voice People hay cái gì ấy mình không nhớ tên....v...v\r\n\r\nBí kíp học dốt tiếng anh đầu tiên, là hãy lao vào đọc/xem những thứ bạn không quan tâm, nhàm chán thiếu thú vị, chỉ cốt để nhồi nhét tiếng Anh vào đầu, công dụng duy nhất là dễ ngủ, Mình đã thử và thành công.\r\n\r\nMấy trang kia mang tính chất **ví dụ**, hãy thay thế cụm trang đó bằng trang nào bạn không thích, chân lý vẫn giữ nguyên.\r\n\r\n# 2. Đào bới khắp thành phố tìm trung tâm tiếng anh nào cho ngon.\r\n\r\nChưa thấy ở đâu lắm trung tâm tiếng anh như ở việt nam, chưa thấy ở đâu các Trung tâm dám **TO CÒI** hô hào khẩu hiệu, thần kì hiệu quả chữa bách bệnh như ăn thịt Đường Tăng như ở VIệt Nam. Rồi đăng lên mấy cái tấm gương thành công do học ở trung tâm mà ra, tìm hiểu mới biết đều là người du học hay học trường quốc tế, không thì cũng là tự giỏi từ trước rồi.\r\n\r\nHọc ở lớp học hay trung tâm có tác dụng khi bạn hoàn toàn mù chữ + không có khả năng tự học + quá lo lắng không biết làm quen tiếng anh như nào + quá tự kỉ không thể ngồi học một mình thêm nữa + muốn giao lưu kết bè kết bạn ngắm gái xinh. Còn đâu thì muốn tiến bộ **nhiều** thì cách tốt nhất là **TỰ THÂN**. \r\n\r\n# 3. Cứ kiếm hết cách học này đến cách học kia, nhưng không nghe lời ai cả\r\n\r\nĐã hỏi cách học thì ít nhất hãy tạm tin và làm theo xem sao đã. Nếu một thời gian sau thấy không hiệu quả thì đổi sang cách khác vì không ai giống ai. Đừng hoang mang lo ngại là làm thế này được không làm thế kia được không. Vì chung quy lại thì làm gì cũng sẽ giỏi lên thôi. Cách duy nhất để dốt đi là cách bạn đang làm: hoang mang chong chóng hết cách này cách kia mà không thực sự bắt tay vào cách nào cả.\r\n\r\n# 4. Download thật nhiều tài liệu, mua thật nhiều sách, down app về chật ních máy\r\n\r\nNgoại trừ từ điển chỉ cần 1 cái và có khi còn tra. Chứ sách vở các thứ thì mở ra dược mấy lần? Xóa đi để bộ nhớ mà tải phim.\r\n\r\n# 5. Làm thật nhiều \"bài tập\"\r\n\r\nTiếng anh chứ có phải toán đâu mà học cái kiểu cộng cộng trừ trừ. S + V-ng + O... cộng cộng suốt ngày đến lúc cần thì trong đầu cũng không nhớ nổi.\r\n\r\n# 6. Cái gì cũng hỏi tại sao\r\nTại sao chỗ này lại viết như thế, tại sao người ta lại nói như thế. \r\n\r\nCâu trả lời kiểu \"khoa học hóa tiếng anh\" sẽ là:\r\n* ở vì đây là thì hiện tại hoàn thành tiếp diễn, mà thì này được dùng diễn tả một việc đã xảy ra và chưa kết thúc mà bla bla bla\r\n* ờ vì -ing dùng cho vật còn -ed dùng cho người....\r\n\r\nRất tiếc, sự giải thích tiếng anh chỉ có ứng dụng đôi chút trong khi những thứ không giải thích được rất nhiều.\r\n\r\nCâu trả lời đúng của \"tại sao như thế\" là:\r\n\r\n**Vì người Anh thích như thế.**\r\n\r\nNên nhớ, vì người Anh nói như thế nên mấy quy tắc này được sinh ra, chứ không phải vì có mấy quy tắc này nên người ta phải nói như thế.\r\n\r\nVậy nên đừng hỏi tại sao nữa, vì những gì không thể hỏi tại sao mới là phần lớn của ngôn ngữ, thông qua sinh hoạt qua lịch sử mà hình thành nên chứ không cần lí do nào cả. Nói nhiều thành quen thôi. \r\n\r\nBạn muốn hỏi lí do để có thể nhớ, như những môn học khác, hiểu mới nhớ. Đáng tiếc là ngôn ngữ thì không như vậy. Dùng mới nhớ.\r\n\r\n# thế phải làm gì đây?\r\n\r\n#1. Thích cái gì, đọc cái đó.\r\n\r\nThích bóng đá? Lên web bóng đá, diễn đàn bóng đá, Reddit bóng đá. Thích cây cối chim muông, đọc về cây cối chim muông bằng tiếng anh. Thích khoa học thì đọc wikipedia, các web khoa học. Thích truyện tranh thì lên kissmanga, app naver webtoon. Thích máy tính đọc về máy tính... Thích kinh dị creepy lên tìm trên tumblr hoặc mấy web kinh dị. Thích xem thiên hạ chém gió lên đọc comment trên những video youtube bạn thích. \r\n\r\nNhiều người hỏi khó lắm biết gì đâu mà đọc.  Khó quá có thể đọc truyện tranh, mẩu tin ngắn thay vì dài. Dần dần nâng cao lên.\r\n\r\n\r\n#2. Bỏ hết phụ đề việt đi, xem phụ đề anh\r\n\r\nPhim là thứ mà 100% nhân loại đều thích. Tại sao không tận dụng. Đừng kêu không hiểu nữa. Không hiểu nhiều thì hiểu ít. Không hiểu thì biết cách phát âm. Không hiểu thì pause lại tra từ. Không hiểu thì ghi ra để sau này hiểu. Không hiểu thì bật song song 2 loại phụ đề việt-anh lên. \r\n\r\nHi sinh \"không hiểu\" vài bộ phim để học tiếng anh cũng có làm sao nhỉ?\r\n\r\nCó những phim còn sử dụng tiếng Nhật - một ngôn ngữ mà khó hơn cả tiếng anh nữa mà mọi người vẫn hiểu vẫn xem ầm ầm đó thôi.\r\n\r\nNgoài ra thì xem phim Nhật, phim Hàn, phim Thái, phim Việt...phụ đề Anh cũng có tác dụng nhé. Dù không bổ sung được phần nghe nói nhưng có tác dụng đọc hiểu.\r\n\r\nXem ở đâu?\r\n\r\n* down về rồi dùng phần mềm như KMPLayer ghép 2 phụ đề song song Anh-Việt vào xem. down phim bằng torrent ở [Vịnh cướp biển](https://thepiratebay.org/), down phụ đề tv series ở [Addic7ed](http://quitestupid.com/), phụ đề phim lẻ ở [Subscene](https://subscene.com/browse/latest/film/1)\r\n* xem online ở [HD Việt](http://movies.hdviet.com/) hoặc [HD Online](http://hdonline.vn/) có sẵn phụ đề Anh và việt nhưng hay die link, nhiều quảng cáo. Được cái đỡ phải down. Hoặc [Study Phim](http://www.studyphim.vn/) ngoài phụ đề trong video còn ghi thêm phụ đề rõ ràng ra bên cạnh và dịch luôn, tua phim bằng phụ đề,... hơi ít phim và hình như có hạn chế số lượng xem hàng ngày... mình không nhớ\r\n* xem online trong ứng dụng [Terrarium TV](https://terrariumtvappdownloads.com/) hoặc [Popcorn Time](https://popcorn-time.to/) chủ yếu là phụ đề tiếng anh, kho phim đồ sộ phim gì cũng có.\r\n\r\n\r\n\r\n# 3. Chơi game server nước ngoài, tìm chém gió với người chơi ở mỹ, anh, xem stream...\r\n\r\nMòe không chơi nên không biết là cụ thể game gì và server nào để mà nói, nhưng muốn tìm có lẽ không khó. Bạn mòe học tiếng anh từ Dota cho rằng Dota là một trong những game hỗ trợ \"chat chit nói chuyện\" tốt nhất.\r\n\r\nNgoài ra có thể xem stream chơi game của bọn nói tiếng anh, hoặc xem mấy cái video clip chế lại từ game, có phụ đề tiếng anh nhưng nói tiếng việt, hoặc nói bằng tiếng anh đều được. Khi xem nhớ ghi chú lại **từ mới, câu nói** những gì cảm thấy sau này cần dùng\r\n\r\n# 4. Từ nay đừng google với từ khóa tiếng việt nữa\r\n\r\nbất kể là cái gì đừng tìm bằng tiếng việt nữa. Tập tìm bằng tiếng anh. Nếu không biết từ khóa là gì thì tra từ điển cái từ khóa rồi dùng từ khóa để tra lại google. Đọc kết quả bằng tiếng anh. Cái này đặc biệt công hiệu vì đã tìm nghĩa là bạn quan tâm. Quan tâm thì sẽ tập trung. Tập trung thì nhớ nhanh + nhớ lâu.\r\n\r\n# 5. Giao lưu kết bạn trò chuyện chém gió chat chit với người việt giỏi tiếng anh hoặc người anh mĩ\r\n\r\nỞ đâu à?\r\n\r\n[discord.me](https://discord.me/) lên đây join vào cái server nào đông hoặc gõ từ khóa vào tìm kiếm server nào ưng ý mình. Discord là một platform chat text + voice **RẤT ĐÔNG**, vô cùng rộng lớn, khắp trên thế giới, đủ mọi chủ đề, không tìm được cạ ở đây thì chắc cũng chẳng còn chỗ nào dễ tìm hơn thế cả.\r\n\r\nMòe thì hay nằm ở server [Programmer's Hangout](https://discord.me/coding) vì hay lên đây hỏi về lập trình, mấy người ở đây vừa năng nổ giúp đỡ vừa có tính cách hay, thoải mái. Hôm bữa chui vào voice room cả nhóm đang nói chuyện thì có ông tự kỉ ngồi chơi piano theo chủ đề câu chuyện. Ví dụ khi Mòe nói tới cài win thì ổng chơi piano luôn bản nhạc khởi động windows,... nói tới phim thì ổng đánh luôn nhạc nền phim đó :smile: Nhiều người dị mà dễ thương thật.\r\n\r\nAi mà hay troll thì **đừng** vào Programmer's Hangout mà hãy vào 2 cái này: [Daddy](https://discord.me/daddy69) và [GayDayz](https://discord.me/gaydayz) cực kì đông đúc và tấp nập, ở đây hầu như lúc nào cũng có người nói chuyện trên các voice room để mà hóng. Cái GayDayz tên Gay nhưng trong này đủ thứ mà thẳng còn nhiều hơn gay. Cái Daddy thì nghe tên daddy69 có vẻ không trong sáng cho lắm. Nói chung 2 server này đủ loại người, tốt xấu có cả. Có lúc thì gặp những người rất lịch sự có lúc thì đùa bậy. Không thuần như Programmer's Hangout nên moè chủ yếu lui tới Programmer's Hangout và một số server của bạn bè mòe thôi. Tốt nhất mỗi người nên tự tìm lấy đám đông mà mình cảm thấy phù hợp.\r\n\r\n\r\nAi kêu không hiểu không biết nói gì, cái gì cũng phải từ từ và bền bỉ. Không biết thì tra, không biết thì hỏi.\r\n\r\nCó cái server này của người việt nói tiếng anh và dạy tiếng việt cho người nước ngoài [Learn Vietnamese-English](https://discord.me/learn_vietnamese) có thể vào đây nếu cảm thấy muốn nói tiếng anh với người việt.\r\n\r\nNgoài discord ra còn có [Xat](https://xat.com/) cũng rất nhiều room đủ thể loại nhưng trên này trẻ trâu là nhiều. \r\n\r\nVà [IRC](https://en.wikipedia.org/wiki/Internet_Relay_Chat) là một mạng lưới còn đông gấp vạn lần discord và Xat, quả nhiều server, nhưng không có một bóng dáng việt nam nào và chỉ hỗ trợ text chat, nhưng dân lập trình chắc sẽ thích vì nó sử dụng giao thức IRC, phải cài client để sử dụng được triệt để và khi đăng nhập phải nhập port number các thứ,...đem lại cảm giác bí hiểm. \r\n\r\nNgoài ra hầu như các **phần mềm, hệ điều hành nổi tiếng** đều có 1 kênh IRC chính thức. Mòe hay lui tới server của [Linux Mint](https://community.linuxmint.com/tutorial/view/12). Có server của [Python](https://www.python.org/community/irc/), của [Mozilla](https://wiki.mozilla.org/IRC), [Ubuntu](https://wiki.ubuntu.com/IRC/ChannelList), [Fedora](https://fedoraproject.org/wiki/IRC), [GNU](https://www.gnu.org/server/irc-rules.en.html), [Open Stack](https://wiki.openstack.org/wiki/IRC), [Twitch](https://help.twitch.tv/customer/portal/articles/1302780-twitch-irc)...\r\n\r\n# 6. Phải thật lì\r\nKhông được sợ hãi, sợ sai. Mấy đứa bảng cửu chương còn không thuộc nó vẫn google translate để tán trai tây kiếm thẻ xanh ầm ầm kìa, các lập trình viên thông minh có gì phải sợ? Nếu bị người khác sửa lỗi đừng cáu kỉnh hay tự ti vì ai giỏi cũng đã từng ngu. Đau mới thấm.\r\n\r\n# 7. Nói còn châm chước, nhưng viết thì phải cẩn thận và có trách nhiệm với những gì mình viết ra\r\n\r\nCó những lỗi sai cơ bản rất đơn giản và không yêu cầu cao siêu gì thì tránh mắc. Khi viết nói chuyện với người khác hay ngay cả viết linh tinh lên facebook cũng phải tự soát lỗi để tránh thành thói quen xấu khó bỏ. Học hành từ mới cấu trúc... đao to búa lớn làm gì khi mà chính những thứ nhỏ nhặt mới là thứ thể hiện trình độ của bạn:\r\n* yesterday i go toilet 6 time a day\r\n* she like me\r\n* but i only want love man\r\n\r\nCái gì mà bạn không dám đảm bảo là đúng (chưa viết quen, chưa kiểm nghiệm) thì google xem **viết như thế là đúng hay sai**, bỏ từ khóa trong ngoặc kép . Nếu thấy **không** ai hoặc **ít** ai nói thế mà toàn người linh tinh kiểu comment/tên nick chứ không có kết quả nào từ **bài báo chính thức** tức là sai rồi viết lại thôi.\r\n\r\n\r\n# 8. Khi đọc, xem, nói chuyện... lưu ý lại hoặc ghi chú lại những gì mà đoán là sau này cần\r\n\r\nmột cụm từ, một câu nói, một thứ mà bạn nghĩ bạn sẽ dùng, một thứ bạn luôn muốn tìm cách diễn đạt mà lâu nay không biết giờ mới thấy, hay thứ mà bạn nghĩ khác bây giờ mới biết mình sai... sẽ trôi qua ngay nếu không tìm cách lưu lại để mở ra ôn lại.\r\n\r\n# 9. Đọc sách tiếng anh\r\n\r\nAi mà tiếng anh mức trung bình trở lên có thể tìm đọc sách tiếng anh. Sách giấy hoặc sách điện tử. Mòe hay đọc sách điện tử vì dễ kiếm hơn là sách giấy và còn có thể tra ngay trong khi đọc bằng cách nhấn giữ vào từ.\r\n\r\nCó thể mua Kindle hoặc tải app đọc sách như [Moon Reader](https://play.google.com/store/apps/details?id=com.flyersoft.moonreader\u0026hl=en), [FB Reader](https://play.google.com/store/apps/details?id=org.geometerplus.zlibrary.ui.android) để đọc file prc, file epub... Dùng kèm với từ điển [MSP Dict](https://drive.google.com/open?id=1g0AxoRyR09Q1dQqFSRiewfDiA84K-be8) để hỗ trợ tra từ bằng nhấn chuột trong khi đọc\r\n\r\nSách thì down trên [Gen Lib](http://gen.lib.rus.ec/) trên này trừ sách mới xuất bản vài tháng, còn đâu thì sách gì cũng có. Hoặc trang của việt nam là [TVE-4U](http://tve-4u.org/) cũng nhiều.\r\n\r\n(nhớ khi nào có điều kiện hãy mua sách giấy hoặc donate để ủng hộ tác giả)\r\n\r\n\r\n----------\r\n\r\n\r\nAi còn gì hay hãy cùng chia sẻ link để mọi người cùng biết nhóe!"
                }, {
                "id": "537j8nGW8FO82AquyWvoTA",
                "title": "Nhat hay Lieu ? Wimpy or Supermannish?",
                "content": "Thu Nhat: Toi muon bien bai blog nay bang tieng Viet, nhung toi khong co du chu chu dong...Eh uh then in English. Noboby wants to be beholden as a wimp. But as a superman? Eh..uh...\r\n\r\nAn Indian English word \"fresher\" is somehow natutalized by Vietnamese. And I dislike this word. Not because it's Indian English but it is WRONG in good English. It suggests an university student of the **FIRST** year, **not a graduate**. Freshers...NO, \"fresh\" graduates always face the toughest question of life: \"How to get a **good** job?\"\r\n\r\nThe answer is usually dubious. Asking around is never a good idea. The reason is simple: nobody likes to bear the responsibility for the future failure of the young man or young woman. Hence the advice is more or less generic -or in other word: useless. The \"freshers\" learned a lot in the university (Latin: universus and it means an Entity or a Wholeness. In Vietnamese Dai Hoc = **Great Learning**). But they didn't learn how to jump into the working world. No, to be more precise: they weren't taught how to prepare themselves before leaving the friendly, nice campus and plunging into a dangerous shark tank. **Shark tank**? Yes. It's about life or death. Full of deceptions and lies.\r\n\r\n![ALT](https://www.impactbnd.com/hubfs/8_Marketing__Sales_Lessons_Ive_Learned_from_Watching_Shark_Tank-2.jpg?t=1525703467692)\r\n\r\nThe newbies are easy meat for the Headhunters (HH) and Human Resource managers (HRM). They are stooges of the men and women in the shadow called \"Bosses\". If the men and women in the shadow (MaWiS) really concern about their company they have, emphasize HAVE, to interview the applicants personally. It's **about their company**, isn't it? One lets his \"property\" administer by a stranger (HH or HRM) only when one wants quick money before one scuds incognito to the Bahamas or Monaco.\r\n\r\nHH and HRM task is to hunt the **best meat** at the lowest cost for the MaWiS. Because, they -the HH and HRM- have nothing to do than day in, day out to sharpen their only tool: grill the newbies, to barbecue them as deli for the bosses: best brains for some meager dollars. Hence they've learned by heart a lot of buzzwords: **SQL-AI-ML-DM-DS-NodeJS-SPRING MVC-Angular-PYTHON-Android-iOS-Bla..bla...**\r\n\r\nAnd if you think that they're \"really\" experts of that what they \"palaver\" then you err tremendously. They are solely the modern Eunuchs who just talk loudly about Making-Love without being able to perform such a thing that they talk about. And if you believe them you become their easy meat.\r\n\r\nIn case that you confront such a loudmouth I recommend you to use your trained \"Great Learning\" to counter his/her buzzwords with your own buzzwords (e.g. \"You certainly know that **CP** -stands for Concurrent Programming- can solve a lot of **BN** -stands for Bottleneck- IT problems, don't you?\". What IT problems, what CP/BN you naturally won't tell him or her, right?).\r\n\r\nNow what? The youngsters who mastered the \"Great Learning\" behave helpless and act awkwardly like some bad-oiled-bad-developed humanoids. Easy meat. Their parents duck. Their governement ducks. All duck. The newbies start to duck, too. What a shame!\r\n\r\n\"it walks like a duck\r\n it quacks like a duck\r\n it looks like a duck\r\n it must be a duck\"\r\n\r\nThe newbies become the ducks- **Peking ducks** for HH and HRM and the  MaWiS.\r\n\r\n![ALT](http://www0.f1online.de/preW/002943000/2943901.jpg)\r\n\r\nI ask myself why won't you behave like your western counterparts and take the initiative into your own hands? Be independent, be more confident (because you have finished the \"Great Learning\") and work out what you have trained for during the \"Great Learning\": global thinking, systematic planning and schematic acting. All that is what the **Dai Hoc** is purposed and prepared for.\r\n\r\nLet start with the CV. Curriculum Vitae - a brief and concise reflection of your life. Brief means short, concise means short-and-precise. A brief and concise CV should be drafted carefully and precisely about oneself, not a verbose biography. The reason is simple: YOU are not the only one who apllies for the job. There're probably hundreds or thousands. Also hundreds or thousands of CV pile up in front of a HH or HRM. He/she has no time for every CV. So, his/her reaction is foreseeable: throw the long CV away, look briefly on the concise CV. Long CV goes straight to the basket.\r\n\r\nThe CV must be **precise and concise**: It should consist of: \r\n\r\nPresonal\r\n- name, \r\n- address\r\n- email and phone\r\n\r\nEducations\r\n- school (name, years)\r\n- college (name, years)\r\n- university (name, years)\r\n- final certificate (with note).\r\n\r\nKnowledge\r\n- IT (e.g. C/C++, JAVA, etc.)\r\n- DB (e.g. SQL)\r\n- advanced (Machine Learning, Big Data, etc.)\r\n\r\nExperience\r\n- training (short description)\r\n- project in the school/college/university (short description)\r\n\r\nDon't be too naive and expose your religion (HH or HRM may against your religion), your family status (single, married, divorced because HH or HRM can draw some negative conclusion about your living status) and your hobby (which could tell HH/HRM that you a lone wolf).\r\n\r\nLife awards only those who have courage and dare to take initiative into their own hands. Everyone sends his application to the company where (s)he want to apply and waits for weeks for an answer. Why you do the same? Why don't you put your CV and papers in a map and go straight to the company and demand to **talk** directly with the Boss (or HRM)? Surprise is the mother of every success -in the battlefield or in a workplace. Twenty Plus years ago I went to SUN and demanded to meet Scott McNealy and got the job without having to go thru the tedious filter of HRM and HH.\r\n\r\nMy only advice: Freshers, eh NO. \"Newbies\", be independent, be confident, be self-assured. Take initiative into your own hands and do what you want to do. Don't let the other interfere your approach. Think about your long future. It's yours, and believe me: the HH or HRM never care about what you do or suffer. And the MaWiS reap the fruits from your sweaty work...and become rich, very rich, filthy rich like Bill Gates or Mark Zuckerberg..."
                }, {
                "id": "j3kuY8yPZguxoLBXxpk72A",
                "title": "Elixir/Erlang, Actor model và Concurrency",
                "content": "Bạn nghe phong thanh người ta nói Elixir chạy nhanh hơn Ruby? Bạn muốn biết làm sao để Whatsapp phục vụ 900 triệu người dùng với chỉ 50 engineers? Vào đọc bài viết này nhé?\n\n---\n\nBài viết khá dài, nhưng túm cái váy lại là bao gồm ba phần:\n\n* Concurrency và mô hình Thread-Lock.\n* Giới thiệu về mô hình Actors (Actors model).\n* Giới thiệu về Elixir/Erlang.\n\nNhưng trước hết hãy cùng tui đọc qua bài toán nổi tiếng: **Bài toán điểm danh của lớp 1A**.\n\n## Bài toán điểm danh\n\nLớp 1A có 50 bé học sinh. Cứ mỗi đầu buổi học, lớp đều điểm danh bằng cách cho **lần lượt** từng bé sẽ ghi tên vào một cuốn tập theo thứ tự ABC.\n\n![pic-1][pic-1]\n\nBài toán điểm danh của lớp 1A có thể được biểu diễn bằng đoạn mã giả như sau:\n\n```ruby\nclass Student\n  def initialize(name)\n    @name = name\n  end\n\n  def roll_call(notebook)\n    notebook.write(@name)\n  end\nend\n\nclass ClassRoom\n  def initialize(students, notebook)\n    @students = students\n    @notebook = notebook\n  end\n\n  def start()\n    @students.each do |student|\n      student.roll_call(@notebook)\n    end\n  end\nend\n```\n\nSẽ không có gì phải lăn tăn nếu học sinh cứ ghi vào cuốn tập **tuần tự**. Nhưng trong thực tế thì không phải học sinh nào cũng đến lớp đúng giờ, ta không thể vì bé Quần Cam tới trễ 30 phút mà bắt tất cả học sinh phía sau cũng phải chờ 30 phút mới được điểm danh. Cho nên ta phải hỗ trợ điểm danh **bất đồng bộ**: ai tới trước điểm danh trước, tới sau điểm danh sau.\n\nVà một cái rẹt, bạn đã văng khỏi thế giới tuần tự để đến với thế giới concurrency!\n\n## Concurrency\n\nKhi nói đến concurrency, ta nói về khả năng các phần khác nhau trong ứng dụng có thể được thực thi **không theo một thứ tự nào cả (out-of-order)**, mà vẫn **đảm bảo kết quả cuối cùng**.\n\nVới bài toán điểm danh bất đồng bộ ở trên, ta có thể viết lại ứng dụng với một đoạn mã giả như bên dưới, bằng cách quăng thao tác điểm danh vào một thread, như khi không người ta vẫn dạy lập trình đa luồng (multithreaded programming) ở trường. Khi một học sinh chưa đến lớp (biến `@is_here` chưa được bật), thread của bé ấy sẽ ngủ 10 giây, nhả lại quyền thực thi cho thread khác.\n\n```ruby\nclass Student\n  def initialize(name, is_here)\n    @name = name\n    @is_here = is_here\n  end\n\n  def roll_call(notebook)\n    if @is_here\n      notebook.write(@name)\n      true\n    else\n      sleep(10)\n      @is_here = true\n      roll_call(notebook)\n    end\n  end\nend\n\nclass ClassRoom\n  def start()\n    @students.each do |student|\n      Thread.new do\n        student.roll_call(@notebook)\n      end\n    end\n  end\nend\n```\n\n### Thread and lock\n\nBây giờ _hãy tưởng tượng_ với đoạn code trên, bé nào trong lớp 1A cũng có thể ghi vào cuốn tập bất kì lúc nào. Mặc dù 50 học sinh chụm đầu để ghi vào cuốn tập thì hơi phi lý thật, nhưng hãy ngưng khó tính và chấp nhận đi. Sau một thời gian bạn sẽ thấy cuốn tập điểm danh trở nên rối loạn như 12 sứ quân.\n\n```\nQuầ\nQuầnn Cam Quần Đùi\nChíp\nQuần Sọt\n```\n\nVì sao lại có tình trạng như vậy? Bởi vì Quần Cam, Quần Chíp và Quần Đùi ghi vào cuốn tập tại **cùng một thời điểm**. Khi Quần Chíp vừa viết được chữ \"Quầ\" thì tới lượt Quần Cam chiếm được quyền ghi, thành thử ra nội dụng cuốn tập trở nên lộn xộn không ra cái thể thống gì cả.\n\nTa rút ra được một bài học: [concurrency phải có control][concurrency-control].\n\nĐể giải quyết vấn đề này, cô giáo đưa ra một luật: chỉ **một bé được viết vào cuốn tập trong cùng một thời điểm**. Trong multithreaded programming, luật đó có thể được hiện thực bằng lock/mutex:\n\n```ruby\nclass ClassRoom\n  def start()\n    notebook_semaphore = Mutex.new\n\n    @students.each do |student|\n      Thread.new do\n        notebook_semaphore.synchronize do\n          student.roll_call(@notebook)\n        end\n      end\n    end\n  end\nend\n```\n\n`notebook_semaphore` sẽ đảm bảo tại một thời điểm chỉ có một học sinh có thể ghi vào notebook, khi nó ghi xong sẽ trả lại resource cho bé kế tiếp.\n\nĐây là giải thích sơ khởi nhất cho mô hình **Thread and lock**, một mô hình rất cơ bản và cấp thấp mà hầu như ngôn ngữ nào cũng hỗ trợ. Ở đây **50 học sinh là các concurrency unit (thread)** và **cuốn tập là shared resource**. Khi một thread cần sử dụng shared resource, nó sẽ lập tức chiếm hữu resource đó để chắc chắn nó là người duy nhất được đụng vào. Mặt khác, một thread nhăm nhe giở trò sở khanh một resource đã bị lock sẽ phải chờ cho đến khi thread khác trả lại resource.\n\nDùng thread và lock sẽ **sát máy** (close-to-metal) và **hiệu quả** nếu dùng đúng. Xin nhắc lại: nếu dùng đúng. Nhưng cân nhắc là rất khó để bạn điều khiển locks đúng và hợp lý. Ví dụ đơn giản của tui với chỉ một resource là \"cuốn tập\" có thể không giúp bạn thấy được độ khó việc điều khiển lock. Nhưng với hai hoặc nhiều resource hơn, bạn sẽ thấy mô hình này có một số hạn chế nhất định: điển hình là dễ xảy ra deadlock.\n\n### Deadlock\n\nDeadlock là nỗi ám ảnh của mọi lập trình viên. Nó là trạng thái **mãi chờ nhau** của hai hoặc nhiều process khi truy cập tài nguyên. Khi một thread tìm cách giữ nhiều hơn 2 resource, khả năng deadlock xảy ra là rất cao nếu như ta không đủ kinh nghiệm xử lý lock.\n\nGiả sử với lớp 1A ở trên, tui sẽ tăng độ khó của bài toán lên một chút bằng ... một cây viết. Một học sinh khi vào lớp sẽ có 2 khả năng xảy ra: tìm cây viết hoặc tìm cuốn tập để điểm danh. Để tui mô phỏng bài toán này cho bạn bằng một đoạn code nhỏ như sau:\n\n```ruby\nclass ClassRoom\n  def start()\n    notebook_semaphore = Mutex.new\n    pen_semaphore = Mutex.new\n\n    @students.each do |student|\n      Thread.new do\n        # Let's shuffle because we don't know if the student would look for\n        # the pen first or the notebook first.\n        [notebook_semaphore, pen_semaphore].shuffle.each do |semaphore|\n          semaphore.synchronize do\n            student.roll_call(@notebook)\n          end\n        end\n      end\n    end\n  end\nend\n```\n\nSau một thời gian, sẽ có bé nào đó giữ cây viết và mãi đi tìm cuốn tập, còn bé đang giữ cuốn tập thì băn khoăn rằng cây viết nằm ở đâu, còn các bé khác thì mải mê chờ hai bé ở trên trong vô vọng.\n\n![concurrency-deadlock][pic-deadlock]\n\n## Actors model\n\nTưởng tượng có một cuộc cách mạng về điểm danh xảy ra ở lớp 1A, học sinh trong lớp không còn điểm danh bằng cách tự viết vào cuốn tập nữa mà lớp trưởng sẽ thay các bé làm chuyện đó. Cách làm là như sau:\n\n* Khi một học sinh tới lớp, bé đó sẽ gửi tin nhắn SMS cho lớp trưởng.\n* Lớp trưởng giữ cả viết lẫn cuốn tập.\n* Khi nhận được SMS, lớp trưởng sẽ ghi tên học sinh đó vào cuốn tập.\n* Mỗi lượt lớp trưởng chỉ đọc và xử lý một tin nhắn.\n* Lúc hộp thư trống, lớp trưởng ngồi chơi.\n* Khi cô giáo cần danh sách có mặt, cô cũng sẽ gửi SMS cho lớp trưởng, rồi lớp trưởng sẽ gửi lại danh sách cho cô cũng qua tin nhắn SMS.\n\n![concurrency-actor-model][pic-actor-model]\n\nMô hình này gọi là **Actors model**. Với mô hình như vậy, việc ghi/đọc điểm danh của lớp 1A trở nên cực kì đơn giản và trực quan:\n\n* Mỗi thành viên trong lớp là một actor trong hệ thống và có **một cái mailbox**. Khi họ muốn trao đổi gì với nhau, họ gửi tin nhắn vào mailbox của đối phương.\n* Viết và tập giờ trở thành _tài sản riêng_ (private state) của riêng lớp trưởng. **KHÔNG** ai được phép đọc/ghi vào private state của người khác. Từ đó, lock trở nên thừa thải.\n\n### Actor\n\nActor là một đơn vị chính của mô hình Actor model và đảm nhận mọi thao tác tính toán trong mô hình này. Các đặc điểm chính của actors bao gồm:\n\n* **message passing** - các actor trao đổi với nhau bằng cách **gửi message vào mailbox** của nhau. Bạn muốn bảo một actor làm gì cho bạn: _gửi message cho nó_. Bạn muốn giết một actor: _gửi message cho nó_. Bạn muốn truy cập thông tin một actor: _gửi message cho nó rồi check mailbox_.\n* **never share memory** - mỗi actor có một state riêng mà **không** có actor nào có thể truy cập hay thay đổi được.\n* there are **many actors** - Actor là thứ sống theo bầy đàn. Trong mô hình này, tất cả đều là actor hoặc không có một actor nào cả. Đồng thời actor được định danh (giống như bạn được cha mẹ bạn cấp cho cái tên), tui sẽ nói rõ hơn về cái này trong phần tiếp theo.\n* **asynchronous** - mọi message đều là bất đồng bộ, tức là lúc bạn bấm gửi và lúc nào nó tới là hai chuyện khác nhau.\n\nKhi nhận được một message, actor sẽ phải băn khoăn với 3 lựa chọn:\n\n* Xử lý thông tin và update state của nó.\n* Tạo thêm các actor khác.\n* Gửi message cho một actor khác.\n\n### Mailbox\n\nTuy rằng hệ thống có rất nhiều actors, nhưng trong **nội bộ actor mọi thao tác đều là tuần tự**. Điều đó có nghĩa là cho dù bạn gửi 10 tin nhắn tới cùng một actor, nó sẽ chỉ sẽ xử lý 1 message cùng lúc. Cách duy nhất để bạn có thể xử lý đồng thời 10 message là tạo ra 10 actor, rồi chia 10 message đó ra cho từng actor.\n\n## Elixir\n\nElixir là ngôn ngữ chạy trên nền tảng của Erlang VM, thứ đã khiến mô hình Actor trở nên thịnh hành. Về mặt ngôn ngữ thì Erlang không có gì quá nổi bật nếu không muốn nói là cú pháp nhìn mắc ói, rất nhiều boilerplate và stdlib rối tung chảo (điều đó đã được giải quyết với Elixir), nhưng sức mạnh của nó nằm ở OTP, framework được ship cùng với ngôn ngữ để giúp bạn build một hệ thống **concurrent, distributed và fault-tolerant**.\n\n### Concurrent\n\nActor trong Erlang được gọi **process**. Là một thực thể của mô hình Actor, một Erlang process cũng **tách biệt** với thế giới bên ngoài, **không share memory**, có một **mailbox queue** và dùng nó để **trao đổi message** với các process khác.\n\nErlang process có **memory footprint rất nhỏ**, khoảng 2KB - 4KB tùy OS. Chúng có thể được khởi tạo (spawn) hay tắt đi (exit) rất nhanh và không làm ảnh hưởng tới performance của hệ thống. Bởi thế người ta hay chém là Erlang VM có khả năng spawn được 134 triệu process.\n\nGiống như các ngôn ngữ dynamic typed khác, Erlang có garbage collection (GC), nhưng mỗi process có một GC riêng. Nó giúp cho việc dọn rác trong Erlang VM **không** như anh QuickSilver (khi tui chạy cả thế giới như đứng lại), GC của Erlang **không stop the world**.\n\nProcess trong Erlang được định thời bởi Erlang VM scheduler. Scheduler này sẽ chỉ định xem process nào được chạy và process nào không. Đồng thời Erlang scheduler là **preemptive**, đảm bảo không process nào được phép chạy mãi mãi. Điều này giúp cân bằng thời gian thực thi giữa các task, không có process nào chiếm dụng CPU quá lâu, kể cả regular expression. Tuy vậy một mặt khác nó cũng sinh ra overhead, nhưng mà vì bài này tui đang nâng bi Elixir, nên tui không đi sâu vào phần đó đâu.\n\nĐể start một process trong Erlang, bạn có thể dùng hàm `spawn`:\n\n```elixir\ndef start() do\n  spawn(fn -\u003e roll_call() end)\nend\n```\n\nChắc đọc tới khúc này sẽ có bạn đặt câu hỏi: _Ôi vậy thì khác gì thread nhỉ?_. Tui sẽ chửi thầm trong bụng: :face_palm:, _Ơ, vậy nãy giờ ba đang đọc gì vậy?_. Nhưng ngoài mặt tui sẽ bảo bạn là câu hỏi rất hay, hãy đọc tiếp bên dưới nhé.\n\n#### Spawn\n\nSpawn là bạn tạo ra một process, rồi mặc kệ nó.\n\n![pic-spawn][pic-spawn]\n\nĐể gửi một tin nhắn tới cho process đã được spawn, bạn có thể dùng hàm `send/2`.\n\n```elixir\nchip = spawn(fn -\u003e\n  receive do\n    :yo -\u003e\n      IO.puts(\"Why call me? Now I die.\")\n      exit(:shutdown)\n  end\nend)\n#PID\u003c0.92.0\u003e\n\niex\u003e send(chip, :yo)\nWhy call me? Now I die.\n:yo\n\niex\u003e send(chip, :yo)\n:yo\n```\n\n\u003e CTBDB;CTBCB;CTBDBMGBCB: `receive` là hàm giúp bạn chờ tin nhắn.\n\n\u003e **CTBDB;CTBCB;CTBDBMGBCB:** Có thể bạn đã biết, có thể bạn chưa biết, có thể bạn đã biết mà giả bộ chưa biết.\n\n#### Spawn and Link\n\n![pic-spawn-link][pic-spawn-link]\n\nKhi bạn spawn và link hai process lại với nhau, khi một process nào đó tự nhiên lăn đùng ra chết, process kia sẽ nhận được tin nhắn báo tử.\n\n```elixir\nchip = spawn(fn -\u003e\n  receive do\n    :yo -\u003e\n      IO.puts(\"Why call me? Now I die.\")\n      Process.exit(self(), :suicide)\n  end\nend)\n\ndefmodule Cam do\n  def start() do\n    spawn(__MODULE__, :loop, [])\n  end\n\n  def loop() do\n    Process.flag(:trap_exit, true)\n\n    receive do\n      {:yo, pid} -\u003e\n        Process.link(pid)\n        send(pid, :yo)\n        loop()\n\n      {:EXIT, from, reason} -\u003e\n        IO.inspect(\"Process #{inspect(from)} is dead :cry:, reason: #{inspect(reason)}\")\n    end\n  end\nend\n\ncam = Cam.start()\n\nsend(cam, {:yo, chip})\nProcess #PID\u003c0.31209.11\u003e is dead :cry:, reason: :suicide\n```\n\n![pic-trap-exit][pic-trap-exit]\n\n### Fault tolerance\n\n`spawn`, `link`, và `send` chính là những thành phần cơ bản giúp OTP build Supervisor. Với Supervisor, việc handle lỗi và giữ cho hệ thống luôn sẵn dùng trở nên thật dễ dàng và hiệu quả.\n\nTrong Erlang có một triết lý là **\"Let It Crash\"**. Bạn không cần phải lập trình ứng dụng theo cách \"cố thủ\", kiểu như phải nghĩ cho ra mọi thứ lỗi có thể xảy ra khi hệ thống chạy và tìm cách xử lý tất cả chúng, bởi vì đơn giản điều đó là không thể. Thay vào đó, hãy dùng Supervisor để **quản lý process** của bạn và để nó **quyết định làm gì khi process bị crash**.\n\n![pic-supervisor][pic-supervisor]\n\nĐó là cách để bạn xây dựng một hệ thống **\"tự phục hồi\"**. Một process có thể crash vì vô vàn lý do (API down, external service tạm thời không truy cập được, network partition), lúc đó supervisor sẽ **hồi sinh và khởi tạo** lại state cho nó, từ đó đảm bảo uptime cho ứng dụng của bạn. Joe Armstrong, đồng tác giả của Erlang, nói rằng có service dùng Erlang đã đạt uptime là Nine Nines, 99.999999999% trong vòng 20 năm, tức là 0.63s downtime trong vòng 20 năm. Đệch, ông chém vừa thôi ông Quần Cam, cơ mà [link đây][erlang-nine-nines].\n\nTui thích ví von là process của Erlang giống như các tế bào ung thư vậy, chỉ có nước bạn tắt luôn cái máy, bằng không thì chúng nó lại sinh sôi nảy nở, cứ như đống cỏ dại mùa hè vậy.\n\n### Distributed\n\nMột trong những đặc điểm thú vị khác của Elixir/Erlang là nó hỗ trợ **phân tán ứng dụng** (distributed applications) ngay từ bên trong ngôn ngữ.\n\nVà khi bạn start một ứng dụng Elixir, thật sự là bạn start máy ảo, và máy ảo có thể tạo cho bạn một **virtual node**. Một cái máy ảo có thể hỗ trợ nhiều virtual node trong cùng một máy, đồng thời một máy có thể connect tới nhiều máy khác, giao tiếp với nhau thông qua giao thức TCP và magic cookies. Cùng với nhau, chúng tạo thành một tập đoàn cứ điểm Điện Biên Phủ và đông như quân Nguyên khắp cụm máy chủ (cluster) của bạn.\n\nBên cạnh việc phân tán ứng dụng, **lập trình phân tán** (distributed programming) cũng được Erlang hỗ trợ khá tận răng. Hãy tưởng tượng trên cương vị lập trình viên, khi bạn đang gửi tin nhắn tới một process đích đến, việc process đó nằm cùng máy hay khác máy không thật sự quan trọng, miễn là tin nhắn tới đúng đích. Đi đường nào cũng được, miễn là tới.\n\nCùng tui kinh qua ví dụ nhỏ sau đây để thấy distributed programming đơn giản như thế nào với Elixir. Hãy bật terminal lên và chạy các lệnh sau:\n\n```\nrrm -rf           # Ahihi\niex --sname teo   # Now you have node \"teo@localhost\".\niex --sname tung  # Now you also node \"tung@localhost\".\n```\n\nỞ node \"teo\", bạn có thể spawn ra một process, và đăng ký cho nó một cái tên.\n\n```elixir\ncam = spawn(fn -\u003e\n  receive do\n    {:yo, from} -\u003e IO.puts \"got message from #{from}\"\n  end\nend)\n\nProcess.register(cam, Cam)\n```\n\nVà bây giờ ở node \"tung\", bạn có thể gửi message cho `Cam` ở node \"teo\".\n\n```elixir\nsend({Cam, :\"teo@localhost\"}, {:ok, Node.self()})\n```\n\n```\niex(teo@Cams-MacBook-Pro-3)2\u003e Process.register(cam, Cam)\ntrue\ngot message from tung@localhost\n```\n\n### Parallelism\n\nTrước hết, tui cần nói rõ là **Concurrency != Parallelism**.\n\nConcurrency là **làm việc** với nhiều task cũng lúc.\n\nParallelism là **xử lý** nhiều task cùng lúc.\n\nGiả sử như ở bài toán điểm danh của lớp 1A, đó là bài toán concurrency bởi vì tui chỉ có một cuốn tập và một cây viết. Tui phải vò đầu bứt trán tối ưu hóa thời gian thực hiện việc điểm danh, bằng cách đưa ra luật: *học sinh nào tới trước điểm danh trước*.\n\nNhưng đó sẽ trở thành bài toán parallelism nếu như lớp 1A có 50 cuốn tập và 50 cây viết cho 50 học sinh. Lúc này mỗi người sẽ tự ghi tên vào cuốn tập của mình và mối quan tâm của tui là làm sao để chia 50 cây viết và tập cho 50 bé học sinh.\n\nVới Elixir/Erlang, có khả năng bạn sẽ đạt được parallelism đích thực, bởi Erlang VM có thể bật scheduler tùy theo số nhân CPU mà bạn có. Giả sử bạn có 10 nhân CPU và muốn có 10 scheduler, khả năng cao là bạn sẽ có 10 task chạy **song song** trong cùng một thời điểm.\n\n## Bài viết này sẽ giúp tui tăng lương như thế nào?\n\nBài viết này không giúp bạn tăng lương, cơ mà bài kì này dài quá, tui sẽ tổng kết TL;DR cho các bạn dễ theo dõi.\n\n* Học Elixir.\n* Học Elixir.\n* Học Elixir.\n\n:speak_no_evil:\n\n---\n\nBài viết được đăng lại từ [Blog Quần Cam](https://quan-cam.com/posts/elixir-erlang-actors-model-va-concurrency).\n\n[pic-1]: https://quan-cam.com/assets/images/concurrency-pic-1.png\n[pic-deadlock]: https://quan-cam.com/assets/images/concurrency-deadlock.png\n[pic-actor-model]: https://quan-cam.com/assets/images/concurrency-actor-model.png\n[pic-spawn]: https://quan-cam.com/assets/images/concurrency-spawn.png\n[pic-spawn-link]: https://quan-cam.com/assets/images/concurrency-spawn-link.png\n[pic-trap-exit]: https://quan-cam.com/assets/images/concurrency-trap-exit.png\n[pic-supervisor]: https://quan-cam.com/assets/images/concurrency-supervisor.png\n[abstraction-leak-post]: https://quan-cam.com/posts/ro-ri-abstraction\n[concurrency-control]: https://en.wikipedia.org/wiki/Concurrency_control\n[lmgtfy]: http://lmgtfy.com/?q=h%E1%BB%99i+th%C3%A1nh+%C4%91%E1%BB%A9c+ch%C3%BAa+tr%E1%BB%9Di\n[erlang-nine-nines]: https://stackoverflow.com/questions/8426897/erlangs-99-9999999-nine-nines-reliability"
                }, {
                "id": "dj3BewW-Kwz5d-ZY-n3AgA",
                "title": "Concurrent Programming với Elixir",
                "content": "Mục đích bài viết này để\n1. Giới thiệu về phương pháp lập trình bất đồng bộ với cách tiếp cận khác những ngôn ngữ như Java hoặc C#.\n2. Những bước đầu tiên để viết 1 chương trình chạy bất đồng bộ bằng Elixir\n3. Hi vọng sẽ lôi kéo được thêm người học Elixir :)\n\n# 1. Concurrent Programming\n\nConcurrent Programming hiểu đơn giản là việc lập trình cho phần mềm có thể chia nhỏ tác vụ và chạy đồng thời, độc lập với nhau. Elixir là ngôn ngữ lập trình được viết dựa trên nền tảng ngôn ngữ erlang - ngôn ngữ giải quyết bài toán concurrent trên rất tốt.\n\nNếu trong Java hay C# việc lập trình bất đồng bộ bạn sẽ sữ dụng những phương pháp như Locking, Thread pool, mutex hay là semaphore... thì ở Elixir sẽ cài đặt trên mô hình **Actor model (1)**.\n\nActor là một đơn vị chính của mô hình Actor model và đảm nhận mọi thao tác tính toán trong mô hình này. Các đặc điểm chính của actors bao gồm:\n - message passing - các actor trao đổi với nhau bằng cách gửi message vào mailbox của nhau. Bạn muốn bảo một actor làm gì cho bạn: gửi message cho nó.\n Bạn muốn giết một actor: gửi message cho nó. Bạn muốn truy cập thông tin một actor: gửi message cho nó rồi check mailbox.\n - never share memory - mỗi actor có một state riêng mà không có actor nào có thể truy cập hay thay đổi được.\n - there are many actors - Actor là thứ sống theo bầy đàn. Trong mô hình này, tất cả đều là actor hoặc không có một actor nào cả. Đồng thời actor được định danh (giống như bạn được cha mẹ bạn cấp cho cái tên), tui sẽ nói rõ hơn về cái này trong phần tiếp theo.\n - asynchronous - mọi message đều là bất đồng bộ, tức là lúc bạn bấm gửi và lúc nào nó tới là hai chuyện khác nhau.\n\nKhi nhận được một message, actor sẽ phải băn khoăn với 3 lựa chọn:\n - Xử lý thông tin và update state của nó.\n - Tạo thêm các actor khác.\n - Gửi message cho một actor khác.\n\n\u003e Đoạn này là copy trên Blog Quần Cam vì ảnh giải thích khá dễ hiểu về mô hình này, đọc thêm [tại đây](https://quan-cam.com/posts/elixir-erlang-actors-model-va-concurrency)\n\nCó 1 tính chất trong elixir đó chính là **Immutability** mình xin tạm dịch là tính bất biến. Hãy cùng xem đoạn code dưới đây:\n\n```\narray = [1, 2, 3]\nsquare(array)\nprint(array)\n```\n\nGiả sử hàm `square` sẽ bình phương giá trị từng phần tử trong mảng `array`. Bạn mong đợi kết quả trả về là [1, 4, 9]. Nhưng trong elixir kết quả sẽ trả về là `[1, 2, 3]` trừ khi bạn gán lại kết quả cho biến array như code dưới đây\n\n```\narray = [ 1, 2, 3 ]\narray = square(array)\nprint(array)\n```\n\nTính chất này giúp cho việc lập trình bất đồng bộ đơn giản hơn rất nhiều vì bạn không cần phải lo giá trị của 1 biến bị thay đổi bởi 1 process khác. Đây là 1 tính chất khá thú vị ở Elixir. Nhưng cái gì cũng sẽ có 2 mặt tốt và chưa tốt.\nBạn có thể tìm đọc thêm ở (2).\n\n# 2. Làm quen với Concurrent Programming trong elixir\n\nNói 1 chút về process trong elixir. Process trong elixir khác với process chạy trên máy tính của bạn, nó chạy bên trong máy ảo erlang VM được quản lý trong ứng dụng của bạn. Trung bình 1 node trên chạy trên máy ảo erlang có thể tạo được 134 triệu processes con. Con số khá ấn tượng nhỉ :)\n\nViệc khởi tạo 1 process trong elixir cũng rất đơn giản. Cùng xem ví dụ dưới đây:\n\n```elixir\n# Đoạn code này định nghĩa 1 module trong elixir và code 1 hàm là greet in ra màn\n# hình là \"Hello\"\ndefmodule SpawnBasic do\n  def greet do\n    IO.puts \"Hello\"\n  end\nend\n\n# Đây là cách gọi hàm thông thường\nSpawnBasic.greet\nHello\n:ok\n\n# Còn đây là cách để chạy hàm trên trong 1 process\nspawn(SpawnBasic, :greet, [])\nHello\n#PID\u003c0.42.0\u003e\n```\n\nKết quả trả về của hàm `spawn` là 1 địa chỉ tới process vừa khởi tạo. Tiếp theo chúng ta sẽ đến phần giao tiếp giữa các process với nhau thế nào.\n\nTrong elixir có 2 hàm là **send** dùng để gửi message tới 1 process và hàm **receive** để nhận 1 message từ 1 process khác gọi sang. Thay đổi 1 chút đoạn code trên.\n\n```elixir\ndefmodule Spawn do\n  def greet do\n    # Hàm này sẽ giúp nhận đối số từ bên ngoài\n    receive do\n      # sender là process gọi tới hàm này và msg là tin nhắn được gửi sang\n      {sender, msg} -\u003e\n        # Dùng hàm send để gửi lại cho sender kết quả (*)\n        send sender, { :ok, \"Hello, #{msg}\" }\n    end\n  end\nend\n\n# Khởi tạo process\npid = spawn(Spawn, :greet, [])\n# Gửi tin nhắn tới process đó\nsend pid, {self, \"World!\"}\n# Lắng nghe kết quả trả về\nreceive do\n  # Chổ này sẽ match với giá trị trả về của hàm greet bên trên (*)\n  {:ok, message} -\u003e\n    IO.puts message\nend\n\nOutput:\n\u003e Hello, World!\n```\n\nĐoạn code trên nếu ta tiếp tục gọi thêm 1 message nữa\n```\n...\nsend pid, {self, \"Ahihi!\"}\nreceive do\n  {:ok, message} -\u003e\n    IO.puts message\nend\n\nOutput:\n\u003e Hello, World!\n...stop...\n```\n\nChương trình bị dừng thay vì tiếp tục trả về message là `Hello, Ahihi!`. Do sau khi hàm greet nhận được message thì đã gọi gửi trở lại cho main process và exit khỏi chương trình.\n\n\u003e Giải thích chỗ này 1 chút đó là function trong elixir sẽ trả về kết quả ở dòng  cuối cùng của thân hàm. Trong đoạn code trên hàm greet sẽ trả về pid là kết quả trả về của lời gọi hàm send\n\n**Vậy làm sao để nhận được kết quả mong muốn là `Hello, Ahihi!` ở lần send message thứ 2?**\n\u003e Chúng ta sẽ thay đổi hàm greet để trả về lời gọi hàm chính nó để khi send tiếp tục lắng nghe tin nhắn từ main process\n\n```\ndef greet do\n  receive do\n    {sender, msg} -\u003e\n      send sender, { :ok, \"Hello, #{msg}\" }\n      greet\n  end\nend\n\nOutput:\n\u003e Hello, World!\n\u003e Hello, Ahihi!\n```\n\n**Đoạn code này trong giống đệ quy phải không?**\n\u003e Đúng rồi, đây là đệ quy trong elixir\n\nNếu trong những ngôn ngữ khác như Java thì khi gọi đệ quy tức là bạn push 1 frame vào stack và nếu bị gọi với số lượng lớn nó sẽ bị out of memory. Vấn đề này được giải quyết bằng kĩ thuật `tail-call optimization` có thể hiểu là nếu như hàm trả về chính nó thì chương trình chỉ đơn giản là nhảy về điểm bắt đầu của chương trình.\n\nĐây là 1 bài toán tìm số factorial thứ n được viết bằng đệ quy\n\n```\ndef factorial(0), do: 1\ndef factorial(n), do: n * factorial(n-1)\n\nVới n = 3 chương trình sẽ chạy như sau\n3 * factorial(3-1)\n3 * 2 * factorial(2-1)\n3 * 2 * 1 * factorial(1-1)\n3 * 2 * 1 * 1\n6\n```\n\nNhưng đây không phải là `tail-call optimization` bởi vì kết quả trả về của hàm thứ 2 không trả về chính nó mà trả về kết quả của 1 phép nhân. Thay đổi 1 chút như bên dưới\n\n```\ndef factorial(n), do: _fact(n, 1)\ndefp _fact(0, acc), do: acc\ndefp _fact(n, acc), do: _fact(n-1, acc*n)\n\nVới n = 3\n_fact(3-2, 1*3) =\u003e _fact(2, 3)\n_fact(2-1, 3*2) =\u003e _fact(1, 6)\n_fact(1-1, 6*1) =\u003e _fact(0, 6)\n6\n```\nChương trình này sẽ dùng biến acc để tracking lại giá trị của số trước nó, và chương trình sẽ chạy lùi từ n về 0. Nhưng như đã nói, mọi thứ đều có 2 mặt tốt và chưa tốt. Để hiểu thêm bạn có thể tham khảo ở (3)\n\n**Nhưng nếu mình muốn mọi thứ đồng bộ nhưng vẫn chạy thành nhiều process có được không?**\n\u003e Được, cùng xem ví dụ dưới đây\n\n```\ndefmodule Demo1 do\n  def say do\n    receive do\n      n -\u003e\n        IO.inspect(n)\n    end\n  end\nend\n\nnums = 1..10\n\nEnum.each(nums, fn i -\u003e\n  pid = spawn(Demo1, :say, [])\n  send(pid, i)\nend)\n\ndefmodule Demo2 do\n  def say(pid) do\n    receive do\n      n -\u003e\n        send(pid, n)\n    end\n  end\nend\n\nEnum.each(nums, fn i -\u003e\n  pid = spawn(Demo2, :say, [self])\n  send(pid, i)\n\n  receive do\n    n -\u003e\n      IO.inspect(n)\n  end\nend)\n\nOutput:\n# Demo1 cách này sẽ giúp bạn khởi tạo và chạy các process mà không quan tâm giá trị trả về có đúng thứ tự không\n1\n3\n2\n7\n4\n10\n8\n6\n5\n9\n\n# Demo2 sẽ đảm bảo kết quả trả về đúng thứ tự\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n```\n\nTrong elixir có 1 hàm giúp ta link được 2 process với nhau đó là hàm `spawn_link`\n\n```\ndefmodule Demo do\n  import :timer, only: [sleep: 1]\n\n  def die_soon do\n    sleep(500)\n    exit(:dead)\n  end\n\n  def run do\n    # Process.flag(:trap_exit, true)\n    spawn_link(Demo, :die_soon, [])\n\n    receive do\n      msg -\u003e\n        IO.puts(\"Message: #{inspect(msg)}\")\n    after\n      1000 -\u003e\n        IO.puts(\"I'm still alive\")\n    end\n  end\nend\n\nDemo.run()\n\nOutput:\n** (EXIT from #PID\u003c0.73.0\u003e) :dead\n```\n\nChương trình trên bị dừng khi process con bị chết, nó sẽ ảnh hưởng tới thằng cha làm chết theo. Để process cha không chết ta bỏ comment chỗ `Process.flag(:trap_exit, true)` lúc này chương trình không bị dừng mà output ra là\n\n```\nMessage: {:EXIT, #PID\u003c0.78.0\u003e, :dead}\n```\n\n# 3. Kết\nHi vọng các bạn có một góc nhìn khác, một hướng tiếp cận khác về lập trình đa luồng và quan trọng nhất là sẽ có bạn tìm hiểu thử về Elixir sau khi đọc xong bài viết này. Nếu bạn có bất cứ thắc mắc hay câu hỏi nào thì vui lòng comment vào bên dưới bài viết. Mình sẽ cố gắng trả lời các câu hỏi nếu trong phạm vi hiểu biết :)\n\nĐọc thêm:\n - (1) [Hewitt-ActorModel.pdf](http://worrydream.com/refs/Hewitt-ActorModel.pdf)\n - (2) [If-immutable-objects-are-good-why-do-people-keep-creating-mutable-objects](https://softwareengineering.stackexchange.com/questions/151733/if-immutable-objects-are-good-why-do-people-keep-creating-mutable-objects)\n - (3) [Tail-call optimization](https://pragtob.wordpress.com/2016/06/16/tail-call-optimization-in-elixir-erlang-not-as-efficient-and-important-as-you-probably-think/)\n\nRef: Elixir book\n"
                }, {
                "id": "7dtVY2yAfJN5n0HK8z130g",
                "title": "Bạn học CNTT và định bỏ đại học? Hãy đọc câu chuyện của mình",
                "content": "Dạo gần đây có rất nhiều tranh cãi xung quanh vấn đề bằng cấp đối với lập trình viên, người bảo cần thiết, người bảo không. Khi mình bắt đầu chính thức làm việc cho một công ty về phần mềm cách đây 3 năm, lúc đó mình hoàn toàn không có một bằng cấp nào cả. Một vài bạn đã gửi yêu cầu viết bài, tâm sự về ý định bỏ đại học, đây là bài viết dành cho các bạn.\n\n\u003e Trước hết chúng ta xác định với nhau là, nếu bạn cho rằng \"Không việc gì phải đọc bài viết vớ vẩn của một thằng không có trình độ đại học\", hoặc là thằng này \"không học nổi đại học\" thì cũng được, không sao cả. Đây chỉ là những gì mình đã trải qua, mang giá trị tham khảo.\n\nTheo quan điểm của mình, nếu bạn muốn bỏ đại học, mình khuyên bạn hãy quay lại trường ngay lập tức, hoàn thành chương trình học và lấy tấm bằng, sẽ ngon lành hơn rất nhiều. Đừng có quá tin tưởng ngưỡng mộ các gương bỏ học mà thành công, số lượng đó nó ít lắm, họ đã giỏi sẵn rồi, có tốt nghiệp hay không thì họ vẫn thành công cả thôi.\n\nNgành lập trình không quá quan trọng bằng cấp, các đơn vị tuyển dụng quan tâm nhiều đến khả năng của ứng viên có đáp ứng được yêu cầu của công việc hay không, tuy nhiên hãy cân nhắc khi bỏ đại học, sẽ có nhiều cái khổ mà bạn sẽ gặp phải đấy.\n\n## Những cái khổ khi không có bằng cấp\n\n**Áp lực tâm lý**:\n\nCái đầu tiên mà mình muốn kể đến đó là áp lực tâm lý. Khi bạn bỏ đại học, bạn sẽ phải chấp nhận cúi mặt xuống tủi nhục khi dư luận, làng xóm, họ hàng... dè bỉu về bạn, về gia đình bạn. Bố mẹ bạn, anh em bạn và chính bạn sẽ bị \"dư luận\" soi mói thậm chí khinh bỉ... Cái này mình cảm thấy cực kỳ khó vượt qua, cảm giác như bạn đã thất bại, chẳng muốn nhìn mặt ai luôn.\n\n**Cảm giác mình yếu kém**:\n\nBây giờ có nhiều trường, nên số lượng người có trình độ đại học mà mình gặp cũng rất nhiều, thậm chí có cả cụm từ \"phổ cập đại học\" nữa. Thế nên đi đâu, không có bằng mình luôn cảm thấy yếu kém so với người đối diện. Ngay lúc này, thời điểm mà mình đang viết bài tâm sự cùng các bạn, mình vẫn chưa có tấm bằng nào, và trong thâm tâm vẫn có một mong ước thầm kín là ước gì mình cũng có một cái.\n\n**Đi xin việc**:\n\nMay cho mình là lúc đi xin việc, mình đã khá tự tin với kỹ năng lập trình (trước đó mình làm freelance) nên cũng thuận lợi hơn một chút xíu. Đến đây thì thật sự không có bằng là một thiệt thòi lớn, thấy tin tuyển dụng nào mà yêu cầu tốt nghiệp đại học là không dám ứng tuyển luôn. Sau này khi đã tự tin hơn, mình phải ghi luôn vào cv xin việc là \"Ứng viên chưa tốt nghiệp đại học\" để người ta đỡ phải hỏi. Đi phỏng vấn luôn phải show sản phẩm, em từng làm cái lọ, em từng làm cái kia để bù vào cái bằng bị khuyết. Vì nhà tuyển dụng có coi trọng bằng cấp hay không, mình không thể nào biết được, rõ ràng rằng mình đã bỏ lỡ một vài cơ hội vì thiếu bằng đại học đúng không nào.\n\n**Khi đi làm**:\n\nTrong thời gian thử việc, người ta sẽ soi bạn nhiều hơn, hoặc ít ra bạn cảm thấy như thế, vì bạn vào đây bằng kinh nghiệm. Người ta có thể \"sân siu\" cho một bạn mới tốt nghiệp vì cho rằng \"bạn ấy vừa tốt nghiệp, chưa có kinh nghiệm nhiều\", nhưng với bạn thì không. Bạn thấy khổ chưa?\n\n\n## Dù thế nào, đừng bỏ lỡ cơ hội được học\n\nTrên báo đài, internet nhan nhản các câu như: \"Đại học không phải là con đường duy nhất đến thành công, có đôi khi bạn sẽ thấy có thằng nào đó bỏ học đại học, sau đó có được tí công trạng, quay lại nói rằng đại học là vô bổ tốn thời gian. Tuy nhiên, trường học dạy bạn khá nhiều thứ, dù ở bất cứ nơi đâu, đừng bỏ lỡ cơ hội được học.\n\n## Những điều đại học dạy bạn\n\nChương trình đại học được thiết kế để mô phỏng thực tế khi ra trường, tuy nó không thể đạt giống 100% nhưng nó cũng giúp bạn rất nhiều. Nó cung cấp cho bạn kiến thức nền tảng, khả năng tư duy và làm việc nhóm... những yếu tố rất cần thiết sau này, thu được kiến thức nhiều hay ít, đó là ở bạn.\n\nNhiều bạn cho rằng chương trình học vẫn nặng lý thuyết, tính thực tiễn chưa cao, điều này có phần đúng. Tuy nhiên, chương trình vẫn đang được cải tiến rất nhiều, mình nhớ là thời mình học đại học, chưa có môn lập trình android như bây giờ, vì lúc đó android chưa được google mua lại nên chưa có người dùng. Chứng tỏ rằng chương trình đại học cũng được cải cách đổi mới để phù hợp với thực tiễn.\n\nTất cả là ở cách học của bạn, có một cái hay nữa đó là khi đang còn là sinh viên, bạn có thừa thời gian để tìm hiểu công nghệ mới, tự học những gì mà bạn cảm thấy thích và làm một cái gì đó có ích. Ý tưởng được bay cao hơn, là sinh viên, bạn không giàu, nhưng chưa phải lo nghĩ gì đến việc kiếm miếng cơm. Đó là quãng thời gian khá thú vị, thực tế là không ít các dự án phần mềm thành công là từ thời sinh viên, facebook chẳng hạn.\n\nMình bỏ học năm cuối, nên cũng được trải nghiệm quãng thời gian thú vị bổ ích này. Đừng bỏ lỡ cơ hội được học nhé, vào thời điểm khó khăn, mình đã phải làm việc chân tay ở một xưởng cao su, thì suy nghĩ được là sinh viên hàng ngày được học những kiến thức lập trình, buổi tối có đủ thời gian để nghiên cứu thêm một cái gì đó theo sở thích, đó là một ước mơ tuyệt vời.\n\n## Kết luận\n\nGiá trị của tấm bằng chính là nó tượng trưng cho quá trình bạn đã cố gắng trong suốt một quãng thời gian, chứng tỏ bạn đã học được nhiều điều từ đó.\n\nTheo cách nhìn này, thì với một người học chỉ để có cái bằng, không chịu nâng cao kỹ năng bản thân, tấm bằng không có giá trị nhiều. Còn với một người khác, họ đã rất cố gắng trong quá trình học, không những học, họ còn chịu khó tìm hiểu nâng cao kiến thức, thì tấm bằng quả là có giá trị như vàng.\n\nBỏ học không giúp bạn thành công, bỏ học chỉ thành công khi bạn có kế hoạch vững chắc, hãy thành công theo cách của bạn, mỗi người có một định nghĩa về thành công khác nhau, con đường đi đến thành công cũng khác nhau. Mình **strongly recommend** bạn đừng bỏ lỡ cơ hội được học, dù ở bất kỳ hoàn cảnh nào.\n\nNguồn bài viết:\n[Blog Lập trình cuộc sống](http://laptrinhcuocsong.com)\n[http://laptrinhcuocsong.com/hoc-cntt-dinh-bo-hoc-hay-doc-cau-chuyen-cua-minh.html](http://laptrinhcuocsong.com/hoc-cntt-dinh-bo-hoc-hay-doc-cau-chuyen-cua-minh.html)"
                }],
    "status": 200,
    "cause": ""
}
