{
    "content": [{
                "id": "f0MQl2OS54OmhTMMH7ygkQ",
                "title": "Proof of Work vs Proof of Stake",
                "content": "\nEthereum đang chuyển từ **Proof of Work** sang **Proof of Stake**.  \n[Casper](https://github.com/ethereum/casper/releases) (smart contract cho phép sử dụng Proof of Stake) vừa được cộng đồng Ethereum Dev release phiên bản 0.1.0 gần 1 tháng trước, hứa hẹn việc chuyển mình từ PoW sang PoS cho không chỉ Ethereum mà còn nhiều các Cryptocurrency khác.  \n\nThiên hạ bàn tán nhiều về ưu nhược điểm của 2 phương pháp.  \nLà người mới tìm hiểu về blockchain, khoan chưa nói về ưu nhược điểm vội, trước hết ta cần hiểu cơ bản về 2 phương pháp này, chúng khác nhau như thế nào?  \n\nCó thể đọc lại bài viết [này](https://1upnote.me/post/2018/01/block-chain-la-gi) để review lại 1 chút về cơ chế hoạt động của Blockchain.  \n\n### Proof of Work (PoW) hoạt động như thế nào?\nNếu đọc kĩ bài viết ở link phía trên, ta cũng đã hiểu được cơ chế hoạt động của **PoW**. Xin được điểm lại 1 chút.   \n\nCác node tham gia hệ thống blockchain được gọi là các **miner** (thợ đào) cùng thực hiện tính toán để tìm ra hash cho khối block thoả mãn một điều kiện nhất định (điều kiện càng khó thì khối lượng tính toán càng nhiều). Ai tính toán ra kết quả đầu tiên sẽ là được phần thưởng, là một số lượng coin.  \n\n\u003e Đó là lý do tại sao cơ chế hoạt động này có tên gọi **Proof of Work**: Bằng chứng công việc.  \n\nĐể được nhận phần thưởng, các node phải cố gắng trở thành người hoàn thành tính toán đầu tiên, cũng có nghĩa là cần đẩy nhanh tốc độ và khối lượng tính toán. Dẫn đến khối lượng tính toán của toàn hệ thống tăng, tương ứng với nó là mức độ ngốn năng lượng.  \nĐó cũng là lý do tại sao bạn thường thấy hình ảnh các công ty đào bitcoin sở hữu các căn phòng rộng đặt hàng trăm hàng nghìn máy đào dài tăm tắp, và thường đặt ở các quốc gia khí hậu lạnh và giá điện rẻ.  \n\n![alt](https://1upnote.me/images/2018/06/bitcoin-mining-pool.jpg)\n\u003ccenter\u003eKhung cảnh bitcoin mining pool\u003c/center\u003e\n\nHơn thế nữa, khi khối lượng trung bình của hệ thống tăng, độ khó của điều kiện đặt ra cũng được điều chỉnh tăng. Điều này giúp cho số lượng coin mới không được sinh ra quá nhiều, giúp ổn định số lượng coin của toàn hệ thống.  \n\nĐộ khó tính toán tăng, mất nhiều thời gian để tính toán hơn, block chain ngày càng trở nên tốn kém về cả thời gian và tiền bạc.\n\n![alt](https://1upnote.me/images/2018/06/mining-energy-map.png)\n\n\u003e Hầu hết các nước ở châu Phi còn tiêu tốn ít năng lượng hơn tổng năng lượng của ngành đào Bitcoin.  \n\n**Câu hỏi đặt ra:**  \nCó cần thiết phải tốn kém nhiều thời gian và tiền bạc như vậy chỉ để đóng gói 1 block? Có cách nào nhanh và rẻ hơn không? Và người ta nghĩ đến 1 cơ chế kiểu khác đặt tên là **Proof of Stake**.\n\n### Proof of Stake (PoS) hoạt động như thế nào?\nKhắc phục nhược điểm kể trên, với **PoW**, việc tất cả node cùng tham gia tính toán giải các hàm hash là tốn thời gian và năng lượng.  \n\n**PoS** đưa ra một phương pháp đồng thuận mới trong việc đóng gói block vào chain.  \nTrong các node tham gia, một node sẽ được **lựa chọn ngẫu nhiên** để trở thành người kiểm định và đóng gói block.  \n\nNode tham gia được gọi là các **validator** (người kiểm định).  \nĐiều kiện để tham gia là các node này cần phải bỏ một khoản tiền vào mạng lưới, mà anh Vitalik Buterin gọi là **bet** (đặt cược). Ta có thể hiểu nôm na là đặt cọc tiền để chứng minh danh tính bản thân.  \n\n\u003e Khoản tiền này được gọi bằng từ chuyên môn là **Stake**.\n\nKhoản tiền này sẽ bị hệ thống thực hiện lock. Và sẽ được unlock sau khi node rút khỏi việc tham gia validator **một thời gian** (Chú ý việc unlock sẽ không được thực hiện ngay lập tức).  \n\nValidator được chọn sẽ thực hiện validate block. Thuật ngữ chuyên môn cho hành động này là **forge** hoặc **mint** (phân biệt với mine trong PoW).  \n\nNếu block hợp lệ và ghi được vào chain, validator này sẽ được phần thưởng chính là từ transaction fee. \n\n#### Thuật toán lựa chọn validator tiến hành forge\nThực chất việc lựa chọn này không hoàn toàn ngẫu nhiên mà dựa trên giá trị stake của những validator tham gia.  \nGiả dụ Alice có stake là 10 USD, Bob có stake là 100 USD. Vậy Bob sẽ có cơ hội cao để được lựa chọn hơn Alice.  \n\n\u003e Ý tưởng đơn giản là: Ai có giá trị stake cao sẽ có tiếng nói tin cậy.  \n\n![alt](https://1upnote.me/images/2018/06/pow-vs-pos.png)\n\n#### Nếu có gian lận thì sao?\nĐiều gì xảy ra nếu validator được chọn thực hiện gian lận cố tình validate block giả mạo.  \nNếu điều này bị phát hiện (được thông báo lên mạng lưới từ các validator khác), anh ta sẽ bị phạt toàn bộ số tiền trong stake.  \nĐây cũng là lý do tại sao stake không được hoàn trả ngay sau khi validator từ bỏ quyền tham gia. Tránh trường hợp anh ta validate block giả mạo sau đó từ bỏ quyền luôn để trốn chạy.  \n\nĐể đảm bảo lợi thu được nhỏ hơn nhiều số tiền bị phạt, stake tối thiểu được quy định của Casper là 1250 ETH (Code trên github ở [đây](https://github.com/ethereum/pyethereum/blob/serenity/ethereum/casper.se.py#L52)).  \n\nNên hiểu là chỉ có 1 block được chấp nhận và thêm vào chain, tất cả các validator đặt stake cho block bị coi là giả mạo (không được thêm vào chain) cũng sẽ mất toàn bộ stake của họ.\n\n**Đánh vào các hình phạt kinh tế là điểm then chốt để đảm bảo tính an toàn của PoS, khiến cho việc tấn công và giả mạo trở nên khó khăn hơn.**  \n\n### Tấn công vào hệ thống\nVới PoW, rất khó để thực hiện tấn công vào hệ thống, như [tấn công 51%](https://1upnote.me/post/2018/01/blockchain-51-attack) sẽ đòi hỏi chi phí về năng lượng tính toán cực lớn mà nhiều khi chi phí để tấn công còn tốn hơn nhiều lần món lợi đem lại.  \n\nVới PoS, việc tấn công cũng không hề dễ dàng. Nếu tấn công thất bại, kể tấn công sẽ bị phạt mất toàn bộ số tiền cược (stake).  \nĐể thực hiện tấn công 51%, kẻ tấn công cần phải có hơn 50% tổng số coin của hệ thống, điều này càng khó có thể xảy ra khi tổng giả trị thị trường của ETH hiện nay đã lên tới gần 60B USD.  \n\nVitalik Buterin có đề cập trong [bài viết của anh](https://medium.com/@VitalikButerin/a-proof-of-stake-design-philosophy-506585978d51) về việc sẽ hard fork nếu có tấn công và cần thiết để khôi phục hậu quả.  \nCó thể tìm hiểu thêm về hark fork ở [đây](https://1upnote.me/post/2018/01/softfork-vs-hardfork).\n\n### PoW vs PoS\nPoS là sự cải tiến của PoW nên chứa nhiều điểm khắc phục:  \n\n1. Do không cần tính toán giải các hàm hash phức tạp, hệ thống sử dụng PoS tốn **ít thời gian và năng lượng** hơn nhiều so với PoW.  \n2. PoS hứa hẹn sẽ tạo ra mạng lưới an toàn và **decentralize** hơn PoW\n\n- Với PoW, việc đào coin hiện nay chỉ hiệu quả với những hệ thống máy đào lớn, năng lượng cao. Điều này dẫn tới hiện nay power của toàn hệ thống chủ yếu tập trung ở các mining pool lớn. Làm cho hệ thống trở nên centralize (tập trung).  \nHiện nay 3 mining pools lớn nhất là BTC.com, AntPool, và SlushPool đã chiếm hơn 50%. \nĐiều gì sẽ diễn ra nếu 3 mining pools này sát nhập. Hệ thống Bitcoin sẽ bị tấn công dễ dàng bởi 51% attack.    \n\n![alt](https://1upnote.me/images/2018/06/blockchain-pools.png)\n\u003ccenter\u003eBiểu đồ phân bổ hash rate của Bitcoin, lấy từ [blockchain.info](https://blockchain.info/pools)\u003c/center\u003e\n\n- Với PoS, do không đòi hỏi năng lượng và dễ dàng để tham gia **đặt cược** (chỉ cần bạn có đủ số tiền vượt ngưỡng min deposit), hứa hẹn sẽ có nhiều node tham gia, giúp hệ thống trở nên **decentralize** hơn, và do đó an toàn hơn.  \n\n**Tuy nhiên:**\n\n- Với Ethereum Casper, con số tối thiểu để tham gia đặt cược là **125 ETH** (tương đương **750K USD** tại thời điểm hiện tại). Đây là 1 khoản tiền lớn, không phải ai cũng có. Vậy nếu được áp dụng PoS có thực sự giúp hệ thống trở nên decentralize hơn, hay quyền lực vẫn chỉ nằm trong tay một nhóm các người giàu nhất định.  \n- Việc hạn chế chỉ người giàu có thể tham gia làm cho người giàu càng trở nên giàu hơn (do thu được thêm lợi từ transaction fee) sẽ đẩy mạnh khoảng cách giàu nghèo. Đây có phải là điều chúng ta muốn tránh?  \n- Ngoài ra PoS còn phải đối mặt với nhiều vấn đề kỹ thuật cần giải quyết trước khi đưa vào hoạt động thực tế như: **Nothing at Stake** hay **Long Range Attack**. Mình xin được nói về 2 vấn đề này và cách Casper giải quyết nó trong một bài viết khác.  \n\n---\nBài cùng nội dung trên blog của mình ở [đây](https://1upnote.me/post/2018/06/pow-vs-pos/)."
                }, {
                "id": "cI450kRu3vPB5PfDCpvEKA",
                "title": "Funtion JavaScript,Jquery And Object",
                "content": "![alt](http://kylefdoherty.github.io/images/js_function_anatomy.png)\r\n# Funtion JavaScript : Một số kiến thức quan trọng và kinh nghiệm\r\n\u003e  đây là một cái blog mà có kiến thức khá nông cạn về nó phản ánh năng lực JavaScript cuả mình vì mình cũng mới học nó nên viết blog chỉ để nhớ và ,những người cùng cấp xem thôi , ngoài ra  mình rất hân hạnh các anh lớn tuổi có kinh nghiệm trong JavaSCript nếu có gì đó sai hoặc sao đó thì mong các anh góp ý cho !! \r\n\r\n### Function in Js\r\n- funtion trong Js đc viết như các Function trong các langues khác nên việc học nó cũng không khó lắm nếu các bạn đã nắm chắc kiến thức cũ của các ngôn ngữ lập trình khác , nhưng ngoài những điểm giống basic thì js còn có những function khá khó\r\n- **1**. Function **Return**\r\nđây là một Function khá easy vì nó là một giá trị vì trong Function có **return** nên nó sẽ trả về một giá trị trong câu lệnh ở đây  khi truyền tham số a, b vào function thì nó sẽ trả về là **a * b** = \u003e **console** sẽ nhận giá tri là **a * b** giá trị trả về hay cách xử lý tham số tùy thuộc vào **code** của bạn \r\n\r\n\r\n```python\r\n function kiablog(a,b){\r\n return a * b ;\r\n }\r\n console.log(kiablog(3,4));\r\n  ```\r\n\r\n\u003e**Console** : 12 \r\n \r\n\r\n\r\n- **2** . Funtion Return **kiểu biến** \r\n\r\n\u003e đây là một function khá kì quái mà mình đã nhầm rất nhiều trong code =)) , trong các ngôn ngũ như [java](https://www.tutorialspoint.com/java/index.htm),[C](https://www.w3schools.in/c-tutorial/),[C++](https://www.w3schools.in/cplusplus-tutorial/intro/) mình đã từng học thì nó khá là kì quái ,đây là một tóm tắt của function return nên nó sẽ ngắn gọn hơn chỉ mất một giòng để thực hiện câu lênh return \r\n  \r\n```python\r\nvar a = new function (\"a\",\"b\",\"a*b\");\r\nvar x = a(3,4);\r\n```\r\n\r\n\u003e ở đây 2 cái \"a\",\"b\" là tham số truyền ,cái \"a*b\" thì nó same như câu lệnh return a ^ b vậy nên hãy đơn giản nó ra thì chúng ta sẽ nhìn rõ đc vấn đề ngay đây\r\n\r\n- 3 .function prameter(gì gì đó )\r\n\r\n\u003etrong hàm này nó là một hàm chống lại sự un Value(không có dũ liệu hay còn goi là undefined)ok !! bắt đầu tìm hiểu nó nào  ? đây là một function khá dễ nên mình sẽ không nói kĩ lưỡng về nó !! =)\r\n\r\n\r\n```python\r\nfunction myFunction(x, y) {\r\n    if (y === undefined) {\r\n        y = 0;\r\n    }    \r\n    return x * y;\r\n}\r\n```\r\n - 4 .**this**\r\n\r\n```python\r\nvar car={\r\ncolor : \"red\",\r\nprice : \"OneMillionDolas\",\r\nyear : \"2018\",\r\npeople : \"8\",\r\nCreateYears : \"2000\"\r\nMyfun : function(){\r\nreturn this.people;\r\n}\r\n};\r\n```\r\n\u003e đây là một kiểu dũ liệu Object trong JS nó như kiểu class trong Java,C,C++,.....đấy thấy chưa !! cái m* gì cũng liên quan đến nhau hết nên khi học một cái thì hãy học tử tế vào nhé !! quay lại với nó thì chúng ta thấy car xem như là một class trong này và nó đóng vai trò hướng đôi tượng trong hàm **Myfun()** thì có chữ **this** ok và nó cũng giống như con trỏ trong cáC ngôn ngũ khác thôi nếu log ra thì nó là object ok \r\n\r\n5.call\r\n```python\r\nvar car = {\r\nName : function(){\r\nreturn this.color;\r\n}\r\n};\r\n\r\n\r\nvar car2 = {\r\ncolor : \"black\",\r\nYear : \"2002\"\r\n};\r\n\r\n\r\nvar car3 = {\r\ncolor : \"gray\",\r\nYear : \"2003\"\r\n};\r\n\r\nconsole.log(car.Name.call(car2));\r\n```\r\n\r\n\u003e **Console:  black**\r\n\r\n\r\n- call function will can make this object acess other object ok ok !!! this is very cool\r\n\r\n\r\n#Object \r\n \r\n\r\n ok this is some ex :for Object like that\r\n ```python\r\nvar person = {\r\n    firstname:\"John\",\r\n    lastname:\"Doe\",\r\n    age:50,\r\n    eyecolor:\"blue\"\r\n};\r\n ```\r\n\u003e var person như là một khai báo của một class , còn fisrtName, bla bla, thì nó có chức năng như biến trong này vậy đó , ok !!\r\n\u003e ngoài ra , dể truy cập đến các biến trong object thì có thể dung con trỏ **this**.tên biến và còn moojt các  nữa để truy cập là person[*tên biến*]\r\n# cách add biến vào class object\r\n\u003e chúng ta có thể dùng câu lệnh sau : person.***tên biến mới***= \"\" \r\n\u003e ngaofi ra chúng ta còn add thêm thuộc tính bằng cách như vậy nhưng khác một xúy\r\n\r\n```python\r\nperson.ngu = function () {\r\n//code\r\n}\r\n````\r\n\r\n#Tổng kết lại\r\n- có rất nhiều kiểu loiaj function khá khó trong Js\r\n- Object làm một class\r\n- cách truy cập,add, biến , function\r\n\r\n\r\n\r\n\u003e chúng ta có thể học Js ở trang web w3School.com ok Bye!"
                }, {
                "id": "9hoURW8SH5_1pfdudjb_1w",
                "title": "Ninja Code",
                "content": "Nếu coding giống như một trận chiến giữa programer và problem cần giải quyết thì, như những chiến binh thực thự, chúng ta tìm kiếm đạo (phương pháp chiến đấu) phù hợp cho chính mình. Trong bạt ngàn những đạo (những nguyên lý), kinh dịch (article trên blog của những blogger nổi tiếng), chú thích kinh nghiệm (những note, post được đông đảo dev `kip` lại),...đâu đó quanh đây vẫn tồn tại một đạo mà không mấy ai để ý đến nhưng số người theo thì đếm không kể hết. Có người đắc đạo hoàn toàn, có người một phần, tuy theo nhiều mức độ khác nhau nhưng tựu chung có thể coi đều là đồng đạo trong môn phái này :))\n\n\u003c!-- more --\u003e\n\n\u003e Chú ý: Bài viết lược dịch từ [đây](https://javascript.info/ninja-code). Đối với tôi, không có từ nào nhận xét tốt hơn cho bản gốc của bài viết này ngoài 2 chữ `tuyệt vời` :)).\n\nTrong khuôn khổ bài viết, đạo này được naming là __ninja đạo__ - người theo đạo được naming là các ninja (ninja đắc đạo là những ninja tuân thủ nghiêm ngặt theo những đạo lý được liệt kê trong bài viết này).\n\n# Đạo lý trong ninja đạo\n\n![Imgur](https://i.imgur.com/9gCBJvO.jpg)\n\nChúng ta sẽ cùng điểm qua những giáo lý chủ đạo của đạo phái này. (chú ý, source code sử dụng trong bài viết là javascript, tuy nhiên mở rộng ra nó có thể là bất cứ ngôn ngữ nào, bởi môn sinh theo học ninja đạo là vô biên)\n\n\u003e Rất nhiều môn sinh theo ninja đạo. Chỉ một số ít thành công.\n\u003e\n\u003e -- \u003ccite\u003eConfucius\u003c/cite\u003e\n\n## Ngắn gọn là đích đến của sự thông tuệ\n\nCode của bạn __càng ngắn gọn, bạn càng thông minh__ hơn thằng ngồi ở block bên cạnh.\n\nLấy ví dụ, tất cả chúng ta từ khi bắt đầu học lập tình đều biết đến phép toán `?` và cách nó biến đổi biểu thức điều kiện if về dạng oneline kì diệu như thế nào.\n\nXem ví dụ bên dưới:\n\n```java\n// taken from a well-known javascript library\ni = i ? i \u003c 0 ? Math.max(0, len + i) : i : 0;\n```\n\nMột ninja đạt cảnh giới cao viết những block code tuyệt vời như vậy! Sẽ chẳng có vấn đề gì nếu nó nằm sâu ngàn lớp trong một thư viện __high performance__ nào đó, nhưng điều gì sẽ xảy ra nếu người động đến đoạn code này là một môn sinh trẻ tuổi? Hẳn là môn sinh non nớt đó sẽ phải bỏ ra kha khá thời gian để bắt được giá trị của `i` khi muốn debug đoạn code này. \n\nVà rồi đến khi không thể tìm ra lời giải thích thoả đáng cho cái lỗi hắn đang phải debug, hắn sẽ tìm đến bạn (một ninja cảnh giới cao hơn) để hỏi về nó, hãy nói với hắn \"Ngắn hơn luôn tốt hơn!\", mở cho anh ta con đường đến với ninja đạo.\n\n## Biến số một chữ cái\n\n\u003e Người Dao ẩn mình bằng sự im lặng. Cái gì người Dao đã bắt đầu, chỉ người Dao biết cách kết thúc nó.\n\u003e\n\u003e -- \u003ccite\u003eLaozi (Tao Te Ching)\u003c/cite\u003e\n\nĐối với một ninja, không gì quan trọng hơn là kĩ năng ẩn mình. Vậy kĩ năng ẩn mình của một ninja đắc đạo thể hiện ở đâu? Nó thể hiện từ những thứ nhỏ nhất như là tên biến...\n\nĐặt tên biến `một-chữ-cái` (như là `a`, `b` hay `c`) giúp các ninja thượng đẳng tăng tốc độ code một cách đáng kể!\n\nTên biến một chữ cái trong 1 block code giống như những ninja ẩn trốn trong rừng cây. Không ai có thể tìm ra họ! Kể cả công cụ search của editor (`ctrl+F` hoặc `cmd+F`) cũng phải đầu hàng trước những biến này. Mặt khác kể cả khi tìm ra, không ai (trừ gã `người Dao` bên trên) biết được ý nghĩa của biến `a` hay `b` đó là gì.\n\n...Tuy nhiên vẫn có một ngoại lệ. Một ninja đắc đạo sẽ không bao giờ dùng biến một-chữ-cái như `i` để làm biến đếm trong vòng `for`. Lý do tại sao à, đơn giản là vì còn rất nhiều lựa chọn khác ngoài `i`, như `x` hay `y` chẳng hạn. \n\nMột ninja thực thụ sẽ không bao giờ để biến của anh ta dễ dàng bị bắt chỉ bởi dùng một chữ cái ai cũng biết như `i` được. Và đặc biệt, khi độ dài của vòng `loop` đó lên đến 1-2 trang (trang ở đây chỉ độ dài hiển thị source code trên một màn hình - nếu có thể, hãy cố gắng làm cho vòng for của bạn dài đến 3 trang, điều này giúp biến của bạn ẩn mình tốt hơn), khi đó bạn đã ngộ được nguyên lý để ẩn mình thực sự.\n\n## Rút....gọn\n\nNếu team của bạn có quy định về cấm sử dụng biến một-chữ-cái hoặc tên-vô-nghĩa, hãy lách luật bằng cách rút gọn chúng.\n\nMột số ví dụ như:\n- list → lst.\n- userAgent → ua.\n- browser → brsr.\n- …etc\n\nPhải là một ninja đắc đạo hoặc là có trực giác tốt mới có thể hiểu được ý nghĩa ẩn giấu dưới những cái tên này. Hãy cố gắng rút gọn mọi thứ, nó là một lớp lọc rất tốt. Chỉ những người thực sự có năng lực mới có thể hiểu và có quyền động vào source code của bạn.\n\n## Trừu tượng là mục tiêu\n\n\u003e The great square is cornerless\n\u003e The great vessel is last complete,\n\u003e The great note is rarified sound,\n\u003e The great image has no form.\n\u003e\n\u003e -- \u003ccite\u003eLaozi (Tao Te Ching)\u003c/cite\u003e\n\nKhi đặt tên biến, trong hàng trăm lựa chọn, hãy chọn cái tên trừu tượng nhất. Giống như `obj`, `data`, `value`, `item`, `elem`,...etc.\n\n+ Cái tên lý tưởng để đặt cho bất cứ biến nào là `data`, lý do đơn giản vì nó là từ chính xác nhất để miêu tả nhiệm vụ của biến - lưu trữ data!\n\nNhưng làm thế nào khi cái tên `data` đã bị một ninja khác trong team dùng mất? Hãy thử `value`! Sau cùng thì mọi biến đều sẽ nhận một giá trị nào đó, nên cái tên value là hoàn toàn có thể chấp nhận được.\n\n+ Mặt khác, bạn hoàn toàn có thể đặt tên cho biến bằng loại giá trị mà biến đó lưu. Ví dụ như: `str`, `num`,...\n\nMột môn sinh trẻ tuổi có thể ban đầu cảm thấy lạc lõng và tự hỏi kĩ năng đặt tên biến như trên có thực sự giúp ích cho một ninja? Hãy tự tin và nói với anh ta \"chắc chắn rồi!\".\n\nThật vậy, những cái tên trên thực sự vẫn mang trong nó ý nghĩa: `str` thể hiện biến đó đang lưu một chuỗi gì đó, `num` sẽ nắm giữ một số,... Nhưng khi có ai đó bên ngoài thử cố gắng hiểu đoạn code của bạn, họ sẽ bất ngờ nhận ra cái tên đó chẳng mang một ý nghĩa cụ thể nào cả :)) họ sẽ phải từ bỏ việc đào bới đoạn code và như vậy biến cùng với logic của bạn được __an toàn__ là của bạn.\n\nKhông có cách nào để thực sự hiểu được đoạn code của bạn - một ninja thượng đẳng - ngoại trừ việc dành nhiều thời gian cho nó và phải thực sự tĩnh tâm :)) Bạn sẽ bất ngờ về khả năng đọc code của môn sinh mới sau vài tháng luyện tập.\n\n+ Vậy phải làm gì khi hầu hết những cái tên phía trên đều rất dễ bị một ninja khác trước bạn dùng mất? Đơn giản, chỉ cần __THÊM SỐ VÀO__ : `data1`, `data2`, `value3`, `str4`,...etc.\n\n## Kiên định\n\nSự tập trung cũng là một trong những yếu tố phân định đẳng cấp của một ninja! Chỉ những ninja đã thực sự tập trung và kiên nhẫn mới đủ tư cách đi cùng những ninja thượng đẳng khác. Vậy làm cách nào để thử thách họ - những môn sinh non trẻ?\n\nMột cách đơn giản, hãy __sử dụng những cặp tên dễ nhầm lẫn đặt tên biến__ như là `data` \u0026 `date`. Sau đó mix chúng lại với nhau! Sẽ không ai có thể nhanh chóng đọc được source code của bạn, và rồi khi có lỗi typo (lỗi đánh máy) Uhm...chúng ta sẽ còn kẹt ở đây khá lâu, một tách trà trước khi tiếp tục không phải một ý tưởng tồi...\n\n## Tiền tố\n\n\u003e Rất khó để có thể bắt được con mèo đen trong một căn phòng tối. Nhất là khi trong đó chẳng có con mèo nào.\n\u003e\n\u003e -- \u003ccite\u003eConfucius\u003c/cite\u003e\n\nSử dụng những từ gần nghĩa là một cách khẳng định khả năng suy nghĩ linh hoạt và sáng tạo của một ninja thượng đẳng. Nó cũng làm cho code của team trở nên thú vị hơn rất nhiều :))\n\nXem xét ví dụ về tiền tố trong đặt tên. Khi muốn viết hàm hiển thị thông tin lên màn hình - hãy đặt tên nó với tiền tố `display`...chẳng hạn `displayMessage`!!! Khi có một chức năng khác cần hiển thị một cái gì đó khác lên màn hình, cố gắng tìm một từ gần nghĩa tương tự chẳng hạn `showName`! \n\nNhấn mạnh rằng __có sự khác biệt tinh tế giữa các chức năng như vậy, trong khi không có sự khác biệt nào__. Hoặc theo một hướng khác, hãy thử thảo luận và đưa ra một hiệp ước với các ninja đồng đội: Nếu như đối với chức năng hiển thị, A sẽ viết các function với tên bắt đầu bằng `display`, B sẽ bắt đầu bằng `render` còn bạn sẽ bắt đầu bằng...`paint` chẳng hạn. Càng nhiều ý tưởng, code của team sẽ càng đa dạng, môn sinh mới gia nhập càng có thêm ví dụ để thực hành. Vậy là bạn đã có sáng tạo của riêng mình và tiến thêm được một bước trên con đường ninja đạo.\n\n...Và bây giờ là thời gian dành cho mẹo vặt!\n\nNếu đã __đặt tiền tố khác nhau cho những chức năng tương tự nhau__, còn gì cản bước bạn không thực hiện nốt phần \u001dcòn lại: __đặt tên tiền tố giống nhau cho những chức năng không mấy liên quan đến nhau__?\n\nVí dụ, hàm `printPage(page)` sẽ sử dụng máy in, in trang hiện tại. Và hàm `printText(text)` sẽ hiển thị văn bản lên màn hình. Hãy để môn sinh xa lạ khi nghĩ về chức năng `printMessage(message)` - một cái tên cùng tiền tố - “Nó đặt thông điệp ở đâu? Để máy in hoặc trên màn hình? ”. Sẽ là một môn sinh đầy triển vọng nếu anh ta có thể làm cho nó thực sự tỏa sáng bằng một ý tưởng: `printMessage(message)` nên xuất nó trong cửa sổ mới!\n\n## Tái sử dụng tên (biến, hàm,...)\n\n\u003e Once the whole is divided, the parts need names.\n\u003e There are already enough names. One must know when to stop.\n\u003e\n\u003e -- \u003ccite\u003eLaozi (Tao Te Ching)\u003c/cite\u003e\n\nMột ninja giỏi biết cách tăng tối đa hiệu quả sử dụng bộ nhớ bằng cách __chỉ tạo biến mới khi thực sự cần thiết__!\n\nMột mặt tích cực khác là bạn đỡ tốn thời gian naming cho biến mới. Do đó tốt hơn cả là sử dụng lại biến với những cái tên đã có, chỉ cần __thay giá trị mới cho chúng__.\n\nMột ninja thượng đẳng có thể viết ra những function hàng chục dòng logic mà chỉ sử dụng các biến được __truyền vào dưới dạng tham số__. Một môn sinh mới sẽ cảm thấy khó khăn để xác định được chính xác giá trị tại thời điểm hiện tại của một biến nào đó, hay biến đó đến từ đâu. Một người có trực giác yếu sẽ phải phân tích đoạn mã theo từng dòng, theo dõi sự thay đổi qua mỗi nhánh mã và sau cùng tuyệt vọng chạy thử đoạn mã trên giấy...\n\nMột biến thể cao cấp của kĩ năng này là thử tráo (tạo clone) của biến đó bên trong vòng loop hoặc function. Những môn sinh yếu không hiểu rõ về những thứ như tham chiếu và tham trị thực sự sẽ phải quỳ gối trước những đoạn code như vậy.\n\n```java\nfunction ninjaFunction(elem) {\n  // 20 lines of code working with elem\n\n  elem = clone(elem);\n\n  // 20 more lines, now working with the clone of the elem!\n}\n```\n\nKhi muốn làm việc với biến `elem` ở nửa sau của hàm, thậm chí, ngay cả một ninja khác cũng có thể sẽ phải bất ngờ...Chỉ khi debug đoạn code trên từng dòng, anh ta mới có cơ hội nhận ra mình đang làm việc với bản clone của biến đó.\n\n## Thể hiện tình yêu đối với những gì bạn tạo ra\n\nHãy để những môn sinh trẻ tuổi thấy được sự tuyệt vời của những thứ bạn tạo ra! Những cái tên như `superElement`, `megaFrame` và `niceItem` chắc chắn sẽ soi sáng họ.\n\nThật vậy, một cái gì đó được naming: `super...`, `mega...`, `nice...` hẳn là một thứ tuyệt vời. Nhưng mặt khác - điều đó không mang lại bất cứ thông tin chi tiết nào. Môn sinh trẻ tuổi có thể sẽ tự ngộ ra một ý nghĩa ẩn giấu nào đó sau khi đã thiền định trong một hoặc hai giờ.\n\n## Chồng chéo các biến bên ngoài\n\n\u003e When in the light, can’t see anything in the darkness.\n\u003e When in the darkness, can see everything in the light.\n\u003e\n\u003e -- \u003ccite\u003eGuan Yin Zi\u003c/cite\u003e\n\nSử dụng __cùng một tên biến cho biến ở trong và ngoài một scope nào đó__. Ví dụ \n\n```java\nlet user = authenticateUser();\n\nfunction render() {\n  let user = anotherValue();\n  ...\n  ... //many lines...\n  ...\n  ... // \u003c-- a programmer wants to work with user here and...\n  ...\n}\n```\n\nMôn sinh trẻ tuổi đang làm việc với đoạn code bên trong function `render` sẽ không thể nhận ra có một __biến local__ khác cùng tên `user` mới thực sự là biến đang được sử dụng. Anh ta vẫn đang tưởng mình đang sử dụng biến user là kết quả của `authenticateUser()`...!!! Ok happy debugging :))\n\n## Side-effects everywhere!!!\n\nCó những chức năng giống như chúng __không thay đổi gì cả__. Những function với cái tên như `isReady()`, `checkPermission()`, `findTags()`,... Chúng được giả định để thực hiện các phép tính, tìm và trả về dữ liệu mà __không thay đổi bất kỳ thứ gì bên ngoài chúng__. Nói cách khác, chúng không có __\"side effect\"__.\n\n+ Một ninja đắc đạo biết cách __thêm vào chúng những chức năng hữu ích__ để hỗ trợ đồng đội.\n\nBiểu hiện của sự ngạc nhiên trên khuôn mặt đồng nghiệp của bạn khi anh ta thấy một chức năng có tên là `check...` hoặc `find...` thay đổi một cái gì đó - chắc chắn sẽ là lý do anh ấy rời xa bạn hơn :)).\n\n+ Một cách khác để gây ngạc nhiên cho anh bạn đồng nghiệp là __trả lại kết quả không chuẩn__.\n\nVới cách suy nghĩ còn non nớt chưa qua rèn rũa của một môn sinh, `checkPermission()` hẳn là một thứ gì đó mà sẽ trả về `true/false`, nhưng là một ninja có trách nhiệm, bạn nên trả về nhiều hơn để giúp anh ta, hãy trả về cho anh ấy một object.\n\nCho đến khi môn sinh trẻ tuổi kia viết những thứ đại loại như `if(checkPermission(...))`, anh ta sẽ tự hỏi tại sao nó không hoạt động. Nói với anh ấy: “Đọc tài liệu đi!!!”. Và __đưa cho anh ấy bài viết này__.\n\n## Powerful functions!\n\n\u003e The great Tao flows everywhere, both to the left and to the right.\n\u003e\n\u003e -- \u003ccite\u003eLaozi (Tao Te Ching)\u003c/cite\u003e\n\nĐừng giới hạn chức năng function của bạn chỉ bởi vì cái tên của nó. Hãy để cho nó làm được nhiều hơn thế.\n\nVí dụ như function `validateEmail(email)` bên cạnh việc kiểm tra tính đúng đắn của email, nó nên xuất ra thông báo về lỗi đó và gửi yêu cầu để người dùng gửi lại email chẳng hạn. Không gì tốt hơn việc __chỉ gọi một function và bạn đã có mọi thứ bạn muốn__ :)).\n\nNhững ninja giỏi biết cách giấu hàng tá logic vào trong code của họ, để không ai có thể đánh cắp chúng từ bên ngoài.\n\n![magic](https://media.giphy.com/media/12NUbkX6p4xOO4/giphy.gif)\n\n__Kết hợp nhiều logic vào trong cùng một chỗ giúp bảo vệ code của bạn khỏi nguy cơ bị tái sử dụng.__\n\nTưởng tượng một thằng ngốc nào đó trong team muốn sử dụng code của một ninja như bạn, ví dụ như hàm `validateEmail(email)` bên trên. Sau vài giờ thiền định và nhận ra function bạn viết làm được còn nhiều hơn cả những gì một gã ngốc như anh ta mong đợi (kiểm tra tính đúng đắn của email), nghiễm nhiên, anh ta sẽ bỏ cuộc và không có ý định làm phiền đến khoảng thời gian thiền định của bạn nữa.\n\n# TL;DR\n\nTất cả những __code lý__ trong __code đạo__ của ninja đạo kể trên đều từ source code có thật...Nhiều khi nó được viết bởi những developer nhiều năm kinh nghiệm, có lẽ có thể còn nhiều hơn cả bạn ;).\n\n- Tuân theo __một vài đạo lý__ trong số này, code của bạn sẽ tràn đầy sự bất ngờ.\n- Tuân theo __phần lớn đạo lý__ trong số này, code của bạn sẽ thực sự là của bạn, không ai muốn sửa hay động đến nó.\n- Tuân theo __tất cả những đạo lý__ này, code của bạn sẽ trở thành một bài học có giá trị cho các môn sinh trẻ tìm kiếm sự giác ngộ.\n\nMình tìm thấy bài viết này sau một khoảng thời gian vật lộn ở team `bugd` - một team chuyên chữa bug trên production ở công ty mình, và mình cảm thấy nó khá thấm :)).\n\nSau khi đọc xong bài viết này, hãy thử nhìn quanh và điểm xem trong những người bạn quen, ai là môn sinh, ai là ninja và ai đã đắc đạo. Nếu bạn mới chỉ là một môn sinh, không nên quá lo lắng, ninja luôn ở quanh ta, hãy tìm và học hỏi họ nhé :+1: ."
                }, {
                "id": "hcvWESKbnODBi4cvZmtJZg",
                "title": "Làm project đặt vé event hay ho của riêng bạn: Phần 1: Làm Google Form, gửi mail cho user",
                "content": "# Đôi điều tâm sự\r\nHmm đã bao giờ bạn bị nhờ là: \"Mày ơi mấy hôm nữa câu lạc bộ làm cái ì ven, mày làm cái form nào đăng kí cái là chúng nó có vé/mail báo thành công\" hay bạn là cái đứa được nhờ cũng muốn tìm hiểu :D Chẳng là ông bạn tui tính làm cái event nho nhỏ giao lưu offline trong group nên muốn cái gì đó hay ho chút nên nhờ tui làm. Mà tui lại rất là ngại mảng front-end, ngồi responsive linh ta linh tinh cũng hết bố nó 1 tuần rồi -.- (Tôi làm chậm lắm :D) nên là tôi tìm hiểu Google App Script của Google luôn.\r\n\r\n# Thế Google App Script(GAS) là cái của nợ gì?\r\nThì [GAS](https://developers.google.com/apps-script/) là một bộ script tích hợp 1 loạt cái hay ho của GG từ GG Form, Docs, Sheet nói chung là cái của nợ gì của nó cũng hay ho luôn :D Anh em lên đó xem qua thì biết\r\n\r\n# Vậy thôi bắt đầu\r\n\r\n## Trước hết làm cái Google Form cái nhỉ?\r\nGoogle Form quá dễ rồi chắc tui không hướng dẫn nữa :D Nếu lần đầu tiếp xúc thì cũng quá dễ dàng để làm quen(Nhưng tôi chắc nếu ông nào biết đến Kipa là gì thì chắc cũng phải dùng Google Form 1 lần là ít)\r\nỞ đây việc tạo như thế nào là anh em tự túc nhé :D Tui sẽ tạo 1 cái đơn giản thôi (Kiểu như thế [này](https://docs.google.com/forms/d/e/1FAIpQLSd-G-aEPMfadNxiUluKvM4ROa3ptwkwcG3QKh_EJ3xOVsdxfw/viewform)\r\n\r\n## Okay xong, ta cùng nghịch 1 chút về Script nhé\r\nĐể vào mục script ta vào trang edit của form và chọn 3 chấm -\u003e Script Editor![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/t1n28xm2uu_image.png)\r\nChính nó :3 Nó sẽ tự bắn vào 1 trang khác. ![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/adugd5exbu_image.png)\r\nVào thì sẽ có 1 file tên là Code.gs. Đây chính là trang chúng ta sẽ viết code xử lí :3 \r\nỞ đây ta có thể dùng các Trigger, libs(mình không biết gọi libs có chuẩn không) để có thể send maill (Ví dụ MailApp.sendEmail để gửi mail)\r\nOkay cùng thử nhé\r\n```js\r\nfunction myFunction() {\r\n  MailApp.sendEmail(\"nghminh163@outlook.com\",\"Xin chào bạn\", \"Lớp diu \u003c3\");\r\n}\r\n```\r\nMình sẽ thử gửi mail về cho mình\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/4k5whwtv5k_image.png)\r\nÀ các bạn lưu ý là nhớ chọn đúng function chạy vào nhé. Mặc định nó sẽ vào function myFunction(kiểu main vậy) bạn có thể chuyển, mình ở đây sẽ cứ để myFunction nhé\r\nOkay run \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/csfcx7h2j4_image.png)\r\nỞ đây nó sẽ đòi quyền gửi mail :3 App của mình mà mình cấp phép nó thôi\r\n*Nếu chưa nhận được sau khi cấp quyền hãy thử send lại nhé*\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7bb7i1xvxl_image.png)\r\nỞ đây nó nghĩ là spam :)) Cũng khá đúng nhưng mà dù sao mình cũng nhận được. Nghịch vậy thôi cùng tiếp tục với project của chúng ta nào\r\n\r\n## Bắt sự kiện người dùng submit form \r\nNếu bạn nào đã liếc qua tài liệu của Google 1 chút rồi thì thấy là nó cũng có 1 trigger là Form Submit đấy nhưng mà nó chẳng trả cái gì mấy (Docs thì đây [này](https://developers.google.com/apps-script/guides/triggers/events#form-submit_3)). Tui thì sẽ get hết response về và lấy cái response cuối cùng :D Chủ trương là như vậy nhé.\r\nTrước hết làm 1 cái function tên nó là onSubmit đã. Các bạn đặt tên gì cũng được, ở đây tui đặt theo thói quen thôi. (Xóa hết function đi để cái này cũng được hoặc các bạn có thể dùng luôn cái myFunction cũng đc)\r\nOkay tôi sẽ set trigger cho nó![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ytyz9elukb_image.png)\r\nBấm vô cái đồng hồ tí hon này này :D\r\nBấm \"No triggers set up. Click here to add one now.\"  ![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/jzqbgbuqpp_image.png)\r\nSet như mình rồi save vào là được\r\nOkay ở đây mình sẽ get cái response cuối cùng như sau\r\n```js\r\nfunction onSubmit(){\r\n   var listRes = FormApp.getActiveForm().getResponses();\r\n   var response = listRes[listRes.length-1].getItemResponses();\r\n  for(var i=0;i\u003cresponse.length;i++){\r\n      Logger.log(response[i].getItem().getTitle()); //Title của câu hỏi\r\n   \t  Logger.log(response[i].getResponse()); //Câu trả lời\r\n}}\r\n```\r\nMình sẽ save lại và thử phát. Trước khi test nhớ check lại Trigger nhé. \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mgt6fvkfov_image.png)\r\nCap cho các ông cái form :D![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ef0i68wywx_image.png)\r\nVà đây là cái log :D. Có vẻ như xong rồi đó. Nốt gửi mail báo về user là xong\r\n\r\n## Muốn mail đẹp phải thì phải dùng html nhỉ?\r\nĐúng rồi muốn mail đẹp thì phải làm file html cho nó ngon :D Trong project sẽ tạo mới 1 file html nhé\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lnxwl48zr6_image.png)\r\nNhư nói trên đó tui khá kém khoản \"hát tờ mờ lờ\" với \"cờ sờ sờ\" nên tui sẽ đơn giản như màu chữ vớ vẩn thôi :)\r\nĐể có thể đặt biến vào html này bạn dùng `\u003c?= tenbien ?\u003e`\r\nĐây mình có cái html như sau\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml\u003e\r\n  \u003cbody\u003e\r\n      \u003ch1 style=\"color:red;\"\u003e Chúng tôi xin xác minh tên bạn là: \u003c?= name ?\u003e\u003c/h1\u003e\r\n      \u003ch2 style=\"color:yellow;\"\u003eHiện tại bạn đang ở: \u003c?= address ?\u003e   \u003c/h2\u003e\r\n      \u003ch3 style=\"color:blue;\"\u003eVà tình trạng vợ con của bạn là: \u003c?= married ?\u003e  \u003c/h3\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\nOkay quay lại với cái file .gs nhé. Để import html thì ta dùng\r\n```js\r\nvar template = HtmlService.createTemplateFromFile('tenfile');\r\ntemplate.tenbien = bien\r\n```\r\nVí dụ ở đây mình có luôn i=0 thì sẽ là name, i=1 thì là địa chỉ, i=2 là tình trạng ghệ, mình ngại for nên mình sẽ set cứng giá trị luôn\r\n\r\nXong rồi dùng hàm sendEmail để send mail thôi\r\n```js\r\n  MailApp.sendEmail(emailto,title,\"\",{htmlBody:template.evaluate().getContent()});\r\n```\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lt74inakos_image.png)\r\nĐây là kết quả ta có\r\n\r\n:D Hề ở số lần sau mình sẽ hướng dẫn các bạn có thể là up cái data nên lên Firebase Firestore và dùng Cloud Function của Firebase trả về QRCode sau đó send cho user nhé. :D Cảm ơn đã đọc bài viết của mình. Mọi thắc mắc cũng như là góp ý vui lòng comment nhé. \r\n\r\n*Vì mình không đem điện thoại theo người mà cái github lại bị 2fa nên kh up source được mình để source dưới đây nhé*\r\n```html\r\n\u003c!-- response.html --\u003e\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml\u003e\r\n  \u003cbody\u003e\r\n      \u003ch1 style=\"color:red;\"\u003e Chúng tôi xin xác minh tên bạn là: \u003c?= name ?\u003e\u003c/h1\u003e\r\n      \u003ch2 style=\"color:yellow;\"\u003eHiện tại bạn đang ở: \u003c?= address ?\u003e   \u003c/h2\u003e\r\n      \u003ch3 style=\"color:blue;\"\u003eVà tình trạng vợ con của bạn là: \u003c?= married ?\u003e  \u003c/h3\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n```js\r\n//Code.gs\r\nfunction onSubmit(){\r\n   var listRes = FormApp.getActiveForm().getResponses()\r\n   var response = listRes[listRes.length-1].getItemResponses();\r\n   var name = response[0].getResponse();\r\n   var addr = response[1].getResponse();\r\n   var married = response[2].getResponse();\r\n  \r\n  var template = HtmlService.createTemplateFromFile('response');\r\n  template.name = name;\r\n  template.address = addr;\r\n  template.married = married;\r\n  \r\n  MailApp.sendEmail(\"nghminh163@outlook.com\",\"Bạn vừa đăng kí dự tiệc offline của hội không có ghệ D:\",\"\",{htmlBody:template.evaluate().getContent()});\r\n}\r\n//Bạn có thể để 1 ô nhập mail để trả về cho user nhé :D ở đây mình quên mất\r\n```"
                }, {
                "id": "9JcpRD3SuDGOIoI8ubH72Q",
                "title": "Một số câu hỏi phỏng vấn JavaScript hay và khó 2 - Chắc ai đó sẽ cần !",
                "content": "Xin chào bạn!\n\nTrong bài viết trước [Một số câu hỏi phỏng vấn JavaScript hay và khó 1 - Chắc ai đó sẽ cần !](https://kipalog.com/posts/Mot-so-cau-hoi-phong-van-JavaScript-hay-va-kho-1---Chac-ai-do-se-can-) , mình đã giới thiệu với bạn một số câu hỏi phỏng vấn JavaScript khá hay (theo ý kiến chủ quan thôi nhé). Không biết bạn đã giải thích được chúng chưa?\n\nNhững câu hỏi trắc nghiệm này khi mới nhìn qua thì tưởng đơn giản, nhưng khi bắt tay vào làm thì mới thấy là không hề dễ. Có những phần kiến thức mình nghĩ chắc chắn phải là A, nhưng thực tế nó lại là B. Vì vậy, việc trả lời những câu hỏi trắc nghiệm sẽ giúp bạn củng cố kiến thức và tự tin hơn vào trình độ của mình.\n\nDo đó, bài này mình lại tiếp tục gửi đến bạn 6 câu hỏi phỏng vấn JavaScript hay và khó khác. Mời bạn theo dõi bài viết!\n\n## Câu 1\nCho bạn 4 đoạn code sau:\n\nĐoạn 1:\n\n```js\nlet person = {\n  name : 'Bob', \n  sayName : function() {\n    setTimeout(function() {\n      console.log(`I'm ${this.name}`);\n    }, 1000);\n  }\n};\nperson.sayName();\n```\n\nĐoạn 2:\n\n```js\nlet person = {\n  name : 'Bob', \n  sayName : () =\u003e {\n    setTimeout(() =\u003e {\n      console.log(`I'm ${this.name}`);\n    }, 1000);\n  }\n};\nperson.sayName();\n```\n\nĐoạn 3:\n\n```js\nlet person = {\n  name : 'Bob', \n  sayName : function() {\n    setTimeout(() =\u003e {\n      console.log(`I'm ${this.name}`);\n    }, 1000);\n  }\n};\nperson.sayName();\n```\n\nĐoạn 4:\n\n```js\nlet person = {\n  name : 'Bob', \n  sayName : () =\u003e {\n    setTimeout(function() {\n      console.log(`I'm ${this.name}`);\n    }, 1000);\n  }\n};\nperson.sayName();\n```\n\nHỏi console in ra kết quả thế nào và tại sao?\n\n## Câu 2\n\n```js\n(function(foo) {\n  console.log(typeof foo);\n})([1, 2, 3]);\n```\n\nHỏi console in ra kết quả như thế nào và tại sao?\n\n## Câu 3\n\n```js\n// Cách 1:\nfunction func() {}\n \n// Cách 2:\nlet func = function() {}\n```\n\nHai cách khai báo function trên khác nhau như thế nào? Nêu ví dụ minh họa?\n\n## Câu 4\n\n```js\nlet cat = function() {\n  return \n  {\n    say: 'meow'\n  }\n}\n```\n\nHỏi console in ra kết quả như thế nào và tại sao?\n\n## Câu 5\n\n```js\nconsole.log(Math.max());\n```\n\nHỏi console in ra kết quả như thế nào và tại sao?\n\n## Câu 6\n\n```js\nconsole.log(0 + '0');\nconsole.log(0 - '0');\nconsole.log(0 * '0');\nconsole.log(0 / '0');\n```\n\nHỏi console in ra kết quả như thế nào và tại sao?\n\n## Đáp án và giải thích\n\nĐể tránh tình trạng bạn chưa suy nghĩ kĩ mà đã xem lời giải, mình sẽ không để đáp án và giải thích tại đây. \n\nThay vào đó, mời bạn xem đáp án và giải thích chi tiết tại [Xoắn não với phỏng vấn JavaScript 2](https://completejavascript.com/xoan-nao-voi-phong-van-javascript-2/).\n\nXin chào và hẹn gặp lại!\n\n---\nTheo dõi [Lam Pham](https://completejavascript.com/gioi-thieu/) trên [Kipalog](https://kipalog.com/users/Lam%20Pham/mypage) để nhận thông báo khi có bài viết mới nhất:\n\n  * **Facebook Fanpage:** [Complete JavaScript](https://www.facebook.com/completejavascript/)\n  * **Facebook Group:** [Hỏi đáp JavaScript VN](https://www.facebook.com/groups/HoiDapJavascriptVN)"
                }, {
                "id": "jYiZqfzDlFJw1BhlEO98KA",
                "title": "Muốn theo nghề lập trình bắt đầu từ đâu? (một góc nhìn từ “Khảo sát của Stack Overflow năm 2018”)",
                "content": "#Muốn theo nghề lập trình bắt đầu từ đâu? (một góc nhìn từ “Khảo sát của Stack Overflow năm 2018”)\r\n##1.\tVề Stack Overflow\r\n* Là một mạng xã hội lớn, uy tín của các lập trình viên trên thế giới\r\n* Giúp các lập trình viên tìm kiếm giải pháp cho các vấn đề gặp phải trong công việc hàng ngày; là nơi mỗi cá nhân thể hiện trình độ của mình thông qua việc giúp đỡ các đồng nghiệp khác; tuyển người làm \u0026 tìm việc làm\r\n* Jeff Atwood và Joel Spolsky (người Mỹ) sáng lập Stack Overflow năm 2008\r\n* Hơn 50M lượt người truy cập mỗi tháng, trên 14M câu hỏi, trên 19M trả lời\r\n* Thực hiện các khảo sát hàng năm, năm nay là lần thứ 8, với hơn 100.000 lập trình viên đang làm việc tại 183 quốc gia và vùng lãnh thổ tham gia khảo sát\r\n* Nội dung khảo sát liên quan đến ngành lập trình\r\n\r\n##2.\tNên chọn công việc nào để theo học\r\nDanh sách sau là một số công việc phổ biến của nghề lập trình, đồng thời cho biết tỉ lệ của mỗi công việc dựa trên số người được khảo sát. Tham khảo để chọn sẽ theo học cái gì? Thông thường, nên chọn công việc có nhiều người đang làm, tức thị trường đang cần nhiều. Hoặc có người đang làm nghĩa là có nhu cầu tuyển dụng, vì vậy học cái gì cũng được, nếu thực sự đam mê. Tuy nhiên, nếu chưa thử hết các công việc làm sao biết mình thích cái nào hơn cái nào? Cần người tư vấn và tự trải nghiệm?\r\n\r\nLoại công việc - Tỉ lệ người đang làm/Tổng số người tham gia khảo sát\r\n\r\n* Back-end developer - 57.9%\r\n* Full-stack developer - 48.2%\r\n* Front-end developer\t- 37.8%\r\n* Mobile developer\t- 20.4%\r\n* Desktop or enterprise applications developer\t- 17.2%\r\n* Student\t- 17.1% (người khảo sát đang là sinh viên, không phải một loại công việc)\r\n* Database administrator\t- 14.3%\r\n* Designer\t- 13.1%\r\n* System administrator\t- 11.3%\r\n* DevOps specialist\t- 10.4%\r\n* Data or business analyst\t- 8.2%\r\n* Data scientist or machine learning specialist\t- 7.7%\r\n* QA or test developer\t- 6.7%\r\n* Engineering manager\t- 5.7%\r\n* Embedded applications or devices developer\t- 5.2%\r\n* Game or graphics developer\t- 5.0%\r\n* Product manager\t- 4.7%\r\n* Educator or academic researcher\t- 4.0%\r\n* C-suite executive (CEO, CTO, etc.)\t- 3.8%\r\n* Marketing or sales professional\t- 1.2%\r\n\r\n##3.\tMức lương của mỗi công việc\r\n\r\nNgoài yếu tố dễ xin việc, hợp với đam mê của bản thân, cũng nên quan tâm tới mức lương của mỗi công việc. Tất nhiên, lương cao thì đòi hỏi trình độ, kinh nghiệm, áp lực công việc cũng cao.\r\nDưới đây là danh sách các loại công việc và mức lương tương ứng (lưu ý:  không phải lương áp dụng cho người đang làm việc tại Việt nam)\r\n\r\nLoại công việc\t- Mức lương\t\r\n\r\n* Engineering manager\t- $89,000\r\n* DevOps specialist\t- $72,000\r\n* Data scientist or machine learning specialist\t- $60,000\r\n* Data or business analyst\t- $59,000\r\n* Embedded applications or devices developer\t- $59,000\r\n* Full-stack developer\t- $59,000\r\n* Desktop or enterprise applications developer\t- $57,000\r\n* Back-end developer\t- $56,000\r\n* System administrator\t- $56,000\r\n* QA or test developer\t- $55,000\r\n* Database administrator\t- $51,000\r\n* Front-end developer\t- $51,000\r\n* Designer\t- $46,000\r\n* Educator or academic researcher\t- $44,000\r\n* Mobile developer\t- $43,000\r\n* Game or graphics developer\t- $40,000\r\n\r\n\r\n##4.\tChọn công nghệ nào để theo\r\nVới mỗi công việc có thể lựa chọn nhiều công nghệ khác nhau, bao gồm: ngôn ngữ lập trình, cơ sở dữ liệu, mã nguồn mở hay đóng, trình viết mã, framework, thư viện.\r\n###4.1\tNgôn ngữ\r\nDưới đây là danh sách các ngôn ngữ phổ biến đang được mọi người sử dụng,\r\n\r\nNgôn ngữ\t- Tỉ lệ người đang sử dụng/Tổng số người tham gia khảo sát\r\n* JavaScript\t71.5%\r\n* HTML\t- 69.4%\r\n* CSS\t- 66.2%\r\n* SQL\t- 58.5%\r\n* Java\t- 45.4%\r\n* Bash/Shell\t- 40.4%\r\n* Python\t- 37.9%\r\n* C#\t- 35.3%\r\n* PHP\t- 31.4%\r\n* C++\t- 24.6%\r\n* C\t- 22.1%\r\n* TypeScript\t- 18.3%\r\n* Ruby\t- 10.3%\r\n* Swift\t- 8.3%\r\n* Objective-C\t- 7.3%\r\n* Go\t- 7.2%\r\n* Assembly\t- 6.9%\r\n* VB.NET\t- 6.9%\r\n* R\t- 6.0%\r\n* Matlab\t- 5.5%\r\n* VBA\t- 4.8%\r\n* Kotlin\t- 4.7%\r\n* Groovy\t- 4.5%\r\n* Scala\t- 4.5%\r\n* Perl\t- 4.2%\r\n\r\n\r\n###4.2\tCơ sở dữ liệu\r\nDưới đây là danh sách các cơ sở dữ liệu phổ biến đang được mọi người sử dụng,\r\n\r\nCơ sở dữ liệu\t- Tỉ lệ người đang sử dụng/Tổng số người tham gia khảo sát\r\n* MySQL\t- 58.7%\r\n* SQL Server\t- 41.2%\r\n* PostgreSQL\t- 32.9%\r\n* MongoDB\t- 25.9%\r\n* SQLite\t- 19.7%\r\n* Redis\t- 18.0%\r\n* Elasticsearch\t- 14.1%\r\n* MariaDB\t- 13.4%\r\n* Oracle\t- 11.1%\r\n* Microsoft Azure (Tables, CosmosDB, SQL, etc)\t- 7.9%\r\n* Google Cloud Storage\t- 5.5%\r\n* Memcached\t- 5.5%\r\n* Amazon DynamoDB\t- 5.2%\r\n* Amazon RDS/Aurora\t- 5.1%\r\n* Cassandra\t- 3.7%\r\n* IBM Db2\t- 2.5%\r\n* Neo4j\t- 2.4%\r\n* Amazon Redshift\t- 2.2%\r\n* Apache Hive\t- 2.2%\r\n* Google BigQuery\t- 2.1%\r\n* Apache Hbase\t- 1.7%\r\n\r\n\r\n###4.3\tFramework, thư viện, công cụ\r\n\r\nDưới đây là danh sách các framework, thư viện, công cụ phổ biến đang được mọi người sử dụng,\r\n\r\nFramework, thư viện, công cụ - Tỉ lệ người đang sử dụng/Tổng số người tham gia khảo sát\r\n* Node.js (JS)\t- 49.6%\r\n* Angular (JS)\t- 36.9%\r\n* React (JS)\t- 27.8%\r\n* .NET Core\t- 27.2%\r\n* Spring (Java)\t- 17.6%\r\n* Django (Python)\t- 13.0%\r\n* Cordova (JS mobile)\t- 8.5%\r\n* TensorFlow (Machine Learning)\t- 7.8%\r\n* Xamarin (mobile app)\t- 7.4%\r\n* Spark (Java)\t- 4.8%\r\n* Hadoop (big data, distributed data)\t- 4.7%\r\n* Torch/PyTorch (deep learning – python)\t- 1.7%\r\n\r\n\r\n###4.4\tTrình viết mã\r\nDưới đây là danh sách trình soạn thảo mã nguồn (IDE, code editor) đang được mọi người sử dụng,\r\n\r\nIDE, code editor - Tỉ lệ người đang sử dụng/Tổng số người tham gia khảo sát\r\n* Visual Studio Code\t- 34.9%\r\n* Visual Studio\t- 34.3%\r\n* Notepad++\t- 34.2%\r\n* Sublime Text\t- 28.9%\r\n* Vim\t- 25.8%\r\n* IntelliJ\t- 24.9%\r\n* Android Studio\t- 19.3%\r\n* Eclipse\t- 18.9%\r\n* Atom\t- 18.0%\r\n* PyCharm\t- 12.0%\r\n* Xcode\t- 10.6%\r\n* PHPStorm\t- 9.0%\r\n* NetBeans\t- 8.2%\r\n* IPython / Jupyter\t- 7.4%\r\n* Emacs\t- 4.1%\r\n* Rstudio\t- 3.3%\r\n* RubyMine\t- 1.6%\r\n* TextMate\t- 1.1%\r\n* Coda\t- 0.6%\r\n* Komodo\t- 0.6%\r\n* Zend\t- 0.4%\r\n* Light Table\t- 0.2%\r\n\r\n###4.5\tCác nhóm công nghệ liên quan\r\nHình sau là các nhóm công nghệ liên quan, (nguồn: stackoverflow)\r\n \r\n ![alt](https://cdn.sstatic.net/insights/Img/Survey/2018/tech_network-1.svg?v=d48aa121744c)\r\n###4.6\tMột số hướng đang được quan tâm nhiều\r\n* Web\r\n* Mobile\r\n* IoT\r\n* Machine Learning\r\n* Data Science\r\n\r\n##5.\tTài liệu tham khảo\r\n[1] http://travisnguyen.net/selfpondering/2018/04/28/stackoverflow-history/\r\n[2] https://en.wikipedia.org/wiki/Joel_Spolsky\r\n[3] https://en.wikipedia.org/wiki/Jeff_Atwood\r\n[4] https://en.wikipedia.org/wiki/Stack_Overflow\r\n[5] https://insights.stackoverflow.com/survey/2018\r\n\r\n\r\nLeGiaCong 05-06-2018"
                }, {
                "id": "nLOCPKMul498xVIdov_lVw",
                "title": "Tuyển dụng IT - Những câu chuyện dở khóc dở cười",
                "content": "**Giaosucan's blog chia sẻ kiến thức theo cách bá đạo**\r\n\r\n**http://www.giaosucan.com**\r\n\r\n##![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/baurn9mta4_image.png)\r\n\r\nFsoft là một công ty IT với hơn 10 nghìn con người, khách hàng đến từ năm châu bốn biển. Từ  Nhật Bổn , Huê Kỳ cho đến Mỹ Tho, Mù Căng Chải đủ cả.  Do đó  mà công ty có nhu cầu tuyển dụng rất lớn. Bài toán nhân lực đã tạo nên áp lực lớn cho đội ngũ tuyển dụng ở đây, và cũng tạo nên nhưng giai thoại cười ra nước mắt.\r\nĐể phục vụ cho công tác tuyển dụng, Fsoft build một đội ngũ tuyển dụng hùng hậu, gọi tắt là đội REC (recruitment), toàn các em gái xinh như mộng, chân dài đến nách, da trắng như Bạch Tuyết, tóc đen như gỗ mun, tóm lại là hàng tuyển, đảm bảo hạ gục ứng viên ngay từ cái nhìn đầu tiên\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/qr1rwiiir9_image.png)\r\n## Đăng tuyển ứng viên\r\nKhi đơn vị có dự án,  HR, các sếp chỉ thị xuống đội REC, yêu cầu tuyển dụng ứng viên ở các level khác nhau như Developer, Solution Architect, PM, biết ngôn ngữ .NET, Java, ABC. Xyz \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/d4ioc8dmsf_image.png)\r\nThường thì những vị trí như coder, tester trình độ nhàng nhàng thì dễ kiếm, nhưng khi tìm ứng viên ở trình độ PM hay SA thì quả là một thách thức đối với đội REC. giống kiểu mò kim đáy bể\r\nNhân viên REC sẽ phải tìm kiếm ứng viên trên LinkedIn, Facebook, các trường đại học… Thời buổi này nếu chỉ đăng tin tuyển dụng kiểu truyền thống, đúng theo lề phải như “Fsoft cần 10 developer .NET”, “Cần xxx Java developer “ thì xác định ứng viên bấm next luôn. Cho nên các bạn đã sử dụng những mẩu tin tuyển dụng cực kì sáng tạo. Không Like, Share không được\r\nChú nào không gửi CV cho chị là hư quá\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lce63hlvyq_image.png)\r\nEm gái xinh như mộng hẹn café thì ai lại từ chối?\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/x0g68dr9zd_image.png)\r\nCác thể loại to và cứng\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/m8vax023ls_image.png)\r\nPhong cách người lạ ơi.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/4ncik3koxp_image.png)\r\nNội dung chưa đủ, bonus cả hình để cưa đổ ứng viên. Tuy nhiên được làm chủ nhân của cái em cầm hoa này thì vẫn ổn hơn là cái lẵng hoa, tiếc là em ý có bình rồi.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7mrg2iywh4_image.png)\r\nNghèo tiền bạc anh ngại, nhưng nghèo quần áo thì ok\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/svieuca43u_image.png)\r\nThực tế hình thức đăng tin PR trên Facebook, kiểu này cũng khá hiệu quả. Mình cơ duyên vào Fsoft cũng qua những tin tuyển dụng thế này, do thấy em tuyển dụng nhìn cool quá nên đồng ý liên hệ, gặp em siêu cá sấu chắc chạy mất dép…\r\n## Tán tỉnh ứng viên\r\nĐối với những bạn ứng viên như sinh viên mới ra trường, ít năm kinh nghiệm thì không mất nhiều thời gian, nhưng đối với những kĩ sư level cao, nhiều năm kinh nghiệm thì việc thuyết phục họ nộp CV, và interview còn khó hơn cả cưa mấy em hoa hậu. Bởi vì những bạn này thuộc dạng “mình giỏi mình có quyền”, đều có công việc ổn định lương cao và đặc biệt họ có nhiều lựa chọn giữa các công ty. Đất lành thì chim đậu, công ty nào chế độ đãi ngộ tốt, môi trường thăng tiến thì sẽ làm. Đại loại không làm chỗ này thì làm chỗ kia, chán Ngọc Trinh thì chuyển sang Thủy Top, không thiệt, chỉ có công ty là thiệt.\r\nSau khi đã tìm được ứng viên trên LinkedIn, Facebook, đưa vào tầm ngắm thì bắt đầu là các loại tin nhắn, email, skype dội bom tới tấp, tiếng tây tiếng ta đủ cả, y như thả thính.\r\nNội dung chính là công việc với mức lương hấp dẫn\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/eatovhgkyh_image.png)\r\n\r\nKhi thính đã được thả cả chùm, bạn nào đớp thính sẽ đến bước 2 là alo, trao đổi qua điện thoại. tranh thủ hẹn hò café với các ứng viên tiềm năng để trao đổi tâm tư tình cảm, giới thiệu công ty, chế độ đãi ngộ, cơ hội thăng tiến, tóm lại chỉ cần bạn giỏi, còn cả thế giới công ty sẽ lo. Thực tế trong ngành IT đa phần ứng viên là nam, nếu có em gái xinh tươi nhắn tin hẹn café tâm sự thì cũng khó từ chối. \r\n## Bị ứng viên tán\r\nCông cuộc tán tỉnh này cũng sinh ra nhiều câu chuyện giở khóc, giở cười, tóm lại nhân viên tuyển dụng xinh đẹp dễ thương cũng là một lợi thế. Có chồng hay không không quan trọng, quan trọng là em cute ngọc nát vẫn hơn ngói lành\r\nNhiều bạn Rec thay vì tán ứng viên là bị ứng viên tán ngược lại theo kiểu hồi mã thương.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/v1uc0x33va_image.png)\r\nBị ứng viên úp sọt\r\nCái nghề này thì việc bị úp sọt, leo cây là chuyện thường như ở huyện. Nhiều ứng viên đồng ý hẹn interview xong thì cancel, thậm chí có bạn đã chốt deal, đợi kí hợp đồng xong thì … bùng. Y như kiểu làm con người ta có bầu rồi quất ngựa truy phong.\r\nCảm giác có thể nói là thốn vô cùng\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/xusqt6mg5x_image.png)\r\n\r\nĐiều này không thể trách ứng viên, khi hợp đồng chưa kí, ván chưa đóng thuyền thì mọi thứ có thể xảy ra. Các doanh nghiệp cạnh tranh nhau về lương bổng, đãi ngộ, nếu ứng viên tìm thấy chỗ tốt hơn thì họ sẽ nhẩy thôi.\r\n\r\n ![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/jn54c16e4h_image.png)\r\n\r\n Đến ngay cả kí xong đi làm, còn nghỉ việc được, chỉ khổ cho các em tuyển dụng chỉ biết ngồi lòng đau như cắt, nước mắt tuôn rơi\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/9uoxhxdvfv_image.png)\r\nỨng viên kí hợp đồng\r\nNỗi buồn đi liền với niềm vui, khi một ứng viên pass interview và kí hợp đồng, nhất là trường hợp “hàng hiếm”, trình độ cao thì cảm giác muốn bùng cháy vì đã hoàn thành nhiệm vụ.\r\nRelated image\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7j355ij715_image.png)\r\n\r\n## Kết luận\r\nNghề tuyển dụng là một nghề có đủ mọi cung bậc cảm xúc, hị nộ ái ố. Tâm trạng thay đổi như  4 mùa, sáng nắng chiều mưa, tối rét run, sáng mai bão tố. Người làm nghề Rec phải hết sức tỉnh táo, phải nắm bắt thông tin thị trường lao động, đối mặt với nhiều khó khăn. Các công ty có được nguồn nhân lực trình độ cao có công lao đóng góp không nhỏ của đội ngũ REC"
                }, {
                "id": "hoSSxR1pY6B_SrmIIZYVGA",
                "title": "Tuốt tuồn tuột về Promise và async/await",
                "content": "**Bài viết gốc được đăng ở Ê-ku [https://ehkoo.com/bai-viet/tat-tan-tat-ve-promise-va-async-await](https://ehkoo.com/bai-viet/tat-tan-tat-ve-promise-va-async-await)**\r\n\r\n---\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/uaulqha86j_image.png)\r\n_`Promise.race([blueTuktuk, greenMotobike, redTractor])` -- Hình minh họa của [Ken Wong](http://www.kenart.net/)_\r\n\r\n\u003e Chời, thời này ai xài Promise nữa. Chuẩn bây giờ là async/await.\r\n\u003e -- _Ai đó trên mạng_\r\n\r\nHãy khoan bạn ơi, đừng vội nhảy lên chuyến tàu tốc hành async/await trong khi chưa rành Promise, kẻo lại xảy ra \"va chạm khi dồn dịch\", gây nên hậu quả khôn lường, vì căn bản async/await vẫn dùng Promise ở bên dưới mà thôi.\r\n\r\nCùng xem lại những khái niệm căn bản của Promise, đồng thời so sánh với async/await để xem khi nào thì nên xài hàng nào nhé.\r\n\r\n### Nhắc lại, Promise là gì?\r\n\r\nPromise là một _cơ chế_ trong JavaScript giúp bạn thực thi các tác vụ bất đồng bộ mà không rơi vào _callback hell_ hay _pyramid of doom_, là tình trạng các hàm callback lồng vào nhau ở quá nhiều tầng. Các tác vụ bất đồng bộ có thể là gửi AJAX request, gọi hàm bên trong `setTimeout`, `setInterval` hoặc `requestAnimationFrame`, hay thao tác với WebSocket hoặc Worker... Dưới đây là một callback hell điển hình.\r\n\r\n```js\r\napi.getUser('pikalong', function(err, user) {\r\n  if (err) throw err\r\n  api.getPostsOfUser(user, function(err, posts) {\r\n    if (err) throw err\r\n    api.getCommentsOfPosts(posts, function(err, comments) {\r\n      // vân vân và mây mây...\r\n    })\r\n  })\r\n})\r\n```\r\n\r\nVí dụ trên khi được viết lại bằng Promise sẽ là:\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e api.getPostsOfUser(user))\r\n  .then(posts =\u003e api.getCommentsOfPosts(posts))\r\n  .catch(err =\u003e { throw err })\r\n```\r\n\r\nĐể tạo ra một promise object thì bạn dùng class Promise có sẵn trong trình duyệt như sau:\r\n\r\n```js\r\nconst p = new Promise( /* executor */ function(resolve, reject) {\r\n  // Thực thi các tác vụ bất đồng bộ ở đây, và gọi `resolve(result)` khi tác\r\n  // vụ hoàn thành. Nếu xảy ra lỗi, gọi đến `reject(error)`.\r\n})\r\n```\r\n\r\nTrong đó, `executor` là một hàm có hai tham số:\r\n* `resolve` là hàm sẽ được gọi khi promise hoàn thành\r\n* `reject` là hàm sẽ được gọi khi có lỗi xảy ra\r\n\r\nVí dụ:\r\n\r\n```js\r\napi.getUser = function(username) {\r\n  // Hàm api.getUser() trả về một promise object\r\n  return new Promise((resolve, reject) =\u003e {\r\n    // Gửi AJAX request\r\n    http.get(`/users/${username}`, (err, result) =\u003e {\r\n\r\n      // Nếu có lỗi bên trong callback, chúng ta gọi đến hàm `reject()`\r\n      if (err) return reject(err)\r\n\r\n      // Ngược lại, dùng `resolve()` để trả dữ liệu về cho `.then()`\r\n      resolve(result)\r\n\r\n    })\r\n  })\r\n}\r\n```\r\n\r\nNhư vậy `api.getUser()` sẽ trả về một promise object. Chúng ta có thể truy xuất đến kết quả trả về bằng phương thức `.then()` như sau:\r\n\r\n\r\n```js\r\nfunction onSuccess(user) { console.log(user) }\r\nfunction onError(err) { console.error(error) }\r\n\r\napi.getUser('pikalong')\r\n  .then(onSuccess, onError)\r\n```\r\n\r\nPhương thức `.then(onSuccess, onError)` nhận vào hai hàm: `onSuccess` được gọi khi promise hoàn thành và `onError` được gọi khi có lỗi xảy ra. Bên trong tham số `onSuccess` bạn có thể trả về một giá trị đồng bộ, chẳng hạn như giá trị số, chuỗi, `null`, `undefined`, array hay object; hoặc một **promise object** khác. Các giá trị bất đồng bộ sẽ được bọc bên trong một Promise, cho phép bạn kết nối (chaining) nhiều promises lại với nhau.\r\n\r\n```js\r\npromise()\r\n  .then(() =\u003e { return 'foo' })\r\n  .then(result1 =\u003e {\r\n     console.log(result1) // 'foo'\r\n     return anotherPromise()\r\n  })\r\n  .then(result2 =\u003e console.log(result2)) // `result2` sẽ là kết quả của anotherPromise()\r\n  .catch(err =\u003e {})\r\n```\r\n\r\nTrong ví dụ trên, bạn thấy đến phương thức `.catch()`. Phương thức này chỉ là _cú pháp bọc đường_ (syntactic sugar) của `.then(null, onError)` mà thôi. Chúng ta sẽ nói thêm về `.catch()` ở bên dưới.\r\n\r\n#### Tạo nhanh Promise với `Promise.resolve()` và `Promise.reject()`\r\n\r\n Có những trường hợp bạn chỉ cần bọc một giá trị vào promise hay tự động reject. Thay vì dùng cú pháp `new Promise()` dài dòng, bạn có thể dùng hai phương thức tĩnh `Promise.resolve(result)` và `Promise.reject(err)`\r\n\r\n```js\r\nconst p = Promise.resolve(12)\r\n  .then(result =\u003e console.log(result)) // 12\r\n  .then(res =\u003e Promise.reject(new Error('Dừng lại nhanh')))\r\n  .then(() =\u003e 'Cười thêm phát nữa là tym anh đứt phanh')\r\n  .catch(err =\u003e console.error(err)) // Error: Dừng lại nhanh\r\n```\r\n\r\n### Còn async/await là cái chi?\r\n\r\nĐược giới thiệu trong ~~ES7~~ ES8, async/await là một _cơ chế_ giúp bạn thực hiện các thao tác bất đồng bộ một cách _tuần tự_ hơn. Async/await vẫn sử dụng Promise ở bên dưới nhưng mã nguồn của bạn (theo một cách nào đó) sẽ trong sáng và dễ theo dõi.\r\n\r\nĐể sử dụng, bạn phải khai báo hàm với từ khóa `async`. Khi đó bên trong hàm bạn có thể dùng `await.`\r\n\r\n```js\r\nasync function() {\r\n  try {\r\n    const user = await api.getUser('pikalong')\r\n    const posts = await api.getPostsOfUser(user)\r\n    const comments = await api.getCommentsOfPosts(posts)\r\n\r\n    console.log(comments)\r\n  } catch (err) {\r\n    console.log(err)\r\n  }\r\n}\r\n```\r\n\r\nCăn bản về Promise và async/await là vậy. Hiện giờ, bạn đã có thể sử dụng Promise và async/await ở tất cả các trình duyệt hiện đại (trừ IE11 ra nhé, bạn vẫn cần polyfill cho nó). Hãy xem những trường hợp cần lưu ý khi sử dụng chúng.\r\n\r\n### Vài lưu ý\r\n\r\n#### \"Kim tự tháp\" Promises\r\n\r\nMột lỗi chúng ta hay mắc phải khi mới làm quen với Promise, đó là tạo ra \"kim tự tháp\" promises như thế này.\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e {\r\n     api.getPostsOfUser(user)\r\n       .then(posts =\u003e {\r\n         api.getCommentsOfPosts(posts)\r\n         .then(comments =\u003e {\r\n           console.log(comments)\r\n         })\r\n         .catch(err =\u003e console.log(err))\r\n       })\r\n       .catch(err =\u003e console.log(err))\r\n  })\r\n  .catch(err =\u003e console.log(err))\r\n```\r\n\r\nLý do vì chúng ta quên mất tính chất liên kết (chaining) của promise, cho phép bên trong hàm `resolve` có thể trả về một giá trị đồng bộ hoặc **một promise** khác. Do đó cách giải quyết là:\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  // Trả về một promise\r\n  .then(user =\u003e api.getPostsOfUser(user))\r\n  .then(posts =\u003e api.getCommentsOfPosts(posts))\r\n  .catch(err =\u003e { throw err })\r\n```\r\n\r\nViệc hiểu và sử dụng thành thạo tính liên kết là một trong những điểm **QUAN TRỌNG NHẤT** khi làm việc với Promise. Khi promise lồng vào nhau từ 2 tầng trở lên thì đã đến lúc bạn phải refactor lại rồi.\r\n\r\n#### Luôn đưa vào `.then()` một hàm\r\n\r\nBạn thử đoán xem đoạn code sau sẽ in ra gì?\r\n\r\n```js\r\nPromise.resolve(1)\r\n  .then(2)\r\n  .then(console.log)\r\n```\r\n\r\nCâu trả lời là `1` đó. Phương thức `.then` đòi hỏi tham số của nó phải là một hàm. Nếu bạn đưa vào `.then()`  một giá trị, nó sẽ bị bỏ qua, giải thích tại sao đoạn code trên hiển thị `1`. Trường hợp tương tự:\r\n\r\n```js\r\nPromise.resolve(1)\r\n  .then(Promise.resolve(2))\r\n  .then(console.log) // 1\r\n```\r\n\r\nCách giải quyết:\r\n\r\n```js\r\nPromise.resolve(1)\r\n  .then(() =\u003e 2)\r\n  // hoặc như thế này, mặc dù hơi dư thừa\r\n  .then(() =\u003e Promise.resolve(2))\r\n  .then(console.log) // 2\r\n```\r\n\r\nChúng ta sẽ được kết quả như ý.\r\n\r\n#### Cẩn thận với `this` khi dùng tham chiếu hàm\r\n\r\nGiả sử bạn có đoạn code sau:\r\n\r\n```js\r\nconst add2 = x =\u003e x + 2\r\n\r\nPromise.resolve(4).then(result =\u003e add2(result))\r\n```\r\n\r\nHàm `onSuccess` không làm gì khác ngoài việc chuyển `result` vào cho `add2`, nên bạn có thể dùng tham chiếu hàm để đoạn code trên gọn hơn.\r\n\r\n```js\r\nPromise.resolve(4).then(add2)\r\n```\r\n\r\nBạn có thể nghĩ, vậy với phương thức của một đối tượng, ta cũng có thể đưa tham chiếu hàm vào `.then()`?\r\n\r\n```js\r\nclass User {\r\n  constructor(user) {\r\n    this.user = user\r\n  }\r\n\r\n  getUsername() {\r\n    return this.user.username\r\n  }\r\n}\r\n\r\nconst u = new User({ username: 'pikalong' })\r\nPromise.resolve()\r\n  .then(u.getUsername)\r\n  .then(console.log)\r\n```\r\n\r\nNhưng bạn lại nhận được lỗi sau:\r\n\r\n\u003e Unhandled rejection:[TypeError: Cannot read property 'user' of undefined]\r\n\r\nLý do là vì khi trong [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode), biến ngữ cảnh `this` chỉ được xác định khi trực tiếp gọi phương thức của đối tượng đó, hoặc thông qua `.bind()`. Bạn có thể xem giải thích chi tiết hơn [ở đây](https://stackoverflow.com/a/34930887).\r\n\r\nĐể giải quyết lỗi này, bạn có thể dùng một trong những cách sau:\r\n\r\n```js\r\n.then(() =\u003e u.getUsername())\r\n\r\n// hoặc\r\n.then(u.getUsername.bind(u))\r\n\r\n// hoặc dùng hàm mũi tên khi khai báo phương thức trong class (cần plugin\r\n// `transform-class-properties` của Babel)\r\nclass User {\r\n  // ...\r\n  getUsername = () =\u003e {\r\n    return this.user.username\r\n  }\r\n}\r\n```\r\n\r\n#### Chạy các Promise tuần tự\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mvo4pyqi2f_image.png)\r\n\r\nTrong trường hợp muốn chạy các promises một cách tuần tự như sơ đồ ở trên, bạn có thể dùng hàm `Array.prototype.reduce` .\r\n\r\n```js\r\n[promise1, promise2, promise3].reduce(function(currentPromise, promise) {\r\n  return currentPromise.then(promise)\r\n}, Promise.resolve())\r\n\r\n// Đoạn ở trên khi được viết dài dòng ra\r\nPromise.resolve().then(promise1).then(promise2).then(promise3)\r\n```\r\n\r\nAsync/await mang đến giải pháp \"xinh đẹp\" hơn, cho phép bạn truy xuất đến giá trị của các promises phía trước nếu cần thiết.\r\n\r\n```js\r\nasync function() {\r\n  const res1 = await promise1()\r\n  const res2 = await promise2(res1)\r\n  const res3 = await promise3(res2)\r\n}\r\n```\r\n\r\n#### Chạy nhiều Promises cùng lúc với Promise.all()\r\n\r\nLại có trường hợp bạn muốn thực thi và lấy ra kết quả của nhiều promises cùng lúc. Giải pháp \"ngây thơ\" sẽ là dùng vòng lặp, hoặc `.forEach`.\r\n\r\n```js\r\nconst userIds = [1, 2, 3, 4]\r\n\r\n// api.getUser() là hàm trả về promise\r\nconst users = []\r\nfor (let id of userIds) {\r\n  api.getUser(id).then(user =\u003e ([...users, user]))\r\n}\r\n\r\nconsole.log(users) // [], oát-đờ-heo?\r\n```\r\n\r\nLý do là vì khi promise chưa kịp resolve thì dòng `console.log` đã chạy rồi. Chúng ta có thể sửa bằng cách dùng `Promise.all([promise1, promise2, ...])`. Phương thức này nhận vào một mảng các promises và chỉ resolve khi tất cả các promises này hoàn thành, hoặc reject khi một trong số chúng xảy ra lỗi.\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/wo4f8pe9f6_image.png)\r\n\r\n```js\r\nconst userIds = [1, 2, 3, 4]\r\n\r\nPromise.all(usersIds.map(api.getUser))\r\n  .then(function(arrayOfResults) {\r\n    const [user1, user2, user3, user4] = arrayOfResults\r\n  })\r\n```\r\n\r\nNếu dùng async/await  thì...\r\n\r\n```js\r\nasync function() {\r\n  const userIds = [1, 2, 3, 4]\r\n  const [user1, user2, user3, user4] = await Promise.all(usersIds.map(api.getUser))\r\n}\r\n```\r\n\r\n#### Đừng quên Promise.race()\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/43qbia9hn1_image.png)\r\n\r\nNgoài hai kiểu chạy tuần tự và song song ở trên, chúng ta còn có `Promise.race([promise1, promise2, ...])`. Phương thức này nhận vào một mảng các promises và sẽ resolve/reject ngay khi một trong số các promises này hoàn thành/xảy ra lỗi.\r\n\r\n```js\r\nPromise.race([\r\n  ping('ns1.example.com'),\r\n  ping('ns2.example.com'),\r\n  ping('ns3.example.com'),\r\n  ping('ns4.example.com')\r\n]).then(result =\u003e {})\r\n```\r\n\r\n#### Cẩn thận với `return` không tường minh\r\n\r\nXét hai đoạn mã sau:\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e {\r\n    return api.getPostsByUser(user)\r\n  })\r\n  .then(console.log) // posts\r\n\r\napi.getUser('pikalong')\r\n  .then(user =\u003e {\r\n    api.getPostsByUser(user)\r\n  })\r\n  .then(console.log) // undefined\r\n```\r\n\r\nĐoạn mã thứ hai trả về `undefined` vì trong JavaScript nếu một hàm không _công khai_ trả về một giá trị, `undefined` mặc định sẽ được trả về ([nguồn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions)). Do đó, bạn cần lưu ý về giá trị `return` khi làm việc với Promise.\r\n\r\n#### Phân biệt `.then(resolve, reject)` và `.then(resolve).catch(reject)`\r\n\r\nHàm `reject` trong `.then(resolve, reject)` chỉ có thể chụp được lỗi từ những `.then()` phía trước nó, mà không thể bắt được lỗi xảy ra trong hàm `resolve` cùng cấp.\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e { throw new Error('Lỗi rồi bạn ei') }, err =\u003e { /* Không có gì ở đây cả */ })\r\n\r\napi.getUser('pikalong')\r\n  .then(user =\u003e { throw new Error('Lỗi rồi bạn ei') })\r\n  .catch(err =\u003e console.log(err)) // Chụp được rồi bạn ei\r\n```\r\n\r\nLưu ý là promise sẽ dừng quá trình thực thi khi bắt được lỗi\r\n\r\n```js\r\nPromise.resolve()\r\n  .then(() =\u003e { throw 'foo' })\r\n  .then(() =\u003e { throw 'bar' }, err =\u003e { console.error(\"here\", err) })\r\n  .catch(err =\u003e console.error('final', err))\r\n\r\n// console:\r\n// \"here bar\"\r\n```\r\n\r\n#### Truyền dữ liệu giữa các promises với nhau\r\n\r\nMột trong những yếu điểm của Promise là không có cơ chế mặc định để bạn truyền dữ liệu giữa các promise objects với nhau. Nghĩa là:\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e api.getPostsByUser(user))\r\n  .then(posts =\u003e {\r\n    // Muốn sử dụng biến user ở trên thì làm sao đây?\r\n  })\r\n```\r\n\r\nMột cách là dùng `Promise.all()`.\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e Promise.all([user, api.getPostsByUser(user)]))\r\n  .then(results =\u003e {\r\n     // Dùng kỹ thuật phân rã biến trong ES6. Bạn lưu ý chúng ta dùng 1 dấu , để\r\n     // tách ra phần tử thứ hai của mảng mà thôi\r\n     const [ , posts ] = results\r\n\r\n     // Lại tiếp tục truyền dữ liệu bao gồm [user, posts, comments] xuống promise sau\r\n     return Promise.all([...results, api.getCommentsOfPosts(posts)])\r\n  })\r\n```\r\n\r\nHoặc, nếu bạn cảm thấy phân tách mảng khó dùng vì phải nhớ thứ tự của các giá trị thì ta có thể dùng object như sau:\r\n\r\n```js\r\napi.getUser('pikalong')\r\n  .then(user =\u003e api.getPostsByUser(user).then(posts =\u003e ({ user, posts })))\r\n  .then(results =\u003e api.getCommentsOfPosts(results.posts).then(comments =\u003e ({ ...results, comments })))\r\n  .then(console.log) // { users, posts, comments }\r\n```\r\n\r\nLại một lần nữa, async/await lại tỏa sáng vì giúp bạn truy xuất đến kết quả của những promises phía trước.\r\n\r\n```js\r\nasync function() {\r\n  const user = await api.getUser('pikalong')\r\n  const posts = await api.getPostsOfUser(user)\r\n  const comments = await api.getCommentsOfPosts(posts)\r\n}\r\n```\r\n\r\n#### Cẩn thận nha, Promise không lazy\r\n\r\nVới đoạn code sau:\r\n\r\n```js\r\nconsole.log('before')\r\nconst promise = new Promise(function fn(resolve, reject) {\r\n  console.log('hello')\r\n  // ...\r\n});\r\nconsole.log('after')\r\n```\r\n\r\nKết quả được in ra console lần lượt sẽ là:\r\n\r\n```bash\r\nbefore\r\nhello\r\nafter\r\n```\r\n\r\nBạn có thể thấy hàm `executor` của Promise được thực thi ngay lập tức. Điều này có thể dẫn đến những kết quả không mong muốn, chẳng hạn như:\r\n\r\n```jsx\r\nconst getUsers = new Promise((resolve, reject) =\u003e {\r\n  return http.get(`/api`, (err, result) =\u003e  err ? reject(err) : resolve(result))\r\n})\r\n\r\nbutton.onclick = e =\u003e getUsers\r\n```\r\n\r\nCách giải quyết là đưa vào một hàm trả về promise.\r\n\r\n```js\r\nconst getUsers = () =\u003e new Promise((resolve, reject) =\u003e {\r\n  return http.get(`/api`, (err, result) =\u003e  err ? reject(err) : resolve(result))\r\n})\r\n\r\nbutton.onclick = e =\u003e getUsers()\r\n```\r\n\r\n#### Cuối cùng, `.finally()`\r\n\r\nBên cạnh `.then()` và `.catch()`, chúng ta còn có `.finally(onFinally)`. Phương thức này nhận vào một hàm và sẽ được kích hoạt dù cho promise trước nó hoàn thành hay xảy ra lỗi.\r\n\r\n```js\r\nshowLoadingSpinner()\r\napi.getUser('pikalong')\r\n  .then(user =\u003e {})\r\n  .catch(err =\u003e {})\r\n  .finally(hideLoadingSpinner)\r\n\r\n// async/await\r\nasync function() {\r\n  try {\r\n    showLoadingSpinner()\r\n    api.getUser('pikalong')\r\n  } catch(err) {\r\n  } finally {\r\n    hideLoadingSpinner()\r\n  }\r\n}\r\n```\r\n\r\nBạn có thể đọc thêm về `Promise.prototype.finally()` [ở đây](https://ehkoo.com/bai-viet/promise-finally-duoc-gioi-thieu-tu-google-chrome-63). Lưu ý là phương thức này hiện chỉ được hỗ trợ bởi Firefox, Chrome và Opera thôi nhé.\r\n\r\n### Kết\r\n\r\nBạn có thể thấy Promise và async/await không hoàn toàn thay thế mà hỗ trợ lẫn nhau. Mặc dù chúng ta có thể dùng async/await ở đa số các trường hợp, Promise vẫn là nền tảng cần thiết khi thực thi các tác vụ bất đồng bộ trong JavaScript. Do đó bạn nên xem xét và lựa chọn giải pháp phù hợp, tùy vào tình hình thực tế nhá.\r\n\r\n#### Đọc thêm\r\n\r\n[_Using Promises_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises) -- MDN\r\n\r\n[_We have a problem with Promise_](https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html) -- Nolan Lawson\r\n\r\n[_Promise is the wrong abstraction_](http://anttih.com/articles/2017/12/25/promise-is-the-wrong-abstraction) -- Antti Holvikari\r\n\r\n[_Promises are not neutral enough_](https://staltz.com/promises-are-not-neutral-enough.html) -- André Staltz\r\n\r\n#### Đính chính\r\n\r\n- Bài viết này ban đầu có nói async/await được giới thiệu trong ES7. Thật ra là ES8 - ES2017 mới đúng. Cám ơn @nhducit đã góp ý."
                }, {
                "id": "YpiTh8C5EQC2rMIL7E_oLw",
                "title": "String + Number =\u003e ????? (JavaScript),String method",
                "content": "![alt](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRLz4UWl-n-VG94ON7MUQjIR3u-Sw4f1MtbXE4kCc1kLk18MuFkEHALDtA)\r\n- các phép cộng trự nhân chia trong lập trình khá quan trọng, ngoài nhưng cái phép cộng trự basic thì nó còn có những phép tính rất khó như các chuỗi + với number chẳng hạn vậy khi có trường hợp như thi máy tính nó sẽ có những result như thê nào nhé !! à ngoài ra các bạn con fđược khuyến mãi thêm cách tách tính toán vị trí trong một String radom, ok vậy bây giờ chúng ta bắt đàu thôi\r\n\r\n\r\n# Tính toán Basic in JavaScript !!\r\n\r\n\u003e qua đây mình cũng giới thiệu về đời mình một tẹo hê hê , hồi trước ấy khi mà mình cũng có học c++ :smile: nó khá hay về cái cộng từ nhân nâng cao, nhưng mình cũng đếch quan tâm nó (nói như kiểu tau đếch quan tâm những thứ ta dell quan tâm =VV),nhưng một thời gian sau khi học java,C,JavaScript,Jquery thì nó toàn khặp những cái kiểu như thế này trong dự án nên rảnh tay viết luôn cái blog này luôn :smile:\r\n \r\n\r\n\r\n **1.**  var a = **546e5**\r\n - e5 tức là nhân lên ấy nếu ở trên a = 54600000(5 con zero)\r\n - ngược lại tức là vả a = 546e-5 tức là chia =\u003e a=0.00546\r\n \r\n **2**  var **0.1 +0.2** =?????;\r\n  ở trong lớp 6,7,8 chúng ta đã học về cộng trự nhân chia nhưng trong Js nó khác đây theo như ở đây result=**0.30000000000000000004**,nó khá lạ =));\r\n- nhưng phép tính ở đây có thể viết như thế này thì nó sẽ khác như :**(1+2)/10** thì kết quả bằng **0.3** trong luôn đấy ??,vì sao vì đây là phép /10 lal fmoojt số tròn chục nên kết quả sẽ khác hản đấy\r\n\r\n**3** number + String like vả a = **20 +\"30\"** \r\nthì theo bạn value của a sẽ đc tính như thế nào ?????? result sẽ là **2030** ok nhưng dữ liệu này đc lưu ở dạng String chứ không phỉa number đâu nhé !!ok\r\n\r\n**4** String +number like : var a = **\"30\"+20** ,vì String là một con qiaus vật hút máu đây ? number mà cộng với nó thì xác định theo String luôn nên khi cộng zầy thì result sẽ là **3020**\r\n**5** tiếp tục với basic String nhé : \"chun\" + \" milion \" =\"chunmilion\"\r\n\r\n**6** nếu nhân thì Sao ??   **\"100\"* \"10\"** result sẽ bằng 100*10=\"1000  khi String * String thì sản phẩm là number đấy\r\n```python\r\nvar x = \"100\";\r\nvar y = \"10\";\r\nvar z = x * y;  \r\nalert(typeof(z));\r\n```\r\n\u003e Console : number\r\n\u003e ngoài nhân ra thì cách này còn áp dụng cho trừ,chia nhé nhưng nó không áp dụng cho + đâu nhé \r\n\r\n# NaN (not a number)\r\n\r\nnếu trong trường hợp nhân chia String ở tên thì nếu như thế này thì kết quả khác đấy nhé !!\r\n ex : 100/\"chun\" =\u003e result = NaN\r\n ok đây là exception đơn giản nên nó khá hiếm khặp đấy\r\n \r\n#String =\u003eArray (HOW??)\r\nfirst,mình có một chuỗi String như sau \"chunngu\" chẳng hạn thì làm sau phân nó thành các phần tử của Array lúc này chúng ta cần dùng function split() để tách cái \"chunngu\" ra thì chúng ta cần sử dụng hàm split như sau \r\n```python\r\nvar chunngu=\"chunngu\";\r\nvar chunnguAfter=chunngu.split(\"\");\r\n```\r\nsau đoạn code này chunnguAfter= array(c,h,u,n,n,g,u)\r\n- thực chất hàm split dùng để cắt chuỗi String bằng các ký tự như space ok \r\n- ngoài hàm Split ra còn có hàm indexof hàm này cho phép ta truy cập đến vị trí của một String trong một String lớn hơn nếu true nó trả về vị trí còn nếu sai nó always trả về -1 nhé , hàm length cũng là một hàm đóng vai trò rất quan trọng tỏng vong lặp loop nó dùng để duyệt và xử lý các dự liệu có trong mảng ex\r\n\r\n``` python \r\nfor( var i =0 ; i\u003c array.length ;i++){\r\n//your code\r\n}\r\n```\r\n \r\n"
                }, {
                "id": "Ag8SLGBfIcU28Olx5Ss8ug",
                "title": "Laravel Mix without Laravel (P2)",
                "content": "Chào các bạn, ở [phần trước](https://kipalog.com/posts/Laravel-Mix-without-Laravel--P1) mình đã hướng dẫn các bạn tích hợp Laravel Mix vào project rồi. Nhưng sau khi làm theo P1 thì mình thấy việc sử dụng Laravel Mix như vậy vẫn khá là nông dân. Vì vậy , hôm nay mình sẽ hướng dẫn các bạn tiếp tục sử dụng nó để **tự động hoá**  mọi việc.\n\n#1. Auto Compile\n\n Việc bạn cần làm duy nhất lúc này là chạy lệnh `npm run watch` thay vì chạy lệnh `npm run dev`.Giờ đây, sau mỗi lần Ctrl+S file thay đổi ở thư mục src/js(sass) thì nó sẽ ngay lập tức được compile sang thư mục public/js(css).  \n \n#2. BrowserSync\n Sau khi chạy lệnh `npm run watch` thì việc compile các file đã đc diễn ra 1 cách tự động rồi, giảm được lượng lớn các thao tác. Giờ các bạn sẽ thêm đoạn code `.browserSync('http://localhost/laravelmix')` vào file **webpack.mix.config** để trình duyệt tự động reload sau mỗi lần có file thay đổi . Chú í bạn cần thay đổi link http://localhost/laravelmix sao cho phù hợp với đường vẫn trỏ đến thư mục của bạn trên local.\n \n#3. Sau tất cả\n \n Tổng kết lại từ P1 -\u003e P2 thì file webpack.mix.js của mình sẽ full nội dung như sau\n \n` let mix = require('laravel-mix');\nmix\n.setPublicPath('public')\n.js('src/js/app.js', 'public/js')\n.sass('src/sass/app.scss', 'public/css')\n.browserSync('http://localhost/laravelmix');`\n\nCác bạn nhớ để í đến cấu trúc thư mục \u0026 lệnh** npm run watch**(giúp compile thay đổi liên tục).\n\nThật ra thì mình có hơi dốt văn chút nên viết bài hơi lủng củng \u003e\u003c . Nếu bạn k hiểu chỗ nào or có góp í gì thì comment phía dưới giúp mình nhé. \nThank guys.\n\n \n \n \n \n \n "
                }, {
                "id": "BOwT4l1iwO1lBG3eova0Pw",
                "title": "Tối ưu hiệu suất MongoDB bằng cách quản lý index",
                "content": "Ai cũng biết đánh index giúp tăng tốc các truy vấn tìm kiếm, tìm kiếm trong cây index (B-Tree) sẽ nhanh hơn scan trong toàn bộ bảng. Ai cũng biết nên không nói nhiều về index là gì nữa :trollface: vậy nhé.\r\n\r\nĐây là [MongoDB users dataset](https://github.com/xluffy/assets/blob/master/users.bson.gz) bạn có thể tải về chơi thử. \r\n\r\n## 1. Sơ sơ về index\r\n\r\nIndex trong Mongo cũng tương tự các cơ sở dữ liệu quan hệ, ví dụ ta có một index được định nghĩa như sau:\r\n\r\n```\r\ndb.users.createIndex({\r\n  user_status: 1\r\n}, {\r\n  background: true,\r\n  name: 'idx_users_by_user_status'\r\n});\r\n```\r\n\r\nCâu trên sẽ nói với database build một index dựa trên giá trị của field `user_status` của collection `users`. \r\n\r\nNgoài ra nó có thêm một tùy chọn là `backgroud: true` để build index ở dạng backgroud, thông thường đánh index sẽ block tất cả các operation khác, và với các collection có kích thước lớn thì việc đánh index sẽ tốn tới vài giờ để hoàn thành và trong thời gian này database sẽ không thể response, đánh index `background` để tránh tính trạng block các operation khác [nhưng không hẳn đời lúc nào cũng như mơ].\r\n\r\nLưu ý là nên chạy query đánh index trong `tmux` để tránh rớt kết nối và để kiểm tra process của index ta có thể truy vấn:\r\n\r\n```\r\ndb.currentOp(\r\n  { \"msg\": /Index Build/ }\r\n);\r\n\r\n\"msg\" : \"Index Build (background) Index Build (background): 3305028/574961784 0%\"\r\n```\r\n\r\nOk, tiếp tục với index phía trên, nó sẽ có tác dụng với các truy vấn tìm kiếm với điều kiện là field `user_status`, ví dụ như sau:\r\n\r\n```\r\ndb.users.find({\r\n  \"user_status\": \"new_user\"\r\n});\r\n```\r\n\r\nKhông có gì phải bàn cãi thêm, truy vấn trên sử dụng index `idx_users_by_user_status` và trả về kết quả với tốc độ của một vị thần gió. :triumph:\r\n\r\nGiờ giả sử, ta có một truy vấn lấy ra tất cả các user `confirmed` NHƯNG trong một tháng của năm 2013 như sau:\r\n\r\n```\r\nvar start = ISODate(\"2013-04-01T00:00:00Z\");\r\nvar end = ISODate(\"2013-04-30T23:59:59Z\");\r\n\r\ndb.users.find({\r\n\t\"user_status\": \"confirmed\",\r\n\t\"created_at\": { $gte: start, $lte: end}\r\n});\r\n```\r\n\r\nTương tự như trên, lấy ra danh sách các `confirmed` khá nhanh chóng do sử dụng index như câu truy vấn trên cùng, tuy nhiên trong danh sách trả ra `confirmed` ta cần lọc thêm một lần nữa để lấy ra các user đăng kí trong tháng đó, và do `created_at` không được đánh index nên có bao nhiêu `confirmed` thì ta cần quét toàn bộ từng đấy.\r\n\r\nĐể giải quyết truy vấn trên, ta cần đánh index trên 2 field, gọi là **compound index** như sau:\r\n\r\n```\r\ndb.users.createIndex({\r\n  user_status: 1,\r\n  created_at: 1 \r\n}, {\r\n  background: true, \r\n  name: 'idx_users_by_user_status_and_created_at' \r\n});\r\n```\r\n\r\nOk, trong có vẻ ngon rồi, truy vấn của chúng ta đã nhanh hơn rồi. Nhưng thử nghĩ xem, chúng ta có thể làm tốt hơn hay không nhỉ?\r\n\r\nGiả sử bạn có 20 triệu register user (hoặc bạn có thể tưởng tượng bạn có 1 tỷ register user và bạn giàu hơn Mark Zuckerberg :slightly_smiling_face: cũng được) `user_status` có các giá trị sau:\r\n\r\n  - new_user\r\n  - confirmed\r\n  - banned\r\n  - deleted\r\n\r\nNếu không có index trên `user_status`, bạn cần quét hết 20 triệu docs này, đánh index trên `user_status` con số giảm từ 20 triệu -\u003e 5 triệu (1/4).\r\n\r\nGiờ giả sử, start-úp mặt của bạn ra đời năm 2015, đến bây giờ là 3 năm, giả sử user đăng kí đồng đều giữa các ngày (thực tế thì đéo phải như vậy đâu  :sweat_smile:). Bạn index lại như sau:\r\n\r\n```\r\ndb.users.createIndex({\r\n  created_at: 1,\r\n  user_status: 1\r\n}, {\r\n  background: true,\r\n  name: 'idx_users_by_created_at_user_status'\r\n});\r\n```\r\n\r\nGiờ với câu truy vấn trên, ta được một danh sách các user đăng ký trong vòng 1 tháng, là cỡ hơn 500 ngàn user (1 ngày có ~ 18 ngàn user đăng ký), sau đó lọc theo điều kiện `new_user` ta chỉ cần quét trong tập 500k user này so với 5 triệu như cách đánh index ban đầu.\r\n\r\nChốt lại, với **compound index** nên đánh index field có giá trị uniqe nhiều hơn trước. Ở trên thì đánh `created_at` trước vì các giá trị trong field này hầu hết đều khác nhau (trong khi `user_status` chỉ có 4 giá trị), nên sẽ giảm được vùng tìm kiếm của truy vấn nhiều hơn.\r\n\r\n## 2. How to improve\r\n\r\nXong xuôi việc đánh index, bây giờ làm cách nào để ta có thể chắc chắn rằng database sẽ sử dụng index một cách hiệu quả? Index cũng như dữ liệu, được lưu trữ trên đĩa cứng, và để index có thể được sử dụng hiệu quả thì tốt nhất là nó nên được đặt trên RAM. Trong Mongo, RAM thì thường được sử dụng để giữ các dữ liệu và index thường xuyên truy vấn (WiredTiger internal cache) tránh phải đọc đĩa thường xuyên. Recommend là 50% physical memory, ví dụ server có 32GB thì WiredTiger internal cache là 15GB.\r\n\r\nNhưng data thì lúc nào cũng lớn hơn RAM, bạn không thể đặt toàn bộ dữ liệu lên Wiredtiger cache được, với index cũng vậy, đánh index thì các truy vấn đọc dữ liệu trên điều kiện sẽ nhanh, nhưng quá nhiều index dư thừa thì gây ra 2 vấn đề:\r\n\r\n- Không thể chứa tất cả các index trên memory.\r\n- Làm chậm các truy vấn ghi dữ liệu như Insert/Update/Delete -\u003e nhưng thực ra \r\nnếu phần ghi chiếm tới 80-95% thì việc đánh đổi cũng đáng kể.\r\n\r\nBạn có thể kiểm tra kích thước tổng thể của index trên cơ sở dữ liệu như sau:\r\n\r\n```\r\ndb.runCommand({ dbStats: 1, scale: 1 });\r\n{\r\n    \"db\" : \"test\",\r\n    \"collections\" : 2,\r\n    \"objects\" : 2000000,\r\n    \"avgObjSize\" : 96.120665,\r\n    \"dataSize\" : 192241330,\r\n    \"storageSize\" : 374370304,\r\n    \"numExtents\" : 0,\r\n    \"indexes\" : 6,\r\n    \"indexSize\" : 53964800,\r\n    \"ok\" : 1\r\n}\r\n```\r\n\r\nCụ thể hơn (dữ liệu này ăn cắp trên production)\r\n\r\n```\r\ndb.stats().indexSize\r\n86508650496\r\n```\r\n\r\n=\u003e kích thước của tất cả các index trên CSDL là 86GB, có nghĩa là index không thể fit hết trên memory, nên khi nào cần sử dụng tới index, nếu index đó không có sẵn trên memory thì cần đọc index đó từ đĩa lên.\r\n\r\nNói chung, xác định bao nhiêu memory là cần thiết không dễ, bạn có thể trả lời vài câu hỏi sau để tự xác định và điều chỉnh memory cho hợp lý:\r\n\r\n- Độ lớn data của bạn là bao nhiêu?\r\n- Độ lớn của index là bao nhiêu?\r\n- Độ phát triển của dữ liệu (trong 1 tháng, 1 năm?)\r\n- Độ lớn của tập dữ liệu thường xuyên truy cập nhất (gọi là working set)?\r\n\r\nVậy chiến lược để giữ index có kích thước nhỏ là như thế nào?\r\n\r\n### 2.1 Xóa các index không sử dụng\r\n\r\n```\r\ndb.users.aggregate([ { $indexStats: {} } ]);\r\n[{\r\n\t\"name\": \"idx_users_by_created_at_user_status\",\r\n\t\"key\": {\r\n\t\t\"created_at\": 1,\r\n\t\t\"user_status\": 1\r\n\t},\r\n\t\"host\": \"6b1b716ae456:27017\",\r\n\t\"accesses\": {\r\n\t\t\"ops\": NumberLong(456550227),\r\n\t\t\"since\": ISODate(\"2018-05-31T15:31:09.020Z\")\r\n\t}\r\n} {\r\n\t\"name\": \"idx_users_by_user_status\",\r\n\t\"key\": {\r\n\t\t\"user_status\": 1\r\n\t},\r\n\t\"host\": \"6b1b716ae456:27017\",\r\n\t\"accesses\": {\r\n\t\t\"ops\": NumberLong(277641131),\r\n\t\t\"since\": ISODate(\"2018-05-31T15:05:39.148Z\")\r\n\t}\r\n} {\r\n\t\"name\": \"_id_\",\r\n\t\"key\": {\r\n\t\t\"_id\": 1\r\n\t},\r\n\t\"host\": \"6b1b716ae456:27017\",\r\n\t\"accesses\": {\r\n\t\t\"ops\": NumberLong(0),\r\n\t\t\"since\": ISODate(\"2018-05-31T15:03:12.197Z\")\r\n\t}\r\n}]\r\n``` \r\n\r\nỞ ví dụ trên, ta có 3 index, ở giá trị `accesses`, ta thấy 2 index đầu tiên được sử dụng rất nhiều lần, trong khi đó index thứ 3 không hề được sử dụng. Con số bao nhiêu là hợp lí để loại bỏ một index tùy thuộc vào số lượng truy vấn và nghiệp vụ của chính bạn, bạn có thể tự cân nhắc, đo lường và loại bỏ nếu không cần thiết.\r\n\r\nCần lưu ý, `ops` có thể bị reset, con số hiện tại thể hiện số lần được sử dụng kể từ `since` -\u003e thời gian mongod được restart.\r\n\r\n### 2.2 Loại bỏ các index dư thừa\r\n\r\n```\r\ndb.users.aggregate([ { $indexStats: {} } ])\r\n[{\r\n\t\"name\": \"idx_users_by_user_status_created_at\",\r\n\t\"key\": {\r\n\t\t\"user_status\": 1,\r\n\t\t\"created_at\": 1\r\n\t},\r\n\t\"host\": \"6b1b716ae456:27017\",\r\n\t\"accesses\": {\r\n\t\t\"ops\": NumberLong(456550227),\r\n\t\t\"since\": ISODate(\"2018-05-31T15:31:09.020Z\")\r\n\t}\r\n} {\r\n\t\"name\": \"idx_users_by_user_status\",\r\n\t\"key\": {\r\n\t\t\"user_status\": 1\r\n\t},\r\n\t\"host\": \"6b1b716ae456:27017\",\r\n\t\"accesses\": {\r\n\t\t\"ops\": NumberLong(277641131),\r\n\t\t\"since\": ISODate(\"2018-05-31T15:05:39.148Z\")\r\n\t}\r\n}]\r\n```\r\n\r\nỞ ví dụ trên, cả 2 index đều được sử dụng. Tuy nhiên index đầu tiên có thể làm cho index thứ 2 trở lên dư thừa, vì các truy vấn chỉ trên điều kiện `user_status` có thể sử dụng index đầu tiên mà không có vấn đề gì.\r\n\r\n### 2.3 Sử dụng sparse index\r\n\r\nĐây là kiểu đánh index trên điều kiện, ví dụ ta có 20 triệu user, nhưng nếu ta chỉ thường truy vấn `user_status` là `new_user` thì ta có thể đánh index riêng với tập `new_user` thôi -\u003e giả sử số lượng `new_user` là 40% trên tổng số user -\u003e index của chúng ta sẽ giảm xuống tới 60% kích thước.\r\n\r\n### 2.4 Giảm bớt kích thước của collection\r\n\r\nCách duy nhất để giảm kích thước của collection đó là ... **xóa dữ liệu**, thực tế có những nghiệp vụ lưu trữ logs, events không cần giữ quá 1-2 năm để tra cứu thì ta có thể xóa bớt các dữ liệu không còn cần thiết (hoặc di chuyển nó sang một CSDL khác với tần suất tuy vấn thấp hơn). Khi kích thước của collection giảm, kích thước của index cũng sẽ giảm theo và data/index có thể fit vừa trên RAM.\r\n\r\n### 2.4 Giữ index đơn giản\r\n\r\nCompound index rất lợi hại trong trường hợp truy vấn dữ liệu trên nhiều điều kiện khác nhau, tuy nhiên nó cũng tốn chi phí bảo trì và dữ liệu càng lớn thì index size sẽ càng tăng nhanh. Tương tự như truy vấn, cố gắng giữ cho index một cách đơn giản nhất có thể.\r\n\r\n## 3. Bonus\r\n\r\nĐáng ra đéo có phần này, [nhưng sợ anh em lại bảo thằng chuyên bài trừ Mongo mà nay lại viết về Mongo](http://whyyoushouldusemongodb.com), thấy sai sai thế éo nào nên phải viết thêm tí.\r\n\r\nThật ra những lý thuyết trên về index và quản lý index đều có thể áp dụng cho các cơ sở dữ liệu quan hệ như MySQL hay PostgreSQL. Ví dụ với PostgreSQL cũng có index trên điều kiện đó là partial index tương tự như sparse index (MySQL thì không biết có không).\r\n\r\nBản chất, nếu để ý sẽ thấy các hệ CSDL có rất nhiều đặc điểm giống nhau (kể cả M$ SQL), lý thuyết này có thể áp dụng cho CSDL khác, và ngược lại. Cốt lõi của vấn đề là **tư duy** về việc **đo lường**, cách thức đo lường và đánh giá hiệu quả của mỗi hành động tác động lên hệ thống\r\n\r\nLần sau sẽ viết thêm về một số thứ liên quan đến metric trong CSDL quan hệ, hỗ trợ cho việc tối ưu hệ thống tương tự như trên MongoDB.\r\n\r\n## 4. Ref\r\n\r\n- https://mixmax.com/blog/improving-mongo-performance-by-managing-indexes\r\n- https://github.com/ozlerhakan/mongodb-json-files\r\n- https://docs.mongodb.com/manual/tutorial/ensure-indexes-fit-ram\r\n\r\n--------\r\n\r\nBài viết gốc được đăng tải tại [https://xluffy.github.io/post/improving-mongodb-perf-by-managing-indexes](https://xluffy.github.io/post/improving-mongodb-perf-by-managing-indexes)"
                }, {
                "id": "wKoN4aJiIU8eJx0_4M34xA",
                "title": "UFO, à nhầm, PMO là cái nồi gì thế?!!",
                "content": "\r\nNhân dịp đọc đến trang 26 cuốn PMP và cũng bắt xuất từ việc hàng tuần mình làm nhiệm vụ thúc giục và nhắc nhở các PM cập nhật báo cáo dự án định kỳ. Trong đó, bản thân cũng là 1 thành viên của buổi họp, chịu trách nhiệm báo cáo các công việc, vấn đề của ban ISO cũng như thư ký buổi họp. \r\n\r\nVũ nhận thấy bản thân mình cần phải hiểu nhiều hơn về lý do cũng như mục đích sâu xa của cuốn PMP hướng đến với 1 buổi PMO đối với công ty là gì? Qua đó điều chỉnh cách thức hoạt động, phương pháp báo cáo và điều phối, ghi chép cho phù hợp tiêu chuẩn.\r\n\r\nVà thực sự thì cũng vì 1 lý do nữa, cái thời kỳ cao trào các sếp học PMP xong, cũng tựa tựa kiểu mình ngày xưa mới đi chuyên tu lần đầu từ trên núi xuống ấy, động cái gì cũng \"theo PMP thì ...\", \"Theo PMO kia...\", làm mình cũng hơi sốt ruột, vì mình dù biết là có tính hợp lý nhưng mà không rõ đã chuẩn chỉnh chưa? Thế là cũng tò mò đọc PMP để khi các sếp nói còn biết đường mà hiểu và xác định sếp mình nói đúng không.\r\n\r\nQuay lại vấn đề nhé, tuy đây chỉ là phần dịch ra từ sách thôi nhưng có vẻ nó cũng khá đủ về lý thuyết rồi. Nào bắt đầu thôi!\r\n\r\n###1. PMO là cái nồi gì vậy?\r\n\r\nPMO (Project Management Office) là một khái niệm được đề cập trong PMP book rất nhiều, nó chỉ cho 1 nhóm hay 1 phòng đặc biệt dành cho công việc quản lý chung mà ở đó tập trung (centralizes) và chuẩn hóa (standardizes) việc quản lý các dự án của tổ chức (Một số nơi gọi đây là Portfolio Management Office). Trong thực tế, PMO có thể có một vài hình thức khác nhau như sau:\r\n\r\n**Supportive:** PMO cung cấp các chính sách, phương pháp, biểu mẫu và các bài học kinh nghiệm phục vụ cho việc quản lý các dự án trong tổ chức. PMO dạng thể này có mức độ kiểm soát/tác động thấp đến quản lý các dự án của Project Manager.\r\n\r\n**Controlling:** PMO dạng thể này tác động cao hơn là ngoài support ra (ở mức trung bình), PMO còn phải thực hiện thêm việc hướng dẫn cách quản lý các dự án, đào tạo người khác cách sử dụng các phần mềm quản lý dự án, thậm chí hỗ trợ vận hành các công cụ quản lý dự án đặc thù, mục đích phục vụ yêu cầu dự án.\r\n\r\n**Directive:** PMO dạng thể này có tác động đến việc quản lý dự án cao nhất, PMO phân bổ mỗi dự án một Project Manager riêng biệt và chịu trách nhiệm kết quả dự án đó, dự án đây có thể có quy mô lớn hay nhỏ đều dưới sự quản lý của PMO.\r\n\r\n### 2. Quyền hạn của PMO\r\n\r\nTrong đề thi PMP có thể hỏi về quyền hạn (Authority) của PMO, và các bạn cẩn thận bị nhầm lẫn với quyền hạn của Project Manager. PMO là 1 bộ phận thuộc tổ chức, chứ không phải 1 cá nhân riêng lẻ nào. Sau đây là một số authority của PMO:\r\n\r\n'1. Quản lý sự phụ thuộc (interdependency) giữa project, program, portfolio.\r\n\r\n'2. Thu thập thông tin từ tất cả các dự án và đánh giá xem liệu tổ chức có đạt được mục tiêu -  chiến lược hay không\r\n\r\n' 3. Giúp cung cấp tài nguyên.\r\n\r\n' 4. Đề nghị kết thúc dự án khi thích hợp\r\n\r\n'5. Theo dõi việc tuân thủ quy trình tổ chức.\r\n\r\n'6. Giúp thu thập các bài học kinh nghiệm và phân bổ/làm cho các dự án khác có thể tái sử dụng được bài học kinh nghiệm này.\r\n\r\n'7. Cung cấp mẫu (ví dụ: đối với cấu trúc phân tích công việc hoặc kế hoạch quản lý truyền thông).\r\n\r\n'8. Cung cấp hướng dẫn và quản trị dự án.\r\n\r\n'9. Cung cấp việc communication tập trung đối với các dự án.\r\n\r\n'10. Được tham gia nhiều hơn từ quá trình khởi động dự án (ngay từ đầu)  thay vì tham gia vào từ các giai đoạn sau của  dự án.\r\n\r\n'11. Một phần của CCB (Change control board - ban kiểm soát thay đổi).\r\n\r\n'12. Là một stakeholder (bên liên quan) trong project team.\r\n\r\n'13. Prioritize projects. (Ưu tiên các dự án)\r\n\r\nNgoài ra trong đề thi PMP có thể hỏi bạn loại PMO hay dạng thể PMO là gì khi đưa ra dữ kiện, lúc này bạn cần phải xác định PMO là dạng thể Supportive, Controlling hay Directive.\r\n\r\n\r\n### 3. Nguyên gốc trong bản 8th PMP\r\n\r\nThe project management office (PMO) centralizes and standardizes the management of projects. (Note that some organizations refer to this as a portfolio management office.) A PMO can take one of several different forms, including: \r\n\r\nSupportive: A supportive PMO provides the policies, methodologies, templates, and lessons learned for managing projects within the organization. It typically exercises a low level of control over projects. \r\n\r\nControlling: A controlling PMO provides support and guidance in the organization on how to  manage projects, trains others in project management and project management software, assists  with specific project management tools, and ensures compliance to organizational practices. It  typically has a moderate level of control over projects. \r\n\r\n Directive:  A directive PMO provides project managers for different projects, and is responsible for the results of those projects; all projects, or projects of a certain size, type, or influence, are managed by this office. A directive PMO has a high level of control over projects. \r\n \r\n Be careful to understand the authority of the PMO and how it is different from the other players on a project. The PMO is a departmental unit within an organization; it is not a single person. The PMO may: \r\n \r\n Manage the interdependencies among projects, programs, and portfolios. \r\n\r\nIntegrate information from all projects to assess whether the organization is achieving its strategic \r\nobjectives. \r\n\r\nHelp provide resources. \r\n\r\nRecommend the termination of projects when appropriate. \r\n\r\nMonitor compliance with organizational processes. \r\n\r\nHelp gather lessons learned and make them available to other projects. \r\n\r\nProvide templates (e.g., for work breakdown structures or communications management plans). \r\n\r\nProvide guidance and project governance. \r\n\r\nProvide centralized communication about the projects. \r\n\r\nBe more heavily involved during project initiating than later in the project. \r\n\r\nBe part of the change control board. \r\n\r\nBe a stakeholder. \r\n\r\nPrioritize projects. "
                }, {
                "id": "ssSCkkMXsKiF7M8ba0Kn2g",
                "title": "Lightning Network là cái quái gì vậy?",
                "content": "### Blockchain chậm và đắt đỏ\r\n**Bitcoin** xử lý tối đa 7 giao dịch mỗi giây, không phải cho từng người tham gia, mà là toàn mạng lưới.  \r\n**Ethereum** xử lý 15 giao dịch chuyển tiền, 3-5 hợp đồng thông minh mỗi giây.  \r\n\r\nĐây là một con số quá nhỏ so với nhu cầu giao dịch toàn cầu (so sánh với con số giao dịch bằng thẻ Visa trung bình 2000 lượt mỗi giây).  \r\n\r\nNếu phải mất hàng giờ (cùng với một khoản phí giao dịch đắt đỏ) để một giao dịch chuyển tiền đơn giản được thực hiện, ai còn muốn sử dụng Bitcoin nữa.  \r\n\r\n**Lighting Network** là một trong các ý tưởng về giải pháp cho vấn đề này.  \r\nTrước khi đi vào tìm hiểu giải pháp này, chúng ta cần hiểu được vấn đề gì đang diễn ra.  \r\n\r\n### Tại sao Blockchain lại chậm?\r\n\u003e \"I am a slow walker, but I never walk back.\" - Abraham Lincoln\r\n\r\nTưởng tượng **Blockchain** như 1 tập hồ sơ (**chain**), bao gồm nhiều tờ giấy (**block**), mỗi tờ giấy ghi chép các giao dịch.  \r\nNgay sau khi một tờ giấy được ghi đầy các giao dịch, nó cần thiết được đưa vào tập hồ sơ trước khi bắt đầu ghi chép giao dịch mới vào tờ giấy tiếp theo.  \r\nTrước khi tờ giấy (block) được cho vào tập hồ sơ (chain), có một vài thao tác cần phải làm để đảm bảo tất cả mọi người tham gia đều đồng ý với nội dung trong tờ giấy đó.  \r\nCác thao tác này thường mất khoảng **10 phút** (với Bitcoin) cho mỗi block.  \r\n(Tìm hiểu thêm về các thức hoạt động của Blockchain ở [đây](https://1upnote.me/post/2018/01/block-chain-la-gi) nhé)\r\n\r\nGiả sử bạn gửi 1 BTC cho bạn mình là Joe. Giao dịch sẽ trông như sau:  \r\n![alt](https://1upnote.me/images/2018/02/1*y24i5MVq6YNUPwrRqqRwuw.png)\r\n\r\nGiao dịch bao gồm thông tin về người gửi, người nhận, số lượng gửi, và phí giao dịch.  \r\n\r\n### Phí giao dịch là cái quái gì vậy?\r\n\u003e \"A consultant is someone who saves his client almost enough to pay his fee.\" - Arnold H. Glasow\r\n\r\nBạn sẽ phải trả phí cho việc giao dịch.  \r\nPhí này để thưởng cho các thợ mỏ nhằm giúp cho giao dịch của bạn được thêm vào block càng sớm càng tốt.  \r\nKhông có giá chung, nhưng nếu bạn càng trả nhiều thì giao dịch của bạn sẽ càng được ưu tiên cao và càng nhanh được thực hiện.  \r\n\r\nTrong cùng một thời điểm, sẽ có rất nhiều các giao dịch xếp hàng để được thực hiện.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*6xcxo4rHHzUQhutAy_6MKw.png)\r\n\r\n**Thợ mỏ** (hiểu nôm na là các máy tính kết nối vào mạng Blockchain) sẽ quyết định xem giao dịch nào được thêm vào block hiện tại. Tiêu chí để quyết định sẽ làm giao dịch nào có phần thuưởng nhiều nhất, tương ứng với việc phí giao dịch được trả cao nhất.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*1XZuQ_jUdMXVyuwKXSlrBg.png)\r\n\r\nNếu số lượng giao dịch với phí giao dịch cao hơn giao dịch của bạn lấp đầy block, giao dịch của bạn sẽ xếp hàng đợi.  \r\nTuỳ theo tình trạng lúc đó mà bạn chỉ phải chờ vài phút, hoặc vài giờ, vài ngày.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*cUMcKGZx7p-OQKUlMUcGJA.png)\r\n\r\nĐó là lý do tại sao Blockchain lại trở nên chậm và đắt sau khi càng nhiều người bắt đầu sử dụng nó. Điều này trở thành rào cản cho việc Blockchain được sử dụng rộng rãi vào các giao dịch thường nhật.  \r\n\r\n**Và Lightning Network được cho là giải pháp khả thi cho vấn đề này.**\r\n\r\n### Lighting Network (LN) là gì?\r\n\u003e “Thunder is good, thunder is impressive; but it is lightning that does the work.” — Mark Twain\r\n\r\nÝ tưởng của LN là không phải tất cả các giao dịch cần thiết phải ghi lại trên Blockchain.  \r\n\r\nTưởng tượng rằng tôi và bạn giao dịch qua lại với nhau nhiều lần. Vậy chúng ta có thể bỏ qua việc ghi chép các giao dịch ở giữa mà chỉ ghi chép lại kết quả lên Blockchain.  \r\nNói đơn giản LN sẽ mở một kênh giao dịch giữa hai người và lưu lại việc kênh được mở lên Blockchain. Kênh này có thể giữ trạng thái mở trong vài giờ, vài ngày, vài tuần hay thậm chí vài thế kỷ.  \r\nHai người sẽ giao dịch thông qua kênh này. Và chỉ khi nào kênh được đóng lại, kết quả cuối chùng sẽ được ghi lại vào Blockchain.  \r\n\r\nBằng cách này, chúng ta có thể tạo một mạng lưới các kênh giao dịch, mà không cần kết nối liên tục đến Blockchain.  \r\n\r\nTưởng tượng rằng ta có 3 nhân vật: Xan, Yelena và Zeke.  \r\nNếu giữa Xan và Yelena mở một kênh giao dịch, giữa Yelena và Zeke cũng mở một kênh giao dịch, Xan có thể gửi tiền cho Zeke thông qua Yelena.  \r\nĐó là ý tưởng của **Lightning Network**. Bằng việc không thường xuyên chạm đến Blockchain, giao dịch sẽ được diễn ra với tốc độ ánh sáng (lighting speed).\r\n\r\n### Kênh giao dịch hoạt động như thế nào ?\r\n\u003e“Individually, we are one drop. Together, we are an ocean.” — Ryunosuke Satoro\r\n\r\nKênh giao dịch giống như một chiếc hộp an toàn đựng tiền của 2 người. Họ cùng cho vào đó một khoản tiền giống nhau, và cùng đặt khoá lên đó.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*d7Sg7eEAADFRnay2qRg_NQ.png)\r\n\r\nHành động 2 người cùng bỏ một khoản tiền vào chiếc hộp được ghi lại trên Blockchain, dưới hình thức **Mở kênh giao dịch**.  \r\nÝ tưởng của việc khoá khoản tiền vào chiếc hộp là để không ai có thể tiêu khoản tiền nếu không có sự đồng ý của người kia. Khoản tiền  mỗi người cho vào trong chiếc hộp sẽ chỉ được dùng để giao dịch giữa 2 người với nhau.  \r\n\r\nQuay lại ví dụ, Xan va Yelena mỗi người bỏ 10 BTC vào chiếc hộp chung. Giờ nếu Xan muốn chuyển 2 BTC cho Yelena, anh ta chỉ việc hứa sẽ chuyển quyền sở hữu 2 BTC của anh ta trong chiếc hộp cho Yelena.  \r\n\r\n\u003e Đây chưa phải là quyền sở hữu thật mà chỉ là **hứa hẹn**.  \r\n\u003e Quyền sở hữu thật sẽ chỉ được chuyển khi giao dịch được **ghi lại trên Blockchain**. \r\n\r\nSau giao dịch này, nếu chiếc hộp được mở, quyền sở hữu sẽ được chuyển đổi, Xan sẽ được lấy 8 BTC, Yelena sẽ được lấy 12 BTC từ nó.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*-aRVAsOvGsL5gcdV0I2sKA.png)\r\n\r\nNếu họ không mở chiếc hộp ngay họ có thể tiếp tục giao dịch. Đây là điểm mấu chốt.  \r\nVào ngày hôm sau, Yelena muốn gửi 1 cho Xan, cô ta làm điều tương tự, hứa hẹn chuyển quyền sở hữu 1 BTC của cô ta trong chiếc hộp cho Xan.  \r\nSau 2 giao dịch, nếu chiếc hộp được mở, Xan sẽ được lấy 9 BTC, Yelena được lấy 11 BTC.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*zmg15wB-gP9NvL5muudfNQ.png)\r\n\r\nTóm lại kênh giao dịch đơn giản là sự kết hợp của việc cùng góp chung một khoản tiền và chuyển giao qua lại hứa hẹn quyền sở hữu số tiền góp chung đó.  \r\nXan hoặc Yelena đều có thể đóng kênh giao dịch. Đóng kênh giao dịch đơn giản là mở chiếc hộp ra và lấy số tiền bên trong nó.  \r\nMở chiếc hộp sẽ lưu lại thông tin quyền sở hữu lên Blockchain.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*sMdtU5-5tE7pwrKVN2MEKQ.png)\r\n\r\nĐó là cách kênh giao dịch hoạt động.  \r\nNhưng nó chỉ thực sự phát huy sức mạnh khi mà có nhiều kênh giao dịch hoạt động cùng nhau tạo thành mạng lưới - **Lightning Network**.\r\n\r\n### Lighting Network hoạt động như thế nào?\r\n\u003e “Great things are done by a series of small things brought together.” — Vincent Van Gogh\r\n\r\nLighting Network hoạt động thông qua việc thay đổi từ chuyển giao quyền sở hữu sang **hứa hẹn** chuyển giao quyển sở hữu.\r\nĐây là một bước đi quan trọng. \r\n\r\n\r\n3 người: Xan, Yelena, Zeke có 2 kênh giao dịch được mở giữa Xan và Yelena, Yelena và Zeke.  \r\nXan muốn chuyển 2 BTC cho Zeke, anh ta yêu cầu Yelena chuyển hứa hẹn quyền sở hữu 2 BTC cho Zeke thông qua kênh của Yelena và Zeke, sau đó anh ta chuyển hứa hẹn quyền sở hữu 2 BTC của anh ta cho Yelena thông qua kênh của Xan và Yelena.  \r\n\r\n![alt](https://1upnote.me/images/2018/02/1*N3z_ylP8YpGy1DFAalhWlA.png)\r\n\r\nBằng cách này, hàng ngàn giao dịch có thể được thực hiện mà không cần chạm đến Blockchain, đồng nghĩa với việc đẩy nhanh tốc độ giao dịch và giảm phí thực hiện giao dịch.  \r\n\r\n--------------------------------------\r\nDịch nôm na từ bài viết của pro Mohit Mamoria ở [đây](https://hackernoon.com/lightning-network-explained-d4615c12ad09).\r\nBài cùng nội dung trên blog của mình ở [đây](https://1upnote.me/post/2018/02/lighting-network-la-gi/)."
                }, {
                "id": "tTu_m5wf1Gy2jWuRyk0wQw",
                "title": "Mô hình MVC ? (Cụ già của Php,...) , và thư viện Css,JavaScript",
                "content": "![alt](https://i.stack.imgur.com/SFdgC.png)\r\n\r\n\r\n## Tổng quan về  mô hình MVC \r\n\r\n\u003e Thường thường, mình thấy mọi người thường nói về khái niệm rồi mới sang chức năng \r\n bla bla..... , nhưng theo mình nó không ổn khi như vậy nó làm khó hiểu cho người đọc nên mình sẽ nói về chức năng trước nhé !!\r\n \r\n \r\n##chức năng (tầm quan trọng)\r\n \r\n - MVC có các trình tự xử lý dữ liệu rất rõ ràng \r\n - ngoài ra, MVC còn giúp người dùng dễ hình dung \r\n - nó áp dụng vào thực tiễn khá nhiều,khá dễ bảo trì\r\n - đây là một mô hình rất lâu dài đến bây giờ nó vẫn là môt mô hình khá hay \r\n\r\n\r\n## Nhược điểm \r\n\r\n\u003echúng ta không thể không nghi ngờ về khả năng của nó được chúng ta cần biết nó có nhược điểm không sau đây mình xin nói : \r\n\r\n- MVC áp dụng trong một dự án khá nhỏ nó không khả dụng với một số dự án lớn\r\n- MVC đôi lúc vẫn gây khó hiểu =)) và gây rắc rối\r\n\r\n## Khái niệm\r\n- MVC tức là sao ??\r\n- M tức là model ,model xử lý các data bằng các funtion,bla bla... \r\n- V tức là View nơi đây là nơi nhận hàng từ C  nó sẽ view cho user\r\n- C tức là control là nơi tương tác với người dùng và nơi tương tác với M \r\n\r\n## Cơ chế hoạt động\r\n\r\n\r\n- Cái này thì nó khá dễ vì liên quan tới thực tế khá nhiều chúng ta cùng xem nhé \r\n\r\n\r\n\u003e cái này hơi ngoài lề :))) c\r\n\r\n\r\n  \r\n Ai cũng đã từng ăn cơm mẹ nấu chưa nhỉ ??? ( đếch cần hỏi ) để nấu nó thì cũng là một quá trình đấy \r\n \u003eđầu tiên câu bạn thốt lên là gì ? mình thì đóng vai trò làm user nhé !!! khi con đói thì nó nói câu :\r\n \r\n \r\n -  mẹ ơi !! con đói rồi mẹ ạ !! \r\n\r\n\r\n \u003e sau đố mẹ sẽ đóng vai trò làm Control sẽ nhận request từ user là con  và gửi lên M(model) khi đó model sẽ xử lý là lấy gạo đổ vào nồi rồi cho nước vào nấu lên , và trong lúc nấu thì mẹ sẽ nói : \r\n \r\n - đợi xúy nhé con !\r\n\r\n\r\n\r\n \u003ekhi nấu xong sẽ có thành quả và V(View) sẽ up data lên user và request cảu user đc xử lý , cũng như mẹ đưa cơm cho xon ăn thôi !!\r\n \r\n\r\n\r\n\r\n\r\n## Hết ăn cơm rồi sang ăn thư viện thôi =(((\r\n\r\n\u003ephần này mình sẽ viết bằng tiếng anh để luyện trình độ tiếng anh nếu có sai sót thì mọi người góp ý nha !!!\r\n\r\n### What is library ??????\r\n- library is a extension that they can help you code master and better and you don't need to code css,or some animation ,it variable in library =))\r\n\r\n### What is Famous Library ??\r\n- AOS is the library that this can help you help a event of Scroll by JavaScript or Jquery ,this can help you Css if you don't want css you can add this\r\n- Trowel is the library that this can have all yours Css it can make yours Css code easy to read \r\n\r\n![alt](https://viblo.asia/uploads/4d82ca3d-e2f2-4938-a860-d7a5c221ef4d.jpg)\r\n\r\n\r\n\u003ethis Img I copy in viblo,this have many library in viblo \r\n\r\n## have a good day !! =)) \r\n "
                }, {
                "id": "CaRI4fgU5Js6m-_4CafQFA",
                "title": "Functional Programming - Phần 3 - Buông bỏ",
                "content": "- [Phần 1: Con đường sáng](https://kipalog.com/posts/Functional-Programming---Phan-1---Con-duong-sang)\r\n- [Phần 2: Nhập đạo](https://kipalog.com/posts/Functional-Programming---Phan-2---Nhap-dao) \r\n- Phần 3: Buông bỏ\r\n\r\n\r\nFunctional Programming là một con đường khác, một phương pháp tư duy khác trong coding. Ở tầm nhìn trừu tượng hơn, người ta xếp Functional Programming vào nhóm \"Declarative\", còn OOP thuộc nhóm \"Imperative\".\r\n\r\nTừ các bài học ngữ pháp chúng ta đã biết 2 kiểu câu: câu trần thuật (Declarative Sentence), và câu mệnh lệnh (Imperative Sentence).\r\n\r\nLập trình theo lối \"Imperative Programming\" là sắp xếp một loạt các mệnh lệnh liên tiếp, để máy tính thực thi tuần tự từng bước. Ở đây người ta tập trung vào \"how\". Nào, hãy làm thế này, rồi làm thế kia... Một hình thức \"cầm tay chỉ việc\". \r\n\r\nVí dụ trên trang web có 4 boxes màu đỏ thế này:\r\n\r\n```\r\n\u003cstyle\u003e\r\n.box {\r\n  width: 100px;\r\n  height: 100px;\r\n  float: left;\r\n  margin: 10px;\r\n  background-color: red;\r\n}\r\n.hide {\r\n  display: none;\r\n}\r\n\u003c/style\u003e\r\n\u003cdiv class=\"box hide\"\u003e\u003c/div\u003e\r\n\u003cdiv class=\"box hide\"\u003e\u003c/div\u003e\r\n\u003cdiv class=\"box hide\"\u003e\u003c/div\u003e\r\n\u003cdiv class=\"box hide\"\u003e\u003c/div\u003e\r\n\r\n```\r\n\r\nMấy boxes này đang ẩn, ta cần làm chúng hiện ra bằng cách loại bỏ class \"hide\" đi.\r\n\r\nCác giáo viên tin học đáng kính ở trường xưa thường dạy viết kiểu như thế này:\r\n\r\n```\r\n// tìm hết các tags có class \"box':\r\nconst els = document.querySelectorAll('.box');\r\n// quét tất cả các tags tìm thấy\r\nfor (let i = 0; i \u003c els.length; i++) {\r\n  // với tag thứ i\r\n  let el = els[i];\r\n  // xóa bỏ class \"hide\" để cho tag hiện lên\r\n  el.classList.remove('hide');\r\n  // nếu còn phần tử phía sau thì tăng i lên 1 đơn vị\r\n  // quay lại với xử lý tag thứ i + 1\r\n}\r\n```\r\n\r\nHọ dùng code hướng dẫn cho máy tính làm từng nhiệm vụ.\r\n\r\nNgười tu luyện Functional Programming không tư duy theo cách đó.\r\n\r\n### No for/while\r\n\r\n \"Declarative Programming\" là tập trung vào \"what\". Chúng ta chỉ cần định nghĩa những quy tắc đầu vào, đầu ra. Chẳng hạn \"nếu input là 1 thì output là 2\". Phần còn lại để máy tính xử lý.\r\n\r\nNgười tu luyện Functional Programming không cần for loop.\r\n\r\nCode như thế này nhìn mới mẻ hơn nhiều:\r\n\r\n```\r\nconst getElements = (selector) =\u003e {\r\n  return Array.from(document.querySelectorAll(selector));\r\n};\r\n\r\nconst getRemover = (el) =\u003e {\r\n  return (className) =\u003e {\r\n    el.classList.remove(className);\r\n    return el;\r\n  };\r\n};\r\n\r\nconst els = getElements('.box')\r\n  .map(getRemover)\r\n  .map(removeClass =\u003e removeClass('hide'));\r\n  \r\nconsole.log(els);\r\n```\r\n\r\nTrước tiên chúng ta tạo ra 1 pure function `getElements` dùng để lấy các elements trên trang thông qua CSS Selector. Tập hợp này vốn là ArrayLike, ta dùng `Array.from` chuyển thành Array thực sự để có thể tận dụng các phương thức trong Array prototype.\r\n\r\nỞ đây ta định nghĩa input là CSS Selector, output là 1 mảng DOM Elements.\r\n\r\nCòn `getRemover` lại là 1 higher-order function. Có thể gọi nó bằng cách chaining `getRemover(DOMElement)(classToRemove)`. Chúng ta lợi dụng đặc tính của higher-order function, sau 2 lần map thì chạm tới function do `getRemover` ném lại.\r\n\r\nỞ đây ta định nghĩa input là DOM Element, output là `function() {nhận input là className và output là DOM Element đã mất đi class đó}`.\r\n\r\nCode như vậy ta có thể đem logic dùng lại ở nhiều chỗ khác nhau, chỉ cần thay đổi input. Ví dụ loại bỏ class `float-left` khỏi tất cả các thẻ div.\r\n\r\n```\r\nconst els = getElements('div')\r\n  .map(getRemover)\r\n  .map(removeClass =\u003e removeClass('float-left'));\r\n```\r\n\r\n### No if/else\r\n\r\nNgười tu luyện Functional Programming cũng không cần if/else.\r\n\r\nThậm chí họ còn tạo ra cả một chiến dịch [Anti-IF](https://francescocirillo.com/pages/anti-if-campaign)!\r\n\r\nCó nhiều cách để loại bỏ hoàn toàn `if/else` ra khỏi chương trình của bạn. Đơn giản nhất là dùng ternary.\r\n\r\n#### Ternary\r\n\r\nTrong JavaScript, ternary - tam phân - có tên gọi chính thức là Toán tử Điều kiện - Conditional Operator. Nó là cách viết ngắn gọn của `if/else`.\r\n\r\nHãy xem đoạn code dài dòng, rẽ nhánh phức tạp như sau:\r\n\r\n```\r\nlet title = 'Mr.';\r\nif (person.gender === 'female') {\r\n  if (!person.gotMarried) {\r\n    title = 'Ms.';\r\n  } else {\r\n    title = 'Mrs.';\r\n  }\r\n}\r\n```\r\n\r\nCó thể được viết gọn lại thành:\r\n\r\n```\r\nconst title = person.gender === 'female' ? (!person.gotMarried ? 'Ms.' : 'Mrs.') : 'Mr.';\r\n```\r\n\r\nKhông còn `if/else` nữa.\r\n\r\nTa cũng vô hình trung loại bỏ được `var`, `let` vì không cần gán lại giá trị cho `title`.\r\n\r\n#### Logical operators\r\n\r\nCách thứ 2 là khai thác sức mạnh ngầm của các logical operators `\u0026\u0026`, `||`. Đây là những toán tử logic. Hôm trước có bạn viết  [1 cái TIL ngắn](https://kipalog.com/posts/--va--) khá hay. Sau đây ta quan sát chúng kỹ hơn qua lăng kính Functional Programming.\r\n\r\nGiả sử có đoạn code như sau:\r\n\r\n```\r\nconst sayHello = () =\u003e {\r\n  console.log('Hello, bonjour, nihao');\r\n  return true;\r\n};\r\n\r\nconst doNothing = () =\u003e {\r\n  console.log('Do nothing');\r\n  return false;\r\n};\r\n\r\nconst greet = (hasClient) =\u003e {\r\n  if (hasClient) {\r\n    sayHello();\r\n  } else {\r\n    doNothing();\r\n  }\r\n}\r\n\r\ngreet(true); // =\u003e 'Hello, bonjour, nihao'\r\ngreet(false); //=\u003e 'Do nothing'\r\n```\r\n\r\nVề mặt logic, hàm `greet()` kiểm tra điều kiện nếu có khách thì chào, nếu không thì không làm gì cả.\r\n\r\nTheo định nghĩa của `\u0026\u0026`  và `||`, chúng ta biết:\r\n\r\n- `expr1 \u0026\u0026 expr2`  trả về `expr1` nếu `expr1` là falsy, ngoài ra nó trả về `expr2`. \r\n\r\nMột điều thú vị ở đây là JavaScript engine luôn ước lượng giá trị biểu thức logic dạng này từ trái sang phải và theo nguyên tắc \"đoản mạch\" - [short-circuit evaluation](https://en.wikipedia.org/wiki/Short-circuit_evaluation)\".  Tiên hữu nào giỏi Vật lý chắc còn nhớ hiện tượng \"đoản mạch\", đó là khi dòng điện không chạy qua tải hoặc chỉ chạy qua một phần.\r\n\r\nVì AND chỉ trả về `true` nếu cả 2 mệnh đề cùng đúng, nên ngay khi bắt gặp `expr1` sai, nó lập tức kết luận mệnh đề ghép là Sai và chấm dứt tại đó luôn, không chạy qua nửa bên phải `expr2` nữa.\r\n\r\n- `expr1 || expr2`  trả về `expr1` nếu `expr1` là truthy, ngoài ra nó trả về `expr2`. \r\n\r\nVì OR trả về `true` nếu ít nhất 1 mệnh đề đúng, nên ngay khi bắt gặp `expr1` đúng, nó lập tức kết luận mệnh đề ghép là Đúng và bỏ qua `expr2`. \r\n\r\nShort-circuit thần thánh! \r\n\r\nCác lập trình viên kinh nghiệm thường lợi dụng đặc điểm này để tối ưu hiệu suất chương trình. Họ để các biểu thức tính toán phức tạp ở nửa sau của biểu thức logic. Như vậy, khi chưa rơi vào hoàn cảnh thích hợp, chúng sẽ bị bỏ qua, không cần tốn resource xử lý.\r\n\r\nTới đây, ta đã có thể viết lại hàm `greet()` một cách bí hiểm như sau:\r\n\r\n```\r\nconst greet = (hasClient) =\u003e {\r\n  return (hasClient || doNothing()) \u0026\u0026 sayHello();\r\n}\r\n```\r\n\r\nBắt đầu phần nằm trong ngoặc đơn bên trái `\u0026\u0026`. Nếu `hasClient` là `true` thì giá trị phần này cũng là `true`, `doNothing()` bị bỏ qua.\r\n\r\nVì phần bên trái của `\u0026\u0026` là `true` nên cuối cùng, giá trị biểu thức quy về phần bên phải `\u0026\u0026`, tức là `sayHello()`.\r\n\r\nLập luận tương tự cho trường hợp `hasClient` là `false`, dòng chảy chương trình lập tức rẽ sang `doNothing()`. Lúc này giá trị nửa bên trái `\u0026\u0026` là `false`, do đó không cần quan tâm đến `sayHello()` nữa.\r\n\r\nViết như trên vừa độc vừa lạ, vừa khử được `if/else`, mà vẫn hoàn toàn ăn khớp với điều kiện quy ước. \r\n\r\nTuy nhiên, logical operators nếu nhìn không quen thì có vẻ hơi khó hình dung mạch suy diễn của chương trình. Tôi chỉ đưa ra đây để các tin hữu tham khảo. Trong dự án thực tế, vẫn nên dùng ternary cho đỡ hại não đồng đội:\r\n\r\n```\r\nconst greet = (hasClient) =\u003e {\r\n  return hasClient ? sayHello() : doNothing();\r\n}\r\n```\r\n\r\n#### Logical functions\r\n\r\nMột cách tiếp cận khác thể hiện tinh thần Functional Programming quyết liệt hơn, đó là tạo ra các hàm đặc trách nhiệm vụ xử lý logic. Ví dụ trong [Ramda.js](https://ramdajs.com) và [Sanctuary](https://sanctuary.js.org) đều có `ifElse` ,  `unless` , `when`, và hàng chục hàm logic khác. \r\n\r\nHàm `greet` nếu viết lại với Ramda sẽ trở nên xinh xắn như thế này:\r\n\r\n```\r\nconst R = require('ramda');\r\n\r\nconst greet = R.ifElse(R.identity, sayHello, doNothing);\r\n```\r\n\r\nĐó là vẻ đẹp đầy tính nghệ thuật của Function Composition. Bạn cứ ngắm nhìn nó và đừng nói gì cả! Composition cũng có nghĩa là tác phẩm, như thơ của Paul Verlaine hay nhạc của Beethoven.\r\n\r\n### No new/this\r\n\r\nCó 2 thứ luôn khiến Brendan Eich cảm thấy hài lòng khi [kể về lịch sử JavaScript](https://brendaneich.com/2008/04/popularity/), đó là first-class function và prototype mechanism.\r\n\r\nNgày nay, hầu hết developer đều biết rằng thừa kế trong JavaScript là prototype-based inheritance. Nhưng ở thời kỳ web còn hoang sơ, người ta hay dùng `new` và các hàm constructors để lập trình OOP trong JavaScript theo kiểu class-based, giống như bên Java vẫn làm.\r\n\r\n#### Classical inheritance\r\n\r\nCổ thư ghi lại rất nhiều ví dụ kiểu này:\r\n\r\n```\r\nfunction Dog(name) {\r\n  this.name = name;\r\n  this.say = function() {\r\n    console.log('woof-woof, my name is ' + this.name);\r\n  }\r\n}\r\n\r\nvar rocky = new Dog('Rocky');\r\nrocky.say();\r\n\r\nvar molly = new Dog('Molly');\r\nmolly.say();\r\n```\r\n\r\nHàm `Dog` gọi là Function Constructor, các tiền bối chân giới Đại Việt thủa trước chuyển ngữ thành \"hàm dựng\". Còn chúng ta thời nay có lẽ cứ nên giữ nguyên văn.\r\n\r\n#### Prototypal inheritance\r\n\r\nSang đầu kỷ thứ 3, ở tông môn Yahoo! có một vị trưởng lão tu vi rất cao thâm tên là [Douglas Crockford](https://en.wikipedia.org/wiki/Douglas_Crockford) tung ra bộ kỳ thư \"JavaScript: The Good Parts\", trong đó có đoạn nhấn mạnh bản chất prototype trong JavaScript, sự khác biệt giữa classical inheritance và prototypal inheritance. Ông cho rằng từ khóa `new` mang theo nhiều điểm bất cập, nên khuyến khích dùng `Object.create` để sao chép nguyên mẫu sang đối tượng kế thừa. \r\n\r\nTư tưởng của Douglas Crockford quả thực mới mẻ. Vào lúc đó, nhiều JavaScript engine còn chưa kịp hỗ trợ `Object.create`. Cuốn này vừa ra mắt đã gây náo loạn cả tin giới, trở thành sách gối đầu giường của rất nhiều tu sĩ.\r\n\r\n`Object.create` cho phép sao chép các properties hoặc protoype của đối tượng. Hàm `Dog` có thể được viết lại theo hướng prototypal inheritance như thế này:\r\n\r\n```\r\nfunction Dog() {}\r\n\r\nDog.prototype.say = function() {\r\n  console.log('woof-woof, my name is ' + this.name);\r\n}\r\n\r\nvar rocky = Object.create(Dog.prototype);\r\nrocky.name = 'Rocky';\r\n\r\nvar molly = Object.create(Dog.prototype);\r\nmolly.name = 'Molly';\r\n\r\nrocky.say();\r\nmolly.say();\r\n```\r\n\r\nKhông cần `new` nữa!\r\n\r\nCác cường giả sau đó nhanh chóng phát triển thêm nhiều cách tiếp cận prototypal inheritance khác, nổi bật nhất phải kể đến Concatenative inheritance, Prototype delegation và Functional inheritance.\r\n\r\nES6 Class ngày nay chỉ vay mượn syntax của classical OOP để làm interface, còn bên trong nó chính là cơ chế prototypal inheritance.\r\n\r\n#### Object Composition\r\n\r\nNhưng dù sao prototypal inheritance vẫn thuộc về OOP.\r\n\r\nNgười tu luyện Functional Programming không cần `new`.\r\n\r\nGần 10 năm sau bom tấn \"The Good Parts\", Douglas Crockford lại một lần nữa khiến tin giới chấn động bằng \"JavaScript: The Better Parts\". Thời điểm này, ông đã không còn dùng `Object.create()` nữa, cũng từ bỏ luôn  `this`, `for loops`, `for in`, `while`... Tu vi của ông đã tiến thêm một bước lớn. Trong clip, ông nói về những tính năng mới của ES6 lúc ấy vẫn còn chưa chính thức xuất xưởng. Mấy lão quái kiệt này luôn đi trước thiên hạ vài năm.\r\n\r\nhttps://www.youtube.com/watch?v=bo36MrBfTk4\r\n\r\nĐó cũng là khi trào lưu Functional Programming đang dần nóng trở lại, người ta bắt đầu nhắc đến khái niệm [Object Composition](https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381).\r\n\r\nĐi cặp với `new` là `this`. Từ khóa `this` chẳng qua chỉ là kỹ xảo nhằm tạo ra một ngữ cảnh khu biệt (context) để thực thi các hàm. Trong JavaScript, mỗi hàm như 1 kết giới độc lập. Function khi được gắn lên object thì gọi là method. Ngữ cảnh method đó chạy thường chính là đối tượng sở hữu nó. Sau này mới sinh ra các thủ thuật `bind`, `apply`, `call` để đánh tráo context.\r\n\r\nVới những người mới học JavaScript, `this` đôi khi trở thành nỗi khiếp sợ. Rất khó debug các vấn đề phát sinh trong hàm nếu không biết chính xác ngữ cảnh chạy nó. Mà ngữ cảnh lại thường không ổn định. Đúng hơn, phải nói rằng chúng luôn luôn mutable.\r\n\r\nNgười tu luyện Functional Programming không cần `this`.\r\n\r\nĐoạn code với classical OOP trên kia có thể viết lại thành:\r\n\r\n```\r\nconst sayName = (state) =\u003e {\r\n  return Object.assign(\r\n    state,\r\n    {\r\n      say: () =\u003e {\r\n        console.log(`woof-woof, my name is ${state.name}`);\r\n      },\r\n    }\r\n  );\r\n};\r\n\r\nconst createDog = (name) =\u003e {\r\n  let state = {\r\n    name,\r\n  };\r\n  return Object.assign(state, sayName(state));\r\n};\r\n\r\nconst rocky = createDog('Rocky');\r\nrocky.say();\r\nconst molly = createDog('Molly');\r\nmolly.say();\r\n```\r\n\r\nNhìn đâu cũng thấy functions.\r\n\r\nKhông còn `for/while`, `if/else`, `new/this`.\r\n\r\nLiệu bạn đã sẵn sàng rời khỏi những phàm vật ấy? \r\n\r\nHay nói như các nhà sư, liệu bạn có thể buông bỏ?\r\n\r\n![Tớ cóc thèm](https://i.imgur.com/LK0k8LW.jpg)\r\n\r\nKhi lối tư duy truyền thống đã ăn sâu vào tâm trí, hễ gặp vấn đề phân cấp đối tượng thì chúng ta sẽ nghĩ ngay đến OOP, class, prototype, inheritance... thậm chí coi chúng như giải pháp tất yếu, duy nhất. Hễ xử lý tập hợp là phải looping, hễ thấy có điều kiện thì chỉ biết dựa vào `if`... Đây là trở ngại rất lớn cho kẻ mới nhập đạo.\r\n\r\nPhải tìm cách rũ bỏ những thứ không cần thiết, thì mới đi xa được.\r\n\r\nRời khỏi chúng, chỉ giữ lại một ý niệm duy nhất: FUNCTION!\r\n\r\nNhất niệm \"phân sần\"!\r\n\r\n![Âu Dương Na Na](https://i.imgur.com/0clmtSN.jpg)\r\n\r\n\r\nBan đầu tất nhiên là sẽ khó khăn, lúng túng. Giống như hàng ngày bạn vẫn đi trên con đường quen thuộc từ nhà đến công sở rồi lại trở về nhà. Cho đến một hôm con đường đó bị cảnh sát chặn lại, bạn đành phải rẽ sang lối khác. \r\n\r\nTrên con đường xa lạ ấy, bạn không còn trông thấy những điểm mốc hàng ngày vẫn thấy: 1 shop lưu niệm, 1 cây xăng, 1 tiệm cầm đồ, sau ngã tư là đến ven sông, cây cầu sơn màu đỏ, một tiệm tạp hóa thường có cô em rất xinh ngồi trước cửa... Bạn không còn bắt gặp những dấu hiệu đã quen mắt. Bạn chẳng biết mình đã đi đến đâu, còn cách nhà bao nhiêu km nữa. \r\n\r\nNhưng con đường nào đi lại vài lần thì cũng thành quen. Chẳng có gì đáng ngại. Vấn đề là, ngay khi bạn nhận thấy Functional Programming là thứ gì đó rất thú vị, đáng để học hỏi, vận dụng nó, bạn nên thực hiện ngay lập tức, đừng chờ đợi dịp nào thuận tiện, đừng chờ tìm được minh sư dẫn dắt. Nếu vậy, bạn sẽ khó mà rời khỏi lối mòn xưa cũ.\r\n\r\nKrishnamurti từng diễn giải một điều gần tương tự, đại ý thế này:\r\n\r\n\u003e Nếu bạn đi về hướng Bắc suốt những ngày tháng của cuộc đời bạn, giống như con người đã đi theo một hướng đặc biệt, rồi có người nào đó xuất hiện và nói, “Hướng đó không đúng”. Sau đó ông ta bảo bạn, “Đi về hướng Nam, hướng Đông, bất kỳ hướng nào, ngoại trừ hướng đó.” Và khi bạn thực sự chuyển động khỏi hướng đó, có một sự thay đổi ngay tại chính những tế bào não bởi vì bạn đã phá vỡ cái khuôn mẫu. Và cái khuôn mẫu đó phải được phá vỡ ngay lúc này, không phải bốn mươi năm hay một trăm năm sau.\r\n\r\n\r\n`\r\n - [Xem phần 1: Con đường sáng](https://kipalog.com/posts/Functional-Programming---Phan-1---Con-duong-sang)\r\n - [Xem phần 2: Nhập đạo](https://kipalog.com/posts/Functional-Programming---Phan-2---Nhap-dao) \r\n"
                }, {
                "id": "kutHE5BTdFP64Cc6Isabfg",
                "title": "Markdown",
                "content": "# Tìm hiểu về Markdown\n\n##Markdown là gì?\n\n**Markdown**  là một ngôn ngữ đánh dấu với cú pháp văn bản thô, được thiết kế để có thể dễ dàng chuyển thành HTML và nhiều định dạng khác sử dụng một công cụ cùng tên. Nó thường được dùng để tạo các tập tin *readme*, viết tin nhắn trên các diễn đàn, và tạo văn bản có định dạng bằng một trình biên tập văn bản thô.\n\n##Lịch sử về Markdown\nNăm 2004, cùng với sự giúp đỡ của [Aaron Swartz](https://en.wikipedia.org/wiki/Aaron_Swartz), [John Gruber](https://en.wikipedia.org/wiki/John_Gruber) đã tạo ra ngôn ngữ Markdown với mục tiêu tạo ra một định dạng văn bản thô \"dễ viết, dễ đọc, dễ dàng chuyển thành XHTML (hoặc HTML).\n## Ngữ pháp cơ bản\n###Tiêu đề\nCác lớp tiêu đề từ h1 đến h6 viết bằng cách thêm tương ứng từ 1 đến 6 ký tự # trước đầu dòng.\nKẹp ở đầu và cuối một đoạn text cặp ký tự  * để in nghiêng, ** để in đậm, *** để kết hợp cả hai. Chữ gạch ngang sử dụng cặp ký tự ~~\n*In nghiêng*\n**In đậm**\n***Nghiêng đậm***\n~~Gạch ngang~~\n###Liên kết\nCách dẫn liên kết là: [alttext]và (url)\n[John Gruber](https://en.wikipedia.org/wiki/John_Gruber)\nNgoài ra chúng ta có thể thêm \"title\" vào sau url trong ().\n### Hình ảnh\nChèn hình ảnh giống với cú pháp chèn liên kết, thêm ký tự ! trước cú pháp trên.\n![https://blog.ghost.org/](https://blog.ghost.org/content/images/2015/03/markdown-guide-1.jpg)\n###Định dạng danh sách\nĐể định dạng một đoạn text thành các gạch đầu dòng, ta dùng ký tự * và một dấu cách ở mỗi ý và dùng thêm 2 dấu cách ở đằng trước nếu muốn lùi vào một level.\n* Châu Âu\n* Châu Á\n * Việt Nam\n     * Hà Nội\n     * Hải Phòng\n * Thái Lan\n \nNếu muốn liệt kê bằng số thì thêm số và một dấu chấm.\n1. Number one\n2. Number two\n3. Number three\n\n###Trích dẫn\nCách viết một trích dẫn: sử dụng ký tự \u003e trước đoạn text.\n\u003e Markdown là một ngôn ngữ đánh dấu với cú pháp văn bản thô, được thiết kế để có thể dễ dàng chuyển thành HTML và nhiều định dạng khác sử dụng một công cụ cùng tên.\n\n###Mã code\nCó 2 loại code có thể viết trong **Markdown**: *inline code* (code trong dòng) và *code block* (đoạn code riêng).\n*Inline code* dùng 1 ký tự ` ở đầu và cuối code.\n\n`Code` trong dòng.\n*Code block* dùng 3 ký tự phẩy ngược ở đầu và cuối một đoạn code. Khi muốn cú pháp  hiển thị chính xác với ngôn ngữ của đoạn code thì có thể thêm định danh ngôn ngữ ở ngay sau 3 ký tự ` mở đoạn.\n\n```python\nimport os\nos.system('clear')\n```\nTham khảo: [https://kipalog.com/markdown](https://kipalog.com/markdown)\n"
                }, {
                "id": "Ae18_lCEx_fg9pL1PSLN0w",
                "title": "Two-Factor Authentication và ứng dụng",
                "content": "Trong thế giới của việc thông tin cá nhân đang ngày càng bị xâm phạm và tấn công, đến thời điểm này đã có gần [10 tỷ](https://breachlevelindex.com/) accounts bị leaked thì chuyện phải implement một phương pháp đăng nhập có tính bảo mật cao hơn là một chuyện bất cứ cá nhân/tổ chức nào cũng aware được.\r\n\r\nTwo-factor Authentication là một trong số đó. Trong bài này mình sẽ chia sẻ những kiến thức đã tổng hợp được trong quá trình làm việc với 2FA.\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7gklibkwls_image.png)\r\n\r\n## Two-Factor Authentication (2FA) là gì?\r\n\r\nTwo-Factor Authentication (2FA) hay còn gọi là Bảo mật 2 lớp, là một phương thức để chứng thực user bằng việc combine 2 factors khác nhau từ bộ source:\r\n- Một cái gì đó bạn biết.\r\n- Một cái gì đó bạn có.\r\n- Một cái gì đó mà nó mặc nhiên như vậy.\r\n\r\nMột ví dụ khá cơ bản của 2FA đó là khi bạn rút tiền ở ATM, bạn cần 2 thứ, một là cái thẻ (bạn có) và mã PIN (bạn biết) mới có khả năng thực hiện rút tiền.\r\n\r\nNhư vậy nó áp dụng trong online authentication như thế nào?\r\n\r\nVới bảo mật thông thường, bạn chỉ cần nhập username và password để đăng nhập tài khoản của mình, thứ bảo vệ duy nhất của bạn là mật khẩu. Đây là cái mà \"bạn biết\". 2FA sẽ thêm một extra layer để bạn cần provide cái mà \"bạn có\" nữa.\r\n\r\n## Các loại 2FA\r\n- Hardware Token\r\n- SMS/Voice based\r\n- Software Token\r\n- Push notification\r\n- Các loại khác\r\n\r\nNhư bạn thấy, có rất nhiều cách để mô phỏng cái mà \"bạn có\". \r\n\r\nChẳng hạn, SMS là một sự lựa chọn không tồi, server gửi SMS về cho user để đăng nhập. Nhưng SMS lại không quá an toàn (có thể bị intercepted), và bị vấn đề về network, việc delay có thể làm ảnh hưởng tới authentication process.\r\n\r\nVì nhiều lí do khác nhau nên team quyết định chọn dùng Software Token cho 2FA. Và từ bây giờ trong bài viết mình 2FA cũng được ám chỉ tới phương pháp sử dụng cryptographically key của Software Token.\r\n\r\n## 2FA hoạt động như thế nào?\r\nMình lấy ví dụ gitlab.\r\nĐây là lúc đăng nhập, mình sẽ provide user và password.\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/qg21xb61c9_Screen%20Shot%202018-05-25%20at%203.15.24%20PM.png)\r\n\r\nSau khi đăng nhập xong, vì mình có enable 2FA nên nó sẽ redirect mình tới trang điền code (soft token).\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/wi0hndhayn_Screen%20Shot%202018-05-25%20at%203.15.33%20PM.png)\r\n\r\nCode này sẽ được lấy từ Authentication application, có thể là Authy, Google authenticator ...\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mui8qfsb9c_Screen%20Shot%202018-05-25%20at%204.43.50%20PM.png)\r\n\r\nVí dụ như mình dùng Authy để lấy được code. Mỗi code sẽ được thay đổi sau 30s.\r\n\r\nVới code này mình sẽ đăng nhập thành công.\r\n\r\n\r\n## Cơ chế hoạt động internally của 2FA\r\nKhi bạn enable 2FA cho tài khoản của mình, bạn sẽ nhận được một secret key based 32. Tùy vào mức độ security, độ dài của secret key có thể là 80, 128 hoặc 160 bit.\r\n\r\nCác authenticator application sẽ scan secret này dưới dạng QR code (hoặc manually) và dùng nó để generate ra một HMAC-SHA1. Chuỗi HMAC này có thể là một trong 2 dạng:\r\n- [TOTP](https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm) \r\n- [HOTP](https://en.wikipedia.org/wiki/HMAC-based_One-time_Password_algorithm)\r\n\r\nSau đó HMAC này sẽ được extracted và lấy ra 1 số int 4 byte, đó chính là code.\r\n\r\nMột mã code sẽ valid trong 30 giây. Tuy nhiên không phải ai cũng có clock synced giống nhau, vì network latency các kiểu nên thường mọi người hay cho phép ở phạm vi cộng trừ 1 code, tức là 1 code sẽ valid trong 1 phút 30 giây. Điều này có thể giảm tính an toàn, nhưng lại tăng sự trải nghiệm đáng kể.\r\n\r\n### Backup codes\r\nBackup codes hay recovery codes sẽ được sử dụng trong trường hợp bạn không thể sử dụng điện thoại, bạn có thể dùng chúng để đăng nhập. Có 2 loại backup codes:\r\n- Multiple backup codes: Ví dụ github sẽ cho bạn 10 codes, và mỗi code sẽ được sử dụng 1 lần.\r\n- Single backup code: Bạn dùng cái code này đồng nghĩa với việc bạn có thể đăng nhập, nhưng phải setup lại 2FA (nó assume bạn bị mất điện thoại).\r\n\r\n\r\n## Làm thế nào để apply 2FA vào dự án của mình?\r\nKhá đơn giản, hầu hết ngôn ngữ đều open source implementation của mình. Mình code Go, library mà mình chọn là `github.com/dgryski/dgoogauth` được viết bởi Damian Gryski, một gopher rất nổi tiếng.\r\n\r\nFlow chương trình \r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hnxlni0dqr_Screen%20Shot%202018-05-25%20at%206.07.49%20PM.png)\r\n\r\nKhi một user muốn enable 2FA, App sẽ gọi `RequestGenerate2FA` API. \r\n\r\nTrong API này sẽ generate ra một temporary secret và lưu vào redis, trong thời gian expire 5 phút.\r\n\r\nGenerateSecret thì khá đơn giản thôi.\r\n```go\r\n// GenerateSecret generates a 10 byte secret string.\r\nfunc GenerateSecret() (string, error) {\r\n\trandom := make([]byte, 10)\r\n\t_, err := rand.Read(random)\r\n\tif err != nil {\r\n\t\treturn \"\", err\r\n\t}\r\n\treturn base32.StdEncoding.EncodeToString(random), nil\r\n}\r\n```\r\n\r\nSau khi app nhận được secret, sẽ turn thành QR code và đưa cho user. QR code này sẽ được user dùng Authenticator application để quét.\r\n\r\nKhi đã có code, user input vào và app sẽ tiếp tục make request lên API `Generate2FA`. Nếu thành công thì user đã được enable 2FA.\r\n\r\nTrong hàm `Generate2FA` chúng ta cần verify được code gửi lên và secret lấy từ redis có valid hay không. Sử dụng library trên như sau:\r\n\r\n```go\r\notpc := \u0026dgoogauth.OTPConfig{\r\n      Secret:      info.Secret,\r\n      WindowSize:  3,\r\n      HotpCounter: 0,\r\n}\r\n\r\nvalid, err := otpc.Authenticate(req.Code)\r\nif err != nil || !valid {\r\n\treturn errors.New(\"Invalid authenticate code\")\r\n}\r\n\r\n// success validation\r\n\r\n```\r\n\r\n(Các bạn có thể đọc thêm source code để biết function Authenticate hoạt động như thế nào, chỉ có 1 file go thôi).\r\n\r\nSau khi validate xong thì mình trả về Recovery codes luôn (cho tiện ở phía application). \r\n\r\nCòn đây thì flow khi login, nếu cần thêm 2FA thì sẽ require code từ user, sau đó upgrade cái access token đó (simply add thêm 1 fields `2fa: true`) để nhận dạng là đã 2FA authenticated rồi.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gvri4aj6di_Screen%20Shot%202018-05-25%20at%206.11.36%20PM.png)\r\n\r\n\r\n## Kết luận\r\n\r\n2FA là một kĩ thuật dùng để enhance security layer của một application. Hay nói cách khác, bạn khóa 1 cửa bằng 2 cái khóa luôn an toàn hơn 1 cái. Trong xã hội đầy loạn lạc này thì ứng dụng nào quan trọng, chứa nhiều sensitive data và liên quan tới tiền bạc thì cứ auto bật 2FA thôi.\r\n\r\n## References\r\n\r\n- https://engineering.gosquared.com/building-two-factor-authentication\r\n- https://authy.com/what-is-2fa/\r\n\r\nBài viết được trích ra từ blog [Runikitkat](http://runikitkat.com/post/2fa/)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
                }, {
                "id": "h86Tem0xTQr5DyqJmoXJGw",
                "title": "Mô hình Polyglot trong Microservice",
                "content": "Giaosucan's blog chia sẻ kiến thức theo cách bá đạo\r\n\r\n### http://www.giaosucan.com/\r\nmicroservice polyglot\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/s3tv5pkwn5_image.png)\r\n##Polyglot là gì?\r\nPolyglot vốn là một từ trong đời thường ám chỉ những người có khả năng nói được nhiều ngôn ngữ khác nhau. Chẳng hạn một người châu âu có thể nói 3 , 4 thứ tiếng Anh Pháp Trung Nhật, một anh Việt Nam nói được chục thứ tiếng cỡ như Mán, Mường, H’ mông, Ê đê. Họ trở thành những polyglot. Đại loại những thanh niên nào đa tài, đa zi năng, cái gì cũng biết thì gọi là Polyglot.\r\nKhái niệm Polyglot trên cũng được áp dụng vào Microservice. Trong mô hình này, chúng ta không sử dụng duy nhất một loại database như kiến trúc đơn khối mà sử dụng một tập hợp nhiều loại database khác nhau như NoSQL, Graph, ElasticSearch…Cũng giống như anh Tây xài được nhiều ngoại ngữ\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hygx3azk4n_image.png)\r\n##Cần Polyglot để làm gì\r\nHãy xem xét một bài toán thực tế sau\r\nBạn có một website bán hàng, user truy cập tìm kiếm sản phẩm, order và thực hiện payment. Website sử dụng kiến trúc microservice với các service Search, Order và Payment, và chỉ dùng duy nhất một loại database quan hệ như sau\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/zmdmn3x0lh_image.png)\r\nDo số nhọ nên bạn gặp toàn khách hàng chơi lầy, search, order sản phẩm thì rất nhiều nhưng đến  giai đoạn payment thì quịt. Như vậy thì service Search phải handle 1 số lượng lớn request tìm kiếm từ phía user, trong khi tốc độ query data trong database relational thì chậm (do số lượng record quá lớn), dẫn tới quá tải và service ngủm củ tỏi luôn.\r\nHệ thống hoạt động không ổn định, khách hàng thì chơi lầy nên ko bao lâu thì bạn sạt nghiệp, phải vác bơm ra hè kiếm cơm.\r\nLúc này thì mô hình Polyglot sẽ phát huy tác dụng, tận dụng được tính độc lập của kiến trúc microservice, bạn chỉ cần thay thế Database quan hệ Search bằng loại database khác hỗ trợ tìm kiếm tốc độ cao như ElasticSearch, MongoDB là xong, khỏi phải lo optimize SQL query, nâng cấp database….\r\nĐối với kiến trúc đơn khối truyền thống, bạn bị bó buộc vào việc chỉ sử dụng được 1 loại DB duy nhất\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/iict2z2arw_image.png)\r\nthì microservice cung cấp cho chúng ta một giải pháp linh hoạt hơn. Tùy theo nghiệp vụ của service bạn tự lựa chọn loại database cho phù hợp\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/6skwij6rx4_image.png)\r\nVí dụ service chuyên tìm kiếm thì sử dụng NoSQL, service chuyên đọc ghi CRUD thì dùng relational database, service làm việc với dữ liệu quan hệ phức tạp thì dùng Graph (Neo4J) database. Tóm lại đông tây y kết hợp đủ cả.\r\n##Nhược điểm của Polyglot\r\nCái gì hiện đại thì cũng hại điện, mọi thứ đều có mặt trái của nó. Polyglot cũng vậy, sử dụng quá nhiều loại database khác nhau đồng nghĩa với bạn phải làm quen với nhiều loại công nghệ đi kèm, chi phí phát triển và bảo trì hệ thống cũng tăng lên.\r\nHơn nữa, mỗi loại database lại sử dụng những format data khác nhau (NoSQL thì dùng JSON, document, SQL thì dùng record, Graph database dùng data dạng graph gồm node, edge…) nên việc xử lý data consistency giữa các database cũng là một thách thức lớn.\r\n##Kết luận\r\nHiểu được ưu nhược điểm của Polyglot sẽ giúp bạn có cách trade off, lựa chọn database phù hợp. Tốt nhất là service của bạn cần thế nào thì chọn database theo thế đấy. Lời khuyên là cũng không nên cố xài lắm database làm gì. Nó có thể dẫn bạn đến tình trạng cái gì cũng chơi, chơi quá độ đến mức liệt, cuối cùng là chẳng chơi nổi cái gì. \r\n"
                }, {
                "id": "QAa7U_oQuhLB3oRFyUHYuw",
                "title": "[RxSwift - Take note về RxSwift] - Các lưu ý dễ mắc phải (phần 1)",
                "content": "## [RxSwift - Take note về RxSwift] - Các lưu ý dễ mắc phải (phần 1)\r\n\r\n###1. Vấn đề về liên quan đến hot/ cold Observables: \r\n\r\nThực tế, khi **mới** nghiên cứu về Hot-Cold Observables, các bạn đừng để ý gì về việc 1 dòng Stream hay nhiều dòng Stream. Với kiến thức hiện tại của mình tại lúc này, mình chỉ quan tâm: các driver UI như UIButton tap hay text UITextField có Hot Observable. Còn các Observable khác là mỗi khi có ai đó subscribe, nó mới emit. (khi nào cần đưa nó thành Hot thì trigger nó)\r\n####a. Ví dụ 1: \r\n\r\n```\r\n\tlet stringTest01: Driver\u003cString?\u003e = imageButton.flatMapLatest { image in\r\n      print(\"[Debug] [stringTest01] day la image VM ne`\\(image)\")\r\n      return RollcallService.uploadImage(withUid: Constant.currentUid ?? \"\", image: image!).asDriver(onErrorJustReturn: \"\")\r\n    }\r\n    \r\n    let stringTest02: Driver\u003cString?\u003e = imageButton.flatMapLatest { image in\r\n      print(\"[Debug] [stringTest02] day la image VM ne`\\(image)\")\r\n      return RollcallService.uploadImage(withUid: Constant.currentUid ?? \"\", image: image!).asDriver(onErrorJustReturn: \"\")\r\n    }\r\n    \r\n    stringTest01.drive(onNext: { resultString in\r\n      print(\"[Debug] [atViewModel] Result string tai man hinh View Model \\(resultString)\")\r\n    })\r\n```\r\n\r\nKhi run lên thì chuyện gì xảy ra, chỉ có `[Debug] [stringTest01]` được in ra cùng với `[Debug] [atViewModel]`, còn stringTest02 không có ai subscribe nên nó không phát ra tín hiệu.\r\n\r\n####b. Ví dụ 2:\r\n```\r\nlet allTextConditions = Driver.combineLatest(nameTextField, emailTextField, passwordTextField, descriptionTextField, positionTextField) { (name, email, password, descriptionUser, position) -\u003e (Users) in\r\n      print(\"[Debug] [allTextConditions] User is \\(Users(name: name, email: email, password: password, descriptionUser: descriptionUser, position: position))\")\r\n      return Users(name: name, email: email, password: password, descriptionUser: descriptionUser, position: position)\r\n    }\r\n  \r\n ```\r\n `combineLatest` chỉ là update mỗi lần có sự thay đổi của các text inside. Còn phần bên trong completion handler là chỉ khi nào có ai đó subscribe, nó mới gọi ra các công việc trong này.\r\n \r\n###2. Lỗi khi không subscribe/ drive được các Observables/ Drivers:\r\n \r\n Cái lỗi này khiến mình bực mình nhất. Xem đoạn code sau:\r\n \r\n ```\r\n profileViewModel.signUpResult.drive { result in\r\n      print(\"Ket qua la result \\(result)\")\r\n    }\r\n ```\r\n Sau khi có được tín hiệu từ ViewModel, mình chuyển qua bên View Controller, cái mà mình nhận được, lúc thì không có gì (lúc này chẳng hiểu vì sao), lúc thì nó ra cái định nghĩa của Driver (nhờ lúc này mới biết là mình thiếu onNext). Cho nên, các bạn cẩn thận nha:\r\n \r\n ```\r\n profileViewModel.signUpResult.drive(onNext: { result in\r\n      print(\"Ket qua la result \\(result)\")\r\n    })\r\n ```\r\n \r\n###3. Lưu ý về disposeBag và dispose: \r\n Các bạn phải lưu ý cần thận việc này, đôi khi nhiều bạn cứ code như sau:\r\n ```\r\n profileViewModel.signUpResult.drive(onNext: { result in\r\n      print(\"Ket qua la result \\(result)\")\r\n    }).dispose()\r\n ```\r\n Vì nếu mà dispose ở đó, tức là nó chỉ lắng nghe 1 lần rồi thôi, stop, ko observer nữa. Mà một khi ko có ai observe nó sẽ stop. Mọi thay đổi tiếp đó, mình sẽ không có kết quả gì. Dùng disposeBag sẽ giữ được sự lắng nghe cho đến khi dealloc màn hình hiện tại. \r\n \r\n Như vậy, mình đã take note lỗi của mình. Hi vọng các bạn đọc được rồi rút kn cho bản thân."
                }, {
                "id": "slYU0NPnPoW67bhvUhpg7A",
                "title": "Phương pháp thần thánh cho kì thi TOEIC",
                "content": "##1, TOEIC là cái gì ? , nó có thể giúp ích cho chúng ta những gì ??##\r\n![alt](http://www.cleverlearnvietnam.vn/wp-content/uploads/2015/06/toeic.jpg)\r\n- TOEIC (viết tắt của Test of English for International Communication – Bài kiểm tra tiếng Anh giao tiếp quốc tế) ,đây là một bài thi nhằm đánh giá trình độ của các người học tiếng anh ,\r\nđặc biệt là những ngưởi yêu thích công nghệ,code....vì để có môt cái gọi là pro trong IT thì phải có cái pro trong tiếng anh\r\n- Tiếng anh là một thứ tiếng rất quan trọng , nó như một thứ tiếng thứ 2 vậy , nên cái mình muốn là : ai cũng học tiếng anh =)) (có cả mình nữa !!), ngoài TOEIC ra thì chúng ta còn phải nói về IELTS,đây cũng là một kì thi giúp chúng ta nâng cao trình độ tiếng anh của mình lên \r\n\r\n\r\n# IELTS và TOEIC có gì khác nhau ??\r\n- về IELTS thì nó khó hơn TOEIC rất nhiều vì TOEIC là tiếng anh thường nhật ,công sở     nên nó chỉ dùng khi đi xin việc\r\n\r\n- TOEIC  chỉ có nghe và đọc\r\n- TOEIC chỉ có trắc nhiệm \r\n- vốn từ của TOEIC là nhứng từ thường nhật,công sở nên khá dễ nhớ\r\n- IELTS thì nó có những câu tự luận để trả lời và điền từ vào đấy!!\r\n- IELTS thì có cả 4 cái kĩ năng reading,speaking,listening,writing:smile:\r\n- IELTS còn dùng những từ trong academic rất khó để nhớ\r\n\r\n##2.Cách ôn thi TOEIC  và một số mẹo khi chúng ta thi TOEIC ?\r\n###Trước khi đi vào thì các bạn hãy xem video này nhé!!\r\n[link](https://www.youtube.com/watch?v=dEe6aAqjSrA)\r\n- Đây cũng là một câu hỏi mình cũng đã thắc mắc rất lâu rồi ?? nhưng nhờ sự mày mò kiếm tài liệu về TOEIC  thì mình cũng có một số mẹo và cách ôn thi của nó (mình mò mất 1 tuần đấy) sau đây mình sẽ chia sẻ bạn cách ôn thi TOEIC nhé :\r\n\u003e Khi chúng ta học TOEIC thì mất tầm khoảng 2 ,3 thắng gì đấy nên cái quan trọng nhất chính là kiên trì và thói quen =))\r\n\r\n#### - Nó gồm 3 giai đoạn\r\n- giai đoạn 1 : mở đầu chúng ta phải ôn tập về từ vững và các cấu trúc,luyện tập các kĩ năng nghe và đọc,vì trong TOEIC chủ yếu là đọc và nghe nên từ vựng là một yếu tố rất quan trọng đấy\r\n\u003eMình cũng đã từng đăng kí thi B1,nó cũng có 1 số cái na ná như TOEIC ,B1 nó đầu tư rất nhiều về từ vựng và cấu trúc , và nó đánh giá rất cao về kĩ năng nghe và nói  \r\n\r\n- giai đoạn 2 : Theo em thì đây là một trong những giai đoạn quan trọng nhất trong các giai đoạn khác vì đây là thời gian mà chúng ta cần luyện đề và làm quen với nó để chúng ta luyện đề thì mình cũng đã xem tài liệu nên lấy từ đâu:\r\n-Cuốn sách Starter TOEIC (trích trong \"Code dạo kí sự\"), Cuốn sách này rất đẽ tìm tên các ebook,facebook,theo mình các bạn nên tải file PDF về đọc nó có cả Mp3 nên vẫn rất thoải mái đấy đây chính là hình dạng của nó\r\n![alt](http://www.mshoatoeic.com/uploads/images/userfiles/13299688568683.jpg)\r\nCuốn sách này rất thích hợp cho những bạn mới khởi đầu khi thi TOEIC =)) ,bề ngoài của nó là một hình cờ vua nhưng bên trong nó là những kiến thức khá hay đấy ,nó có các dạng bài tập rất tốt và thuận tiện cho việc ôn thi,\r\n- ngoài ra các bạn còn có thể tìm đọc những cuốn sách như \r\n-Target TOEIC\r\n-TOEIC Analyst\r\n![alt](http://toeicacademy.com/wp-content/uploads/2016/08/target-toeic.jpg)\r\n![alt](https://vcdn.tikicdn.com/cache/550x550/media/catalog/product/t/o/toeic-analyst-second-edition-a.jpg)\r\n\r\n- giai đoạn 3 : là thời gian hầu hết bạn dánh để thi thử và đếm thời gian nhé , trong các cuốn mình đã chia sẻ thì cũng đã có đề rồi nha !!!!\r\n\r\n\u003enếu các bạn cảm thấy không có động lực để  học ý thì đăng ký đi rồi thi cũng dc =))\r\n\t\r\n[Link](https://www.youtube.com/watch?v=1h_K0sUTAoc)\r\n\r\n\u003e đây là video nói về các từ vựng trong TOEIC nha !! nếu bạn có thời gian thì có thể tìm các tips của TOEIC nhé ,nhưng bạn phải nhớ điều quan trọng nhất là : NĂNG LỰC !\r\n\r\n\r\n#Chúc mọi người thi tốt !!\r\n\r\n\r\n"
                }, {
                "id": "jV4qra2tZtGQNc6t8slITQ",
                "title": "12 cách tối ưu hoá website - thời đại của mobile-first",
                "content": "Lập trình viên sau khi phát triển xong một website, website chạy ổn định, không bug thì coi như đã hoàn thành. \r\n\r\nCâu chuyện của năm 2018 có đơn giản như vậy?\r\n\r\n## Tại sao phải tối ưu hoá website?\r\n_Theo [số liệu cung cấp bởi google](https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/)_\r\n\r\n![fact-1](https://qmau.me/uploads/ltfWITVaamwum4CC.jpg)\r\n\r\n- User facts:\r\n  - **47%** người dùng muốn trang web load **dưới 2 giây** và **40%** sẽ bỏ cuộc nếu trang web mất **trên 3 giây** để load.\r\n  - **79%** người dùng sẽ không ghé thăm lại một website có performance tồi.\r\n  - **52%** người dùng cho rằng website load nhanh ảnh hưởng trực tiếp đến độ trung thành của họ.\r\n  - **44%** người dùng than phiền về tốc độ web với bạn của họ.\r\n  - **1 giây** tăng lên trong load-time giảm **16%** độ hài lòng của người dùng.\r\n\r\n![fact-2](https://qmau.me/uploads/pxvo1NJb9KnMlUCu.png)\r\n- Website facts:\r\n  - **79%** có kích thước trên 1MB, **53%** trên 2MB và **23%** trên 4MB.\r\n  - \u001dMobile load-time đã **giảm 7 giây** nhưng vẫn tốn khoảng **15 giây**, **53%** websites tốn hơn **3 giây** để hiển thị.\r\n  - Mobile traffic chiếm hơn một nửa web traffic trên toàn thế giới, nhưng tỷ lệ chuyển đổi thành lợi nhuận lại thấp hơn trên các thiết bị máy tính.\r\n\r\n  → **speed equals revenue**\r\n  - **70%** landing page mất **hơn 5 giây** để hiển thị.\r\n  - Google sử dụng một deep neural network với độ chính xác 90% để cho ra kết quả sau:\r\n    - **giảm load-time được 10 giây**, tỷ lệ người dùng tiếp tục sử dụng website **tăng 123%**\r\n    - ngược lại, số lượng elements trên trang web **tăng từ 400 lên 6000**, tỷ lệ chuyển đổi thành lợi nhuận **giảm 95%**\r\n\r\n  → **faster is better and less is more**\r\n  - Thử nghiệm thực tế:\r\n    1. Walmart:\r\n      - Mỗi **1 giây** load-time giảm, số lượng đặt hàng **tăng 2%**\r\n      - Mỗi **100ms** load-time giảm, lợi nhuận tăng **1%**\r\n      - Tỉ lệ đặt hàng có thể **giảm 25%** với mỗi **1 giây** tăng trong load-time.\r\n    2. Amazon A/B Test:\r\n      - Chỉ **100ms load-time** có thể khiến lợi nhuận **giảm đáng kể**.\r\n    3. Google\r\n      - Traffic **giảm 20%** nếu load-time tăng thêm **0.5 giây**\r\n      - Google đã rank các website theo [mobile-first index](https://searchengineland.com/finally-going-mobile-friendly-collision-course-googles-mobile-first-index-case-study-265227), tốc độ load trang trên di động sẽ ảnh hưởng trực tiếp đến kết quả index trên Google search engine.\r\n\r\n\r\n### SPEED DOES MATTER\r\n![fact-3](https://qmau.me/uploads/xM14N65sTTJpIBaq.jpg)\r\n\r\nLoad-time tăng 1 giây:\r\n- **Giảm 11%** lượng pageviews\r\n- **Giảm 16%** sự hài lòng của khách hàng\r\n- **Giảm 7%** lợi nhuận\r\n\r\nỞ Việt Nam, website của [Thế giới di động](https://www.thegioididong.com/) được giao KPI hiển thị dưới 300ms, còn [tiki và đặc biệt là sendo có vẻ không quan tâm đến](https://toidicodedao.com/2018/04/03/tiki-sendo-tai-trang-cham-sen-bo/) việc này lắm. Các bạn có thể dễ dàng thấy trải nghiệm người dùng ở đâu tốt hơn, ở đâu mọi người mua đồ nhiều hơn.\r\n\r\nDù sao thì trong tương lai, các website chắc chắn sẽ phải để ý đến việc optimize webservice. Đây vừa là cơ hội và cũng là thách thức với các lập trình viên. Liệu tất cả những lý do trên đã khiến các bạn phải ngồi vào bàn và bỏ thời gian ra làm một website chạy nhanh hơn 1-2 giây?\r\n\r\nLong story short:\r\n\u003e Hãy làm trang của bạn chạy thật nhanh trên các thiết bị di động và bắt đầu tư duy theo hướng mobile-first.\r\n\r\nCùng nhìn lại một chút quá trình vào một trang web của người dùng theo một flow đơn giản:\r\n\r\n![flow](https://qmau.me/uploads/jQyWIfh6TnBtl1wi.jpg)\r\n\r\n1. người dùng nhập địa chỉ web → chuyển đến mạng Internet\r\n2. DNS server (Domain Name Service server) chuyển từ URL thành địa chỉ IP →　trỏ đến server có IP yêu cầu\r\n3. server nhận request, xử lý request\r\n4. chuyển lại response cho người dùng → browser hiển thị kết quả.\r\n\r\nTin tốt là chúng ta có thể optimize trang web ở tất cả các bước còn tin xấu là ở mỗi bước, thời gian cải thiện có thể chỉ được tính bằng ms (1/1000 giây ). Có nên thực sự quan tâm?\r\n\r\n- Nếu trang web của bạn là một blog cá nhân, không có giá trị kiếm tiền, có \u003c 50 người truy cập cùng lúc (như blog này) thì việc optimize không mang lại nhiều giá trị.\r\n\r\n- Bạn kiếm tiền từ trang web của bạn và có trung bình vài nghìn hoặc vài trăm nghìn lượt truy cập cùng lúc. Ngoài lý do về lợi nhuận, nếu không optimize web service, server có thể bị quá tải do requests của khách hàng → bottle neck → load-time kéo dài, thậm chí out of service. Thay vì bỏ tiền mua server khủng hơn, hãy bỏ chút thời gian để sắp xếp và thiết kế lại service để đem lại performance ổn định với chi phí rẻ hơn.\r\n\r\n## Làm thế nào?\r\n\r\n- Đầu tiên hãy xem website của bạn đang có vấn đề gì bằng [công cụ của Pagespeed của google](https://developers.google.com/speed/pagespeed/insights/)\r\n\r\n- Tham khảo các rules của google cho việc tăng tốc độ load trang:\r\n  - [Hạn chế việc redirect tại landing page](https://developers.google.com/speed/docs/insights/AvoidRedirects)\r\n  - [Enable compression](https://developers.google.com/speed/docs/insights/EnableCompression)\r\n  - [Cải thiện tốc độ phản hồi của server](https://developers.google.com/speed/docs/insights/Server)\r\n  - [Tận dụng bộ nhớ cache của browser](https://developers.google.com/speed/docs/insights/LeverageBrowserCaching)\r\n  - [Tối giản hoá các tài nguyên](https://developers.google.com/speed/docs/insights/MinifyResources)\r\n  - [Tối ưu hiển thị ảnh](https://developers.google.com/speed/docs/insights/OptimizeImages)\r\n  - [Tối ưu hoá việc load CSS](https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery)\r\n  - [Ưu tiên các nội dung cần được hiển thị trước](https://developers.google.com/speed/docs/insights/PrioritizeVisibleContent)\r\n  - [Xoá bỏ các Javascript gây ra render-blocking](https://developers.google.com/speed/docs/insights/BlockingJS)\r\n\r\nSau tất cả, google là công cụ tìm kiếm lớn nhất thế giới, làm mọi thứ theo chuẩn của họ chắc chắn không phải một lựa chọn tồi.\r\n\r\nĐể đầy đủ hơn, mình sẽ thêm một số phương pháp và chia thành 4 loại tương ứng với từng giai đoạn khi người dùng truy cập website.\r\n\r\n## Loại 1: User → Internet\r\nHoàn toàn nằm ngoài khả năng của chúng ta, tuy nhiên vẫn có thể đảm bảo việc khác hàng có được trải nghiệm đủ tốt với tốc độ mạng cực chậm bằng việc [xây dựng progressive web app và sử dụng service-worker](https://qmau.me/blog/post/progressive-web-apps-qmau-me-cho-ios) cho trang web của bạn.\r\n\r\n## Loại 2: Internet → Server\r\n\r\n### 1. Sử dụng DNS server\r\n\r\n![DNS-server](https://qmau.me/uploads/jAOAsuDFTd9l0zPK.jpg)\r\n\r\nViệc chuyển từ URL sang địa chỉ IP server do DNS server đảm nhận, và nó cũng chỉ là một máy tính, nhanh chậm khác nhau. Các dịch vụ cung cấp host thường cũng sẽ có kèm theo dịch vụ cung cấp DNS, tuy nhiên tốc độ có thể khác nhau → tốc độ load trang cũng bị phụ thuộc.\r\n\r\n**Cách khắc phục**\r\n- Để tiết kiệm được khoảng **20-30ms** load-time, bạn nên cân nhắc chuyển qua dùng DNS server của một số nhà cung cấp khác.\r\n- Một số nhà cung cấp dịch vụ DNS (như cloudflare) cho phép bạn sử dụng DNS service miễn phí, tuy nhiên hãy tìm hiểu xem ở khu vực địa lý mà website của bạn hay được sử dụng [DNS nào có tốc độ nhanh nhất](https://www.dnsperf.com/).\r\n\r\n### 2. Sử dụng CDN\r\n\r\n![CDN-services](https://qmau.me/uploads/luVNJqudPakH-jpc.jpg)\r\n\r\nContent Delivery Network (CDN) là hệ thống các edge servers được đặt tại các vị trí địa lý khác nhau để có thể truyền tải nội dung từ một origin ở khoảng cách xa nhanh chóng hơn nhờ cơ chế cache.\r\n\r\nThay vì đến tận server (origin, ở xa) để lấy các tài nguyên thì người dùng có thể lấy ngay tại CDN (distribution, ở gần), chính vì thế load-time sẽ được giảm đáng kể.\r\n\r\nĐể hiểu rõ hơn những lợi ích của việc sử dụng CDN bạn có thể đọc [bài viết vô cùng có tâm của sempai Đinh Hoàng Long về CDN](https://viblo.asia/p/su-dung-cdn-de-giam-tai-cho-server-ymwGXOxoM4p1).\r\n\r\nTheo [cdnperf.com](https://www.cdnperf.com/), tính đến thời điểm này JSDELIVR đang dẫn đầu trong việc cung cấp dịch vụ CDN trên toàn cầu. Ở châu Á, vị trí quán quân thuộc về CDNetworks. Cloudflare CDN, Azure và CloudFront của AWS cũng lọp top 10.\r\n\r\n_Cloud CDN (của google) mà mình đang dùng ở vị trí nào đó không xuất hiện trong bảng xếp hạng_ \r\n\r\n## Loại 3: Server\r\n\r\n### 3. Hosting\r\n\r\n![](https://qmau.me/uploads/yvVGAtFtpTp2qnbr.png)\r\n\r\nThời đại của cloud computing, các service hầu hết được đưa lên mây. Việc chọn một hosting service phù hợp với nhu cầu của trang web cũng là một yếu tố quan trọng ảnh hưởng đến tốc độ của trang web.\r\n\r\n- Nhu cầu nhỏ →　shared hosting.\r\n- Nhu cầu vừa phải → VPS hosting.\r\n- Nhu cầu lớn → Dedicated server.\r\n\r\nNếu có thể, hãy tham khảo ý kiến từ một lập trình viên, nhân viên quản trị hệ thống hoặc sử dụng dịch vụ của một số nhà cung cấp lớn như [Amazon web service](https://aws.amazon.com/websites/), [Microsoft Azure](https://www.microsoft.com/en-us/CloudandHosting/Azure_Hosting.aspx), [Google cloud](https://cloud.google.com/),...\r\n\r\n_[qmau.me](https://qmau.me) đang được host với 300$ free của Google cloud VPS, CPU trung bình khoảng 1%_ \r\n\r\n\r\n### 4. Cải thiện tốc độ phản hồi của server\r\nGoogle rất khó tính, họ cho rằng phản hồi của server nên **dưới 200ms**. Việc server phản hồi chậm có thể do một trong những lý do sau:\r\n- Sử dụng framework, ngôn ngữ không tối ưu\r\n- Logic quá phức tạp → việc xử lý chậm\r\n- Các components của server tốn nhiều thời gian để liên kết\r\n\r\n  Ví dụ: sử dụng web server và database server riêng → mất thêm độ trễ của network vào thời gian phản hồi của webserver.\r\n- Mạng chậm (lý do khách quan, bỏ tay trả về).\r\n\r\n**Cách khắc phục**\r\n- Low level:\r\n  - Sử dụng các ngôn ngữ, framework có tốc độ xử lý tốt (không dùng fortran để code web).\r\n  - Đơn giản hoá code, sử dụng kiến thức về cấu trúc dữ liệu, giải thuật \r\n  - Với website có thể dùng cache (redis, memcached), cache trong database để tăng tốc độ phản hồi (tối ưu cache memory lại là một câu chuyện khác)\r\n- High level:\r\n  - Xây dựng hệ thống với độ trễ giữa các clusters thấp → việc của quản trị viên hệ thống.\r\n\r\n### 5. Tối giản hoá các tài nguyên\r\nKhi load trang web, các file `html, css, js, script` sẽ được load để hiển thị trên browser. Tuy không quá nặng nhưng việc đơn giản hoá, không sử dụng thừa code trong các tài nguyên được load cũng sẽ cải thiện tốc độ load cho trang web.\r\n\r\n**Cách khắc phục**\r\n- [Minify HTML](https://github.com/kangax/html-minifier)\r\n- [Minify CSS](https://github.com/ben-eb/cssnano)\r\n- [Minify Javascript](https://github.com/mishoo/UglifyJS2)\r\n- Có thể cài [PageSpeed Module](https://developers.google.com/speed/pagespeed/module/) của google cho webserver (apache, nginx) và mọi thứ cứ để module lo.\r\n- Học sử dụng [gulp](https://gulpjs.com/) và viết gulp task cho việc minify tài nguyên (worth it).\r\n\r\n### 6. Tối ưu hiển thị ảnh\r\nẢnh có thể coi là tài nguyên chiếm nhiều load-time nhất của một trang web, việc tối ưu được hiển thị ảnh đóng vai trò quan trọng trong việc cải thiện load-time của một trang web.\r\n\r\nNgày nay người dùng sử dụng rất nhiều các thiết bị khác nhau để có thể truy cập vào trang web của bạn. Với layout bạn có thể giải quyết bằng responsive design, còn với ảnh câu chuyện sẽ rắc rối hơn một chút.\r\n\r\n**Cách khắc phục**\r\n- Sử dụng ảnh phù hợp với kích cỡ màn hình người dùng. Tham khảo [các best practices](https://developers.google.com/web/fundamentals/design-and-ux/responsive/images) cho việc hiển thị ảnh responsive để tiết kiệm tài nguyên.\r\n- Sử dụng các phương thức nén ảnh phù hợp:\r\n  - GIF, PNG là phương thức nén lossless, ảnh sau khi nén sẽ có chất lượng gần như ảnh gốc, tỉ lệ nén thấp.\r\n  - JPEG là phương thức nén lossy, ảnh sau khi nén có chất lượng giảm so với ảnh gốc tuy nhiên tỉ lệ nén có thể **gấp 10 lần** GIF và PNG.\r\n  - Sử dụng các phương thức nén hiện đại hơn như JPEG 2000, JPEG XR hoặc WebP để tăng tốc độ load.\r\n\r\n### 7. Tối ưu hoá việc load CSS\r\nMột trang web sẽ được hiển thị khi load đầy đủ html, css, js. Nếu file css, js có kích thước quá lớn sẽ khiến trang web bị render-blocking, khiến tốc độ load trang tăng đáng kể.\r\n\r\n**Cách khắc phục**\r\n- [Inline các file css hoặc js nhỏ](https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery#example) bằng thẻ `\u003cstyle\u003e` trong phần `\u003chead\u003e`. Các code này sẽ được load cùng html thay vì phải load từng file nhỏ. ps: khai báo ở đầu trang chứ không phải khai báo trong html tag (`\u003cp style=...\u003e`) nhé.\r\n- Nên nhớ rằng việc chia css, javascript thành các file nhỏ sẽ giúp project có cấu trúc code tốt hơn, tuy nhiên với mỗi file, browser sẽ tốn thêm 1 request đến server của bạn, đôi khi thấy đọc code thấy css hay script inline thì đừng vội chửi dev ngu nhé.\r\n\r\n### 8. Tổ chức thứ tự load\r\nTrong Lighthouse audits của Chrome, tốc độ hiển thị first page của trang web là một trong nhưng tiêu chí được đánh giá rất cao trong mục Performance. Để người dùng có trải nghiệm tốt nhất thì việc ưu tiên hiển thị những nội dung cơ bản (above-the-fold - ATF) của trang web là rất quan trọng.\r\n\r\n**Cách khắc phục**\r\n- Hãy tổ chức html thật tốt, quyết định đâu là thành phần quan trọng cần load trước (html load theo thứ tự từ trên xuống dưới)\r\n  - Chia css thành 2 phần, 1 phần inline dành cho các nội dung ưu tiên hiển thị để tăng tốc độ load, 1 phần dành cho các nội dung còn lại\r\n  - Nếu sidebar và nội dung cùng đặt song song, ưu tiên hiển thị nội dung trước khi hiển thị sidebar\r\n- Giảm lượng tài nguyên cần load xuống bằng cách:\r\n  - Minify tài nguyên\r\n  - Sử dụng css thay cho ảnh khi có thể\r\n  - Sử dụng nén\r\n- [Sử dụng lazy load](https://github.com/verlok/lazyload) cho các tài nguyên chưa cần được hiển thị (vd: các ảnh chưa có trong khung hình)\r\n\r\n### 9. Xoá bỏ các Javascript gây ra render-blocking\r\nTrong khi browser tạo ra các DOM tree, nếu gặp một script, nó sẽ dừng lại và thực hiện xong script đó rồi mới tiếp tục tạo ra các DOM. Chính vì thế javascript có thể coi là một nguyên nhân khiến tốc độ tải trang bị chậm đi rất nhiều.\r\n\r\n**Cách khắc phục**\r\n- Inline script giống như đã làm với css, tuy nhiên hãy chắc chắn được các script được inline có tốc độ thực hiện nhanh và không gây ra render-blocking.\r\n- Sử dụng asynchronous (không đồng bộ) cho javascript, khi gặp script, browser sẽ không dừng lại thực hiện mà sẽ tiếp tục parse HTML đồng thời thực hiện script → tránh bị render-blocking.\r\n- Mạnh hơn nữa chúng ta có thể [defer javascript](https://www.w3schools.com/tags/att_script_defer.asp), các script sẽ được thực hiện khi trang được load xong.\r\n- Cơ chế load javascript:\r\n  - Nếu có async: script sẽ được thực hiện song song với parse html.\r\n  - Nếu có defer: script sẽ được thực hiện sau khi parse html.\r\n  - Nếu không có: script sẽ được thực hiện ngay, sau đó mới tiếp tục parse html.\r\n\r\n### 10. Hạn chế redirect tại landing page\r\nViệc redirect người dùng tại landing page sẽ đem lại trải nghiệm xấu và tăng thời gian load time của trang/\r\nVí dụ:\r\n- example.com sử dụng thiết kế responsive không đòi hỏi redirect, nhanh và tối ưu.\r\n- example.com → m.example.com/home - sẽ tốn thời gian cho multi-roundtrip.\r\n- example.com → www.example.com → m.example.com - người dùng mobile sẽ có trải nghiệm rất tệ do load time quá lâu.\r\n\r\n**Các khắc phục**\r\n- Học cách thiết kế một giao diện responsive và hạn chế việc redirect.\r\n- Nếu buộc phải redirect, tham khảo [hướng dẫn của google](https://developers.google.com/search/mobile-sites/mobile-seo/separate-urls#automatic-redirection).\r\n\r\n## Loại 4: Server → User\r\n\r\n### 11. Sử dụng nén dữ liệu\r\nHầu hết các browser hiệnt tại đều hỗ trợ và sử dụng gzip cho việc nén dữ liệu, nhờ lượng dữ liệu truyền tải qua network ít đi → tăng tốc độ tải trang.\r\n\r\n**Cách khắc phục**\r\n- Config server cho phép dữ liệu được ném nhằm giảm, một số config mẫu cho các web server:\r\n  - Apache: Use [mod_deflate](http://httpd.apache.org/docs/current/mod/mod_deflate.html)\r\n  - Nginx: Use [ngx_http_gzip_module](http://nginx.org/en/docs/http/ngx_http_gzip_module.html)\r\n\r\n- Dữ liệu được nén\r\n\r\n|Library|\tSize|\tCompressed size|\tCompression ratio|\r\n| :------------- | :------------- |:------------- |:------------- |:------------- |\r\n|jquery-1.11.0.js |\t276 KB |\t82 KB |\t70%|\r\n|jquery-1.11.0.min.js |\t94 KB\t| 33 KB |\t65%|\r\n|angular-1.2.15.js |\t729 KB\t| 182 KB |\t75%|\r\n|angular-1.2.15.min.js |\t101 KB |\t37 KB |\t63%|\r\n|bootstrap-3.1.1.css |\t118 KB |\t18 KB\t| 85%|\r\n|bootstrap-3.1.1.min.css |\t98 KB |\t17 KB\t| 83%|\r\n|foundation-5.css |\t186 KB | 22 KB\t|88%|\r\n|foundation-5.min.css |\t146 KB |\t18 KB |\t88%|\r\n\r\n### 12. Tận dụng bộ nhớ cache của browser\r\nMỗi lần người dùng truy cập một trang nào đó, toàn bộ tài nguyên của trang sẽ được load. Điều đó có nghĩa là nếu trang web của bạn không sử dụng cache, mỗi lần load trang sẽ load lại toàn bộ các file css, script dù nó có thể giống y hệt trang trước đó → tăng load-time.\r\n\r\nCác browser đều có bộ nhớ cache nên hãy tận dụng nó để tăng tốc độ load trang của bạn, nhưng tuyệt đối không [dùng máy của khách để đào bitcoin](https://coinhive.com/).\r\n\r\n**Cách khắc phục**\r\n- [Sử dụng Cache-Control và ETags để thiết lập cache-policy](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#cache-control) cho trang web của bạn.\r\n- Sử dụng [service-worker trong progressive web app](https://qmau.me/blog/post/progressive-web-apps-qmau-me-cho-ios) để precache tài nguyên trong lần load đầu tiên.\r\n\r\n## Challenge\r\n- Lighthouse audits của qmau.me đạt 100.\r\n- Tìm hiểu về AMP - công nghệ mới của google để load trang nhanh chóng.\r\n- KPI load-time qmau.me \u003c 500ms\r\n- Viết một bài cụ thể hoá tất cả những kiến thức ở trên.\r\n\r\n## TL;DR\r\n- Load-time của website ảnh hưởng rất lớn đến trải nghiệm người dùng, từ đó cũng ảnh hưởng đến lợi nhuận, vị trí trên google và tỉ lệ quay lại trang.\r\n- Quá trình tối ưu hoá load-time của website có rất nhiều bước, đòi hỏi nhiều công sức nhưng đáng để được quan tâm.\r\n- Keep everything simple at first, hãy cố gắng phát triển ứng dụng web có tâm, không sử dụng những gì không cần, tư duy mobile-first và trong sáng nhất có thể.\r\n\r\n## Refs\r\n- [Google pagespeed](https://developers.google.com/speed/docs/insights/v4/reference/)\r\n- [Speed up your website](https://www.crazyegg.com/blog/speed-up-your-website/)\r\n- [Google webspeed](https://developers.google.com/speed/)\r\n- [Sử dụng CDN để giảm tải cho Server](https://viblo.asia/p/su-dung-cdn-de-giam-tai-cho-server-ymwGXOxoM4p1)\r\n- [Find out how you stack up to new industry benchmarks for mobile page speed](https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/)\r\n\r\n## Bài viết gốc tại blog cá nhân\r\n https://qmau.me/blog/post/12-cach-toi-uu-hoa-website-thoi-dai-cua-mobile-first\r\n \r\nPeace, sớm gặp lại mọi người."
                }, {
                "id": "TgsclDi5aE2aQJgdYWcx8g",
                "title": "Zone trong Angluar và các thiết kế ở front-end framework",
                "content": "![zone in angular](https://i.imgur.com/po98H7T.png)\r\n\r\n# Chất vất bản thân\r\n\r\nKhi làm việc với `Angular`, bạn có bao giờ hỏi là =\u003e thế beep nào mà mình phải cần xài thằng `zone.js` để chạy một ứng dụng Angular? Why why why? Mịa nó chiếm space của ứng dụng bố mà chả hiểu **cần nó làm cái méo gì?** Có thấy `React` hoặc `Vue` có cần cái dependencies nào để chạy chung đâu hè. \r\n\r\nNói tới đây chắc fan của Vue và React sẽ nháo nhào chê bai Angular là: *đang mệt, Angular như shệt, qua học React hay Vue gì đê bác ưiiiii !!!!!*\r\n\r\n**Vậy `zone.js` là gì?** mà các kỹ sư thiên tài ở `Google` phải bắt buộc sử dụng đến cho library nài. Để trả lời câu hỏi trên chúng ta nên quay lại một chút về các khái niệm thiết kế cơ bản của Angular.\r\n\r\n# React, Angular và Vếu... nhầm Vue\r\n\r\nTại đây mình chỉ đề cập đến 3 frameworks này, vì mặc dù có nhiều framework khác làm những việc tương tự, mình không đề cập không phải là vì nó không tốt bằng 3 anh này, nhưng về độ phổ biến thì 3 anh này không ai bằng, chẳng khác nào bộ 3 huyền ảo `Zara`, `HM` và `Uniqlo`. Còn ánh xạ cho ai thì tùy bạn :D\r\n\r\nNhư chúng ta đỡ biết, `React` và `Vue` và nhiều framework khác sử dụng **virtual DOM** để detect, và sau khi **tính toán sự thay đổi**, cuối cùng là update lại **những thứ thật sự cần thay đổi** lên trên `ĐƠM thật`. Cơ bản là vậy đó, vì mấy cái zụ `ĐƠM ảo` này mình cũng không rành lắm, biết zậy thôi.\r\n\r\nNhưng Angular **lại không sử dụng thiết kế đó (VDOM)** để phát triển, mà bọn họ lại chọn **change detection** để làm cái việc detect, và render lại view.\r\n\r\n**Vậy tại sao họ lại lựa chọn thiết kế nài?** Xin trả lời là mình **đếu biết**. \r\n\r\nMình nghĩ chắc họ có lý do của họ, tìm hiểu nhiều tài liệu nhiều cuộc tranh luận mình cũng không thấy cái nào là rõ ràng và thật sự chính xác. Nhưng có lẽ nói như thế này là đúng nhất\r\n```\r\nIs chocolate ice cream better than vanilla ice cream?\r\n```\r\nMình cũng ếu biết kem nào ngon hơn luôn, mình ghét ăn kem, mình ăn bưởi hơn, vì nó tốt cho sức khỏe? Mình nghĩ ae coder cũng thích ăn bưởi hơn, chắc vậy? còn ai thích ăn kem thì tùy, thế giới giờ cũng thoáng. **Mà suy cho cùng thoái mái với cái gì thì mình cứ làm với đó thôi.**\r\n\r\nNhưng có 1 điều mình **chắc chắn** là chạy Angular **sẽ tốn memory** hơn là `React` và `Vue`, mà cũng đơn giản thôi vì nó là 1 framwork hoàn chỉnh từ render đến routing và làm được thêm nhều thứ khác mà không cần đến các 3rd party.\r\n\r\nMà vấn đề quản lý `memory` ở javascript thì framework nào cũng vậy, không nắm được rõ cái mình đang làm thì `best framework` cũng `out of memory` thôi. `Webpack` là 1 ví dụ, chạy `build build run run` một hồi lâu là out of memory liền.\r\n\r\nQuay lại vấn đề thiết kế, từ các thông tin trên chúng ta có thể **đúc kết lại như này:**\r\n\r\n- `React` và `Vue` đều dùng **`VDOM`**. **Lưu ý** dù đều dùng VDOM nhưng 2 fw này lại có cách implement khác nhau nhé. React là `setState` còn Vue là `Object.definedProperty`. Các bác có thể tự tìm hiểu thêm nhóe.\r\n- còn `Angular` thì sử dụng `Change Dectection` và `zone.js` (được implement thành `NgZone` trong Angular)\r\n\r\n\u003e https://angular.io/api/core/NgZone \u003cbr\u003e \r\n\u003e https://github.com/angular/zone.js/\r\n\r\n## Performance thì sao nhỉ?\r\nTheo như mình tìm hiểu thì bác [`IgorMinar`](https://github.com/IgorMinar) một trong core member của dự án `Angular` sau khi được hỏi là tại sao `Angular` không sử dụng `VDOM`?, cũng như tại sao lại chọn thiết kế như hiện tại thì trả lời đại loại như thế này.\r\n\r\n## Igor said\r\n**Um.... ơ hờm... thật khó để so sánh các thiết kế với nhau mấy pa ơi** vì nó giống như bạn ăn tô `bún bò` với tô `phở` vậy, bạn người Bắc có lẽ thích phở hơn, còn nếu bạn là người Trung (miền trung nhé, không phải tung của nhóe) chắc thích bụn bọ huệ hơn. Còn mình mình thích bún bò huệ hơn (kệ cmm -__- =\u003e nói tiếp đi anh Igor). Và với lại team chúng tôi vẫn cảm thấy thoải mái với thiết kế này cũng như vẫn thoái mái với hiệu suất thực thi (`runtime performance`) mà chúng tôi mong đợi và chúng tôi cũng đang có những cải tiến để tăng hiệu năng ứng dụng ở các phiên bản tiếp theo...bla bla, nên chọn dùng gì vẫn là **lựa chọn là ở các bạn**.\r\n\r\n\u003e Chỗ bún bò vs phở anh `IgorMinar` không cón nói nhé hehe.\r\n\r\nCác bạn có thể xem thêm cuộc tranh luận ở đây:\r\nhttps://github.com/angular/angular/issues/22587\r\n\r\n**Bảng so sánh hiệu năng**\r\n![Benchmarks](https://i.imgur.com/r5NU0ey.png)\r\n\r\nXem thêm: https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html\r\n\r\n## Tổng kết\r\n\r\nTừ bản so sánh hiệu năng ở trên thì ít nhiều chúng ta có thể thấy thì 3 anh này tốc độ cũng same same nhau thôi ah. Nên không thể nói thiết kế nào tốt hơn thiết kế nào cạ. Tùy sở thích mỗi người và dự án yêu cầu thì chơi thôi nhể.\r\n\r\n- React, Vue thì `VDOM`\r\n- Angular thì `change detection`\r\n\r\n# Vậy `Change Detection` trong Angular là gì? Và tại sao lại cần `zone.js`\r\n\r\nXét đoạn code dưới này nè:\r\n``` js\r\n// \u003cdiv id=\"content\"\u003e\u003c/div\u003e\r\nconst content = document.getElementById('#content');\r\nupdateText = function () {\r\n    input.innerHTML = text + \": \" + Date.now();\r\n}\r\nlet text = \"Hello\";\r\nupdateText();\r\n```\r\n\r\nSau khi chạy thì cái cái `div` kia sẽ có giá trị là: `Hello: 1526665390423`. Hàm `updateText` đã update lại text cho input đó. Ok nothing.\r\n\r\nThêm tiếp đoạn này nựa:\r\n``` js\r\nconst btn = document.getElementById('btn1');\r\nbtn.addEventListener('click', () =\u003e {\r\n    text = \"Aquanicap\";\r\n})\r\n```\r\n\r\nQuá rõ ràng là sau khi click button xong thì **chả có cái méo gì xảy ra cả**. Giỏ giàng quá rồi, object đúng là được cập nhật nhưng html của div **thì không biết điều đóa**. Đáng là phải như này mới đúng chớ.\r\n\r\n``` js\r\nconst btn = document.getElementById('btn1');\r\nbtn.addEventListener('click', () =\u003e {\r\n    text = \"Aquanicap\";\r\n    updateText();\r\n})\r\n```\r\n\r\n**Đúng !!** bạn đoán y chóc, hàm `updateText` đó chính là mô phỏng cho việc `change detection` trong `Angular`. Và tụi Mẽo gọi đó là `monkey patch` hay là `open heart surgery` gì đó.\r\n\r\nMọe kiếp khó nhớ kinh. Kiu mình search từ khóa `monkey patch` rồi đọc mớ giải thích chắc cũng méo hiểu nó nói gì và chắc lại nghĩ chết mẹ cái gì mà lại cao siêu vậy rồi lại hành hạ, chì chiết bản thân nựa ??? \r\n\r\nNhưng hông lẽ **Angular implement đơn giản như quại sao?** \r\n\r\nĐể trả lời câu hỏi này, chúng ta nên suy nghĩ một chút là **thật sự các sự thay đổi** ở view được thay đổi ở **những trường hợp** nào? Tổng kết nó chỉ nằm trong **3** trường hợp nài:\r\n\r\n1. **Events** - User events like click, change, input, submit,...\r\n2. **XMLHttpRequests/fetch** - E.g. when fetching data from a remote service\r\n3. **Timers** - setTimeout(), setInterval()...\r\n\r\nThẩm một chút chúng ta có thể nhận ra: **AH, đang mệt, tụi này nó có gì gì đó chung chung phải không ta?**, chết mẹ đúng rồi đó là **tụi nó toàn là `ASYNCCHRONOUS`** (móa phát hiện vĩ đại quá ha -__-)\r\n\r\nCó thể mổ phỏng lại trong `Angular` như nầy nè:\r\n``` js\r\nconst btn = document.getElementById('btn1');\r\nbtn.addEventListener('click', () =\u003e {\r\n    text = \"Aquanicap\";\r\n    runAngularsChangeDetection(); \r\n})\r\n```\r\n\r\n## Vậy làm cách nào Angular `detect` được khi nào `update lại data và view` trong 3 cái actions này?\r\n\r\nQuay lại một chút về thiết kế của Angular một chút để ứng với mỗi action Angular cung cấp các công cụ gì:\r\n\r\n1. **Events**: Angular support `(click)`, `(change)`, `(keyup)`...\r\n2. **XMLHttpRequests** : Chính là module `Http` và sau này là `HttpClient`\r\n3. **Timers**: Các hàm từ `rxjs`... cũng như `setTimeout interval` của native.\r\n\r\nThì như trên đa phần các action này đều được Angular wrap bởi khuôn khổ framework của mình, nghĩa là sự kiện `click` không chỉ còn mỗi việc là gọi lại cái `callback` của chúng ta rồi làm mỗi cái việc của chúng ta trong đó.\r\n\r\nMà bản chất là nó sẽ làm thêm những việc như gọi `change detection`, `updade view`, update `life cycle`... sau khi hàm `callback` của chúng ta run xong, nói chung là kiểu kiểu vậy. Người ta (tụi Mẽo) gọi đó là: đang mệt, `monkey patch` hay là `phẩu thuật tim hở` gì gì đó... -__-\r\n\r\n**\u003e\u003e\u003e Và để làm cái việc trời đánh này, Angular đã sử dụng thư viện và nó được gọi là `zone.js`**\r\n\r\n# Vậy `zone.js` là cái méo gì?\r\n\r\nHomepage: https://github.com/angular/zone.js/\r\n\r\n**A Zone is an execution context that persists across async tasks. You can think of it as thread-local storage for JavaScript VMs.**\r\n\r\nHiểu nôm na nó sẽ tạo ra một vùng context để thực hiện các thao tác bất đồng bộ (async). Nghĩa là bây giờ các thao tác async sẽ được **chạy trên một vùng** mà chúng ta có thể **quản lý, sờ nắn và tác động được**.\r\n\r\nVí dụ một đoạn code sau:\r\n```js\r\nfunction bar() {\r\n    console.log('bar')\r\n}\r\nfunction foo() {\r\n    console.log('foo')\r\n}\r\nfunction baz() {\r\n    console.log('baz')\r\n}\r\n```\r\n\r\n```js\r\nvar start,\r\n    time = 0;\r\n    timer = Date.now;\r\n\r\nstart = timer();\r\nfoo();\r\nbar();\r\nbaz();\r\ntime = timer() - start;\r\n\r\n// log time in ms\r\nconsole.log(Math.floor(time*100) / 100 + 'ms');\r\n```\r\n\r\nSau khi chạy thì chúng ta có thể detect được thời gian mà 3 functions thực thi. Nhưng rõ ràng là không có gì đặc biệt hết, bây giờ chúng ta xét đoạn code khác dưới này, chúng ta update lại `function baz` với `setTimeout()`: \r\n```js\r\nfunction bar() ...\r\nfunction foo() ...\r\n// Update lại function baz với timeout\r\nfunction baz() {\r\n    setTimeout(() =\u003e {\r\n        console.log('baz')\r\n    }, 1000)\r\n}\r\n```\r\nChạy lại đoạn code đo thời gian thực thi bên trên, nó sẽ tốn hơn một xíu thời gian so với đoạn code `sync` ở trên, nhưng rõ ràng là thời gian thực thi này không thể hiện đúng những gì chúng ta đang chạy vì hàm `setTimeout()` sẽ là một `tác vụ không đồng bộ` được trình duyệt thêm vào **event queue** sau đó cuối cùng sẽ được **event loop** xử lý khi hết thời gian chờ `1000 ms`.\r\n\r\n**Vậy làm cách nào để giải quyết vấn đề với các tác vụ bất đồng bộ?** Do đó cái chúng ta cần là làm một cách nào đó `hook` để **cho phép chúng ta biết khi nào** mà một tác vụ không bộ **xảy ra.** \r\n\r\nSuy nghĩ đơn giản một chút là chúng ta sẽ thêm thủ công các hàm đo đếm trong từng hàm `async`, **nhưng ai mà đi làm vậy?** thật là lộn xộn, cứ phải thêm trong mỗi cuối hàm `async`.\r\n\r\n\u003cstrong style=\"color:red\" \u003eĐÂY CHÍNH LÀ NƠI MÀ ZONE RA ĐỜI ĐỂ GIẢI QUYẾT\u003c/strong\u003e. \r\n\r\nXem đoạn code dưới đây, nhưng bạn có thể tham khảo thêm tài liệu của [Zone API homepage](https://github.com/angular/zone.js/blob/master/dist/zone.js.d.ts) để biết thêm chi tiết. Mình sẽ không đề cập chi tiết ở đây. \r\n```js\r\nfunction bar() { console.log('bar') };\r\nfunction foo() { console.log('foo') };\r\nfunction baz() {\r\n    setTimeout(() =\u003e {\r\n        console.log('baz')\r\n    }, 1000)\r\n}\r\nfunction bazz() {\r\n    setTimeout(() =\u003e {\r\n        console.log('bazz')\r\n    }, 1000)\r\n}\r\n\r\n// Wrap các hàm lại nằm trong hàm main\r\nfunction main() {\r\n    bar();\r\n    foo();\r\n    baz();\r\n    bazz();\r\n}\r\n\r\nconst rootZone = Zone.current;\r\nconst zoneA = rootZone.fork({\r\n    name: 'zoneA',\r\n    onInvokeTask: function (parentZoneDelegate, currentZone, targetZone, task) {\r\n        console.log('Run async') // Run trước khi hàm được gọi\r\n        task.callback(); // Original method đc gọi ở đây\r\n        //... run sau khi hàm được gọi\r\n    }\r\n})\r\n\r\nzoneA.run(main);\r\n```\r\nKết quả sau khi chạy các hàm trong `Zone`:\r\n\r\n![Zonejs](https://i.imgur.com/61ZrE3G.png)\r\n\r\nChắc qua ví dụ trên chúng ta ít nhiều hiểu sơ sơ thằng zone làm cái gì rồi phải hôn? Đại loại các `async methods` sẽ được thằng `Zone` ôm lại hết vào lòng để quản lý và sau đóa cung cấp cho chúng ta các methods để **làm cái gì đó chúng ta muốn ahihi** trước sau những async method đó. Các bác thể gọi là thằng zone là **Zone tú bà**.\r\n\r\n## Zone hữu dụng khi nào và `why` lại dùng nó?\r\n\r\n1. Zones are useful for debugging, testing, profiling.\r\n2. Zones are useful for frameworks to know when to render.\r\n3. Zones are useful for tracking resources which persist across async operations and can automatically release/cleanup the resources. \r\n4. Zones are composable\r\n\r\nSau khi google dịch 4 cái câu trên, em rút ra được một điểm chung đó là...... 4 cầu này đều là thì hiện tại đơn thì phải, và cái quan trọng nhất khi được google dịch dùm câu này\u003cbr\u003e\r\n`Zones are useful for frameworks to know when to render.` =\u003e \u003cbr\u003e\r\n`Các khu vực rất hữu ích cho các khung công tác để biết thời điểm hiển thị.` -__- dù hơi hơi là khó hiểu một chút nhưng... **đúng gòi, chính xác**, đây chính là cái `Angular` cần và cũng đang sử dụng cho thiết kế của mình. Nó giúp framework biết khi nào `async funtions` thực thi xong để gọi các hàm `re-render` view cũng như gọi các hàm trong `life cycle` của bản thăn nó.\r\n\r\n**=\u003e Angular đang xài combo `Change Detection` + `Zone.js`** \r\n\r\n# Cuối cùng Zone.js hoạt động trong Angular như thế nào?\r\n\r\nSau những hà hồ sa số giải thích ở trên thì các bạn cũng nhận ra là `Angular` đang sử dụng `Zone.js` để hỗ trợ cho việc update lại state của application và render lại view của ứng dụng. \r\n\r\nThì trong một ứng dụng Angular, Angular sẽ tạo ra một vùng zone được fork từ rootZone (thường là zone của window ở browser) và sẽ tự thân quản lý nó có thể được gọi là `AngularZone`. Thì những `actions, events...` mà hoạt động dưới **các thao tác bất đồng bộ** sẽ được Angular quản lý và xử lý các thay đổi này. Từ đó update lại tầng view cho ứng dụng.\r\n\r\nAngular không sử dụng library `zone.js` native mà sẽ wrap nó trên một class gọi là **`NgZone`**, thì nó sẽ cung cấp các `state` để chúng tracking, cũng như là chúng ta cũng có thể chạy **bất cứ một hàm nào nằm ngoài vùng kiểm soát** của `Angular Zone`.\r\n\r\nChẳng hạn như là khi chúng ta sử dụng chức năng `scroll` trong browser chẳng hạn, `scroll` sinh ra và call liên tục các sự kiện, rõ ràng nó sẽ khiến vấn đề performance có trục trặc. Nhưng mà nó lại là một vấn đề khác nữa và nếu cơ hội mình sẽ làm một khác về vấn đề performance của `Angular`. Bài viết cũng khá là dài dài rồi nên chắc mình phải kết thúc tại đây thôy.\r\n\r\nChi tiết class NgZone của Angular:\u003cbr\u003e\r\nhttps://angular.io/api/core/NgZone\r\n\r\n```ts\r\nclass NgZone {\r\n  static isInAngularZone(): boolean\r\n  static assertInAngularZone(): void\r\n  static assertNotInAngularZone(): void\r\n  constructor(__0)\r\n  get hasPendingMicrotasks: boolean\r\n  get hasPendingMacrotasks: boolean\r\n  get isStable: boolean\r\n  get onUnstable: EventEmitter\u003cany\u003e\r\n  get onMicrotaskEmpty: EventEmitter\u003cany\u003e\r\n  get onStable: EventEmitter\u003cany\u003e\r\n  get onError: EventEmitter\u003cany\u003e\r\n  run\u003cT\u003e(fn: (...args: any[]) =\u003e T, applyThis?: any, applyArgs?: any[]): T\r\n  runTask\u003cT\u003e(fn: (...args: any[]) =\u003e T, applyThis?: any, applyArgs?: any[], name?: string): T\r\n  runGuarded\u003cT\u003e(fn: (...args: any[]) =\u003e T, applyThis?: any, applyArgs?: any[]): T\r\n  runOutsideAngular\u003cT\u003e(fn: (...args: any[]) =\u003e T): T\r\n}\r\n```\r\n\r\n# Túm lại cái váy bài này đê\r\n\r\nSau bài này mình rút ra được vài điều như này mà mình thấy:\r\n\r\n1. React, Vue xài `VDOM`, Angular xài `change detection`.\r\n2. Hiệu suất 3 frameworks là khá tương đồng nhau, không thể nói thiết kế nào tốt hơn thiết kế nào.\r\n3. Sử dụng framework là do sở thích và là cái diên.\r\n4. Tất cả các hoạt động thay đổi đều thuộc về các thao tác bất đồng bộ.\r\n5. Angular sử dụng `zone.js` để hỗ trợ việc `change detection`.\r\n\r\nThanks các bác đã đọc đến tận đây nhóe !!!\r\n\r\n# Tham khảo\r\n\r\n1. https://blog.thoughtram.io/angular/2016/01/22/understanding-zones.html\r\n2. https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html\r\n3. https://github.com/angular/zone.js/\r\n4. https://github.com/angular/angular/issues/22587\r\n\r\nBài viết gốc được đăng ở blog của mình:\r\nhttps://www.jinhduong.com/post/zone-in-angular/\r\n"
                }, {
                "id": "09p2hYC0GHdM7lkm4EZYdQ",
                "title": "[Series Dart Lang] Phần 3: Exceptions, Class, Constructors trong Dart",
                "content": "## Control flow statements\r\nAnh em có thể tham khảo tại [official docs](https://www.dartlang.org/guides/language/language-tour#control-flow-statements). Vì phần này khá cơ bản và giống Java, không có gì đặc biệt nên mình sẽ bỏ qua.\r\n\r\n## Throw and Exceptions\r\nTương tự như các ngôn ngữ khác, Dart cũng hỗ trợ [Exceptions](https://api.dartlang.org/dev/dart-core/Exception-class.html), [Errors](https://api.dartlang.org/dev/dart-core/Error-class.html) và rất nhiều các subtypes của 2 class đó.\r\n\r\nĐể throw hay raise lên một Exception ta có thế làm như sau:\r\n```\r\nthrow new FormatException('Expected at least 1 section');\r\n\r\nthrow 'Out of llamas!';\r\n```\r\n\r\n\u003e**Note:** Để tăng tính hiệu quả, cũng như giúp cho code meaning hơn. Chúng ta thường throw những error là subtype của `Error` và `Exception`.\r\n\r\nBởi vì việc throw ra một exception được coi là một expression. Do đó chúng ta có thể làm như sau:\r\n```\r\nvoid distanceTo(Point other) =\u003e\r\n    throw new UnimplementedError();\r\n```\r\n\r\n## Catch\r\n```\r\ntry {\r\n  breedMoreLlamas();\r\n} on OutOfLlamasException {\r\n  buyMoreLlamas();\r\n}\r\n```\r\nTrên là cách chúng ta handle một exception `OutOfLlamasException` mà đoạn code trong `try` có thể throw ra. Bạn cũng có thể catch nhiều exception:\r\n```\r\ntry {\r\n  breedMoreLlamas();\r\n} on OutOfLlamasException {\r\n  // Xác định rõ loại exception mà bạn muốn handle\r\n  buyMoreLlamas();\r\n} on Exception catch (e) {\r\n  // Nếu exception không phải là OutOfLlamasException, chúng ta handle những error là subtype của Exception\r\n  print('Unknown exception: $e');\r\n} catch (e) {\r\n  // Không xác định, handle tất cả\r\n  print('Something really unknown: $e');\r\n}\r\n```\r\nBạn dùng `on` khi muốn xác định type mà bạn muốn catch. Sử dụng `catch` để nhận được object mà đoạn code trong `try` throw ra.\r\n```\r\ntry {\r\n  // ···\r\n} on Exception catch (e) {\r\n  print('Exception details:\\n $e');\r\n} catch (e, s) {\r\n  print('Exception details:\\n $e');\r\n  print('Stack trace:\\n $s');\r\n}\r\n```\r\n\r\n## Classes\r\nDart là ngôn ngữ hướng đối tượng với class và _mixin-based inheritance_. Mọi object đều là một instance của class. _Mixin-based inheritance_ có nghĩa là, mặc dù một class chỉ có duy nhất một superclass, nhưng mà class body (các variable, method) có thể được sử dụng lại như _multiple class hierarchies_ (hiểu nôm na là đa thừa kế, phần này đoạn sau sẽ làm rõ).\r\n\r\nBạn có thể tạo 1 object bằng từ khóa `new` với _constructor_ của class. Constructor có thể là _Classname_ hoặc _Classname.identifier_ (identifier này kiểu như là đặt tên cho constructor, ở mục constructor sẽ nói rõ):\r\n```\r\nvar jsonData = jsonDecode('{\"x\":1, \"y\":2}');\r\n\r\n// Create a Point using Point().\r\nvar p1 = new Point(2, 2);\r\n\r\n// Create a Point using Point.fromJson().\r\nvar p2 = new Point.fromJson(jsonData);\r\n```\r\n\u003e**Dart 2 note:** Với Dart 2 bạn có thể bỏ từ khóa `new`. Ví dụ: var p1 = Point(2, 2).\r\n\r\nĐể lấy ra type của object, bạn sử dụng property `runtimeType`:\r\n```\r\nprint('The type of a is ${a.runtimeType}');\r\n```\r\n\r\n## Constructors\r\nĐây là cách tạo một constructor:\r\n```\r\nclass Point {\r\n  num x, y;\r\n\r\n  Point(num x, num y) {\r\n    // There's a better way to do this, stay tuned.\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n}\r\n```\r\n\u003e**Note:** Chỉ sử dụng `this` when xảy ra name conflict.\r\n\r\nNếu chúng ta muốn gán trực tiếp các variable thông qua constructor chúng ta có thể làm như sau (cách này rất phổ biến):\r\n```\r\nclass Point {\r\n  num x, y;\r\n\r\n  // Syntactic sugar for setting x and y\r\n  // before the constructor body runs.\r\n  Point(this.x, this.y);\r\n}\r\n```\r\n\r\n### Default constructors\r\nNếu ta không tạo constructor cho class, mặc định Dart sẽ tạo ra constructor không tham số cho class đó.\r\n\r\n### Constructors aren’t inherited\r\nCác subclass không kế thừa các constructor của superclass. Nghĩa là nếu superclass có tạo ra 1 constructor, đồng nghĩa với việc các subclass cũng phải tạo ra constructor và gọi lại construcor của superclass:\r\n```\r\nclass Person {\r\n  final _name;\r\n\r\n  Person(this._name);\r\n}\r\n\r\nclass Musican extends Person {\r\n  Musican(String name): super(name);\r\n}\r\n```\r\n\r\n### Named constructors\r\nĐánh tên cho constructor giúp cho constructor có nghĩa và rõ ràng hơn:\r\n```\r\nclass Point {\r\n  num x, y;\r\n\r\n  Point(this.x, this.y);\r\n\r\n  // Named constructor\r\n  Point.origin() {\r\n    x = 0;\r\n    y = 0;\r\n  }\r\n}\r\n```\r\nTrong trường hợp kế thừa:\r\n```\r\nclass Person {\r\n  String firstName;\r\n\r\n  Person.fromJson(Map data) {\r\n    print('in Person');\r\n  }\r\n}\r\n\r\nclass Employee extends Person {\r\n  // Person does not have a default constructor;\r\n  // you must call super.fromJson(data).\r\n  Employee.fromJson(Map data) : super.fromJson(data) {\r\n    print('in Employee');\r\n  }\r\n}\r\n\r\nmain() {\r\n  var emp = new Employee.fromJson({});\r\n```\r\n\r\n### Redirecting constructors\r\nThỉnh thoảng nhiệm vụ duy nhất của một constructor chỉ là chuyển hướng sang một constructor khác trong cùng một class:\r\n```\r\nclass Point {\r\n  num x, y;\r\n\r\n  // The main constructor for this class.\r\n  Point(this.x, this.y);\r\n\r\n  // Delegates to the main constructor.\r\n  Point.alongXAxis(num x) : this(x, 0);\r\n}\r\n```\r\n\r\n### Constant constructors\r\nNếu như chúng ta muốn tạo ra một object không bao giờ thay đổi. Để làm điều đó, tạo ra một `const` constructor, và đảm bảo rằng các variable là `final`:\r\n```\r\nclass ImmutablePoint {\r\n  static final ImmutablePoint origin =\r\n      const ImmutablePoint(0, 0);\r\n\r\n  final num x, y;\r\n\r\n  const ImmutablePoint(this.x, this.y);\r\n}\r\n```\r\n\r\n### Factory constructors\r\nChúng ta sử dụng `factory` khi muốn tạo constructor không chỉ để tạo ra một instance mới của class mà có thể một instance từ cache, hoặc một subtype instance.\r\n\r\nDưới đây là ví dụ factory constructor trả ra một object từ cache.\r\n```\r\nclass Logger {\r\n  final String name;\r\n  bool mute = false;\r\n\r\n  // _cache is library-private, thanks to\r\n  // the _ in front of its name.\r\n  static final Map\u003cString, Logger\u003e _cache =\r\n      \u003cString, Logger\u003e{};\r\n\r\n  factory Logger(String name) {\r\n    if (_cache.containsKey(name)) {\r\n      return _cache[name];\r\n    } else {\r\n      final logger = new Logger._internal(name);\r\n      _cache[name] = logger;\r\n      return logger;\r\n    }\r\n  }\r\n\r\n  Logger._internal(this.name);\r\n\r\n  void log(String msg) {\r\n    if (!mute) print(msg);\r\n  }\r\n}\r\n```\r\n\u003e**Note:** Lưu ý rằng Factory constructor không thể truy cập vào `this`.\r\n\r\nSử dụng factory constructor như bình thường:\r\n```\r\nvar logger = new Logger('UI');\r\nlogger.log('Button clicked');\r\n```\r\n"
                }, {
                "id": "CnzyYfdPlGYEHHnwCSKMZg",
                "title": "Một số câu hỏi phỏng vấn JavaScript hay và khó 1 - Chắc ai đó sẽ cần !",
                "content": "Xin chào bạn! \n\nCó thể bạn đã biết, JavaScript là một ngôn ngữ lập trình rất mạnh, nhưng lại vô cùng rắc rối, phức tạp. Để có thể nắm vững được JavaScript, bạn sẽ cần phải mất một thời gian khá dài để học và thực hành nó. \n\nVà một trong số những cách thực hành hiệu quả nhất, đó là trả lời các câu hỏi, giải đố, quiz. Thông qua việc trả lời mỗi câu hỏi, bạn sẽ tự kiểm tra lại kiến thức của bản thân, đồng thời học hỏi thêm nhiều kiến thức mới.\n\nBài viết này mình sẽ chia sẻ với bạn một số câu hỏi phỏng vấn JavaScript rất hay. Mời bạn theo dõi!\n\n## Câu 1\n\n```js\nconst x = [1, 2, 3];\nx[-1] = -1;\nconsole.log(x[x.indexOf(10000)]);\n```\n\nHỏi console in ra kết quả như thế nào?\n\n## Câu 2\n\n```js\n//let i = ?\n \nconsole.log(i * i); // =\u003e 0\nconsole.log(i + 1); // =\u003e 1\nconsole.log(i - 1); // =\u003e -1\nconsole.log(i / i); // =\u003e 1\n```\n\nTìm số i thỏa mãn đồng thời 4 câu lệnh trên?\n\n## Câu 3\n\n```js\nlet a = [1, 2, 3] + [4, 5, 6];\nconsole.log(a);\n```\n\nHỏi console in ra kết quả như thế nào?\n\n## Câu 4\n\n```js\n(function() {\n  let x = 100;\n})();\n \nconsole.log(x);\n```\n\nHỏi console in ra kết quả như thế nào?\n\n## Đáp án và giải thích\n\nĐể tránh tình trạng bạn chưa suy nghĩ kĩ mà đã xem lời giải, mình sẽ không để đáp án và giải thích tại đây. \n\nThay vào đó, mời bạn xem đáp án và giải thích chi tiết tại [Xoắn não với phỏng vấn JavaScript 1](https://completejavascript.com/xoan-nao-voi-phong-van-javascript-1/).\n\nXin chào và hẹn gặp lại!\n\n---\nTheo dõi [Lam Pham](https://completejavascript.com/gioi-thieu/) trên [Kipalog](https://kipalog.com/users/Lam%20Pham/mypage) để nhận thông báo khi có bài viết mới nhất:\n\n  * **Facebook Fanpage:** [Complete JavaScript](https://www.facebook.com/completejavascript/)\n  * **Facebook Group:** [Hỏi đáp JavaScript VN](https://www.facebook.com/groups/HoiDapJavascriptVN)\n  * **Portfoflio** : [Lam Pham](http://about.phamvanlam.com)"
                }, {
                "id": "fm0C9R7TWsvWbCj0Z5FHwA",
                "title": "Tại sao các công ty không gửi mail báo \"rớt\" cho bạn là những công ty có HR tệ nhất quả đất?",
                "content": "# Chuyện của tôi\r\nVào đợt nghỉ lễ giỗ tổ Hùng-King vừa rồi, mình có nhận được một mời phỏng vấn ở một công ty A nọ. Mặc dù thời điểm phỏng vấn không tốt lắm, 1h30PM, thời tiết khá nắng nóng vào hôm đó, nhưng mình vẫn quyết định tới tham gia buổi phỏng vấn đúng giờ. Kết thúc buổi phỏng vấn, mình nhận được feedback là công ty sẽ gửi bài test cho mình. Và sau hơn một tuần chờ đợi thì mình không nhận được thông tin gì cả! Có thể là sau buổi phỏng vấn đó, công ty đó đã thấy là mình không phù hợp và không tiếp tục với mình. Ok, fine. Nhưng tại sao không thông báo cho mình? Trong khi mình đang ngồi chờ một bài test nào đó từ họ?\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/5d0wvv6h1k_waiting-mail.gif)\r\n\r\nCó thể rất nhiều bạn đang có những câu chuyện giống mình. Các bạn gửi CV, rồi nhận được thông báo từ HR và bắt đầu quy trình phỏng vấn. Có thể là bài test online hay là một vòng phỏng vấn trực tiếp. Sau đó bạn về nhà, chờ đợi và chờ đợi. Sau 1 tuần mà không thấy một email phản hồi nào cả, bạn đành tự hiểu rằng, \"**à, thế là mình tạch**\".\r\n\r\n# Tại sao vậy?\r\nTheo mình, có thể người HR của công ty đó cho rằng \"mình đã không gửi mail trả lời, ứng viên sẽ tự hiểu là họ rớt\". Hoặc có thể là họ đang bận ngồi xem cv của một ai đó, hay tiến hành phỏng vấn với một ứng viên khác ngon lành hơn. Nhưng tóm lại, là vào lúc này, bạn đã không còn giá trị trong mắt họ. Họ không tuyển được bạn, không kiếm được tiền từ bạn, chả có lý do gì để họ tiếp tục một cuộc nói chuyện vô nghĩa, hay phải tốn tầm 15-20 giây để copy một cái format email nào đó để gửi cho bạn!\r\n\r\nMột tình huống khác là HR muốn giữ lại như một lựa chọn backup. Nếu một ứng viên khác ngon hơn nhưng đã từ chối offer, họ có thể sẽ quay lại với ứng viên bị rớt như một lựa chọn thay thế. Thường việc này diễn ra sau vài tháng.\r\n\r\n# Tại sao tôi nói đó là những HR tệ?\r\nTôi từng phỏng vấn ở một công ty G. Phải nói chị HR ở công ty đó là người \"nice\" nhất tôi từng gặp. Chị gọi điện, thông báo chi tiết về từng step, địa điểm tòa nhà. (Cái công ty A kia, tui phải hỏi loanh quanh mấy người bảo vệ ở nơi khác mới biết được nơi vào văn phòng của công ty đó. Họ còn thắc mắc là sao ngày nghỉ vẫn đi phỏng vấn!). Khi tôi tạch ở vòng cuối cùng, chị cũng có gọi điện và giải thích nguyên nhân tạch, abc xyz. Rõ ràng, chị đã thể hiện rõ sự chuyên nghiệp trong công việc, cũng như sự tôn trọng đối với bất kỳ ứng viên nào. Qua đó, mang lại những hình ảnh tốt đẹp về công ty.\r\nDù là tôi đã trượt, nhưng ấn tượng tôi về công ty đó rất là tốt. Nếu có ai hỏi, tôi vẫn cho rằng đó là một công ty có văn hóa, dù rằng tôi chưa làm việc ở đó ngày nào. Còn với công ty A kia, nếu có ai đó hỏi...  hmm chắc bạn biết câu trả lời của tôi rồi đó.\r\n\r\nTưởng tượng là bạn đang nói chuyện với một ai đó. Rồi bỗng nhiên người kia im lặng. Và rồi khi time-out tới, bạn đành tự hiểu là \"người ta đã không tiếp tục với bạn\". Bạn có cảm thấy đó là **bất lịch sự** không? \r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lk5b4tstyl_facebook_seen-980x420.jpg)\r\nQuy trình phỏng vấn cũng như một cuộc nói chuyện vậy. Đã có bắt đầu, thì hãy nên có một kết thúc. Hoặc là bạn sẽ từ chối những vòng phỏng vấn tiếp theo. Hoặc là HR sẽ báo cho bạn việc bạn chưa đạt một số tiêu chí. Dù là theo cách nào đi nữa, để một cuộc nói chuyện trở nên **tử tế**, hãy kết thúc một cách tử tế!\r\n\r\nNgoài ra, các bạn ứng viên đã phải dành rất nhiều thời gian cho buổi phỏng vấn. Từ việc chuẩn bị kiến thức, quá trình đi lại, rồi sắp xếp công việc trên công ty. Không thể cho rằng vì HR quá bận, hay thời gian của HR *quý* hơn của ứng viên được.\r\n\r\n# Kết\r\nViệc gửi một email thông báo tới ứng viên là tạch, không hề mất thời gian của HR. Một ứng viên, đã phải giành rất nhiều thời gian để phỏng vấn ở công ty. Họ phải chuẩn bị CV này, phải ôn tập kiến thức trước buổi phỏng vấn. Thậm chí phải xin nghỉ trên công ty hiện tại để đi phỏng vấn ở chỗ các bạn. Chưa kể quá trình đi lại trên đường cho kịp giờ phỏng vấn còn có thể gặp những rủi ro tai nạn giao thông nữa. Những việc đó tốn của ứng viên rất nhiều thời gian, công sức, và tâm huyết. **Vậy lý do gì mà HR lại tiết kiệm 15 giây trong cuộc đời mà không gửi email cho ứng viên?**\r\nThế nên, các bạn HR ạ, xin hãy dành cho những ứng viên, sự tôn trọng tối thiểu. Hãy cho họ một kết quả, để họ không phải chờ đợi trong một sự im lặng!\r\n\r\nLePhongVu 18-05-2018"
                }, {
                "id": "KrcFiHUq3Y4yVJST-h_aAQ",
                "title": "Xử lý assynchronous bằng axios và những lầm lẫn hay gặp khi sử dụng aysnc, await và axios",
                "content": "![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/zfnc4okssz_0_7362QLWAsdyhwsBB.png)\r\n\u003e# Chém gió\r\naxios là thư viện call api rất tuyệt vời, nó hầu như tương thích với mọi trình duyệt,khi mình sử dụng axios thì hầu như mình chả bao giờ phải dùng promise nữa.axios hỗ trợ cho cả npm ,cdn.. :v nói chung là quá tiện cho ai dùng để call api.\r\nĐây là document của [nó](https://github.com/axios/axios)\r\n\u003e# Async/await là gì ??\r\nasync/await là cú pháp mới của javascript khi lên ES7.Bạn có thể tham khảo tại [document](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) của nó  mình rất thích sử dụng nó hơn là promise.Vậy tại sao nên dùng nó .Ta xem đoạn code giới đây\r\nNhư đoạn code dưới đây ta thấy một promise  chỉ try catch đc một lần cho tất cả các callback\r\n```javascript\r\nconst makeRequest = () =\u003e {\r\n  return callAPromise()\r\n    .then(() =\u003e callAPromise())\r\n    .then(() =\u003e callAPromise())\r\n    .then(() =\u003e callAPromise())\r\n    .then(() =\u003e callAPromise())\r\n    .then(() =\u003e {\r\n      throw new Error(\"oops\");\r\n    })\r\n}\r\n```\r\nĐối với await . mỗi callback đều có thể try catch tùy ý\r\n\r\n```\r\nconst makeRequest = async () =\u003e {\r\n  const value1 = await promise1()\r\n  const value2 = await promise2(value1)\r\n  return promise3(value1, value2)\r\n}\r\n```\r\n\r\n\u003e# Cách sử dụng axios\r\naxios cung cấp rất cho ta rất nhiều method sẵn nhưng ở trong bài này mình chỉ nhắc đến ba cái phổ biến hay dùng nhất khi mình sử dụng restful api là get ,post, put. mọi method được gọi từ axios đều là bất động bộ vì vậy đề gán cho một biến nào đó ta phải sử dụng async/await\r\nVd mình muốn gửi request tới server lấy thông tin của một user có id là một chẳng hạn thì:\r\n```javascript\r\naxios.get('/user', {\r\n    params: {\r\n      id: 1\r\n    }\r\n  })\r\n  .then(function (response) {\r\n//response là biến chứa toàn bộ thông tin user\r\n    console.log(response);\r\n  })\r\n  .catch(function (error) {\r\n    console.log(error);\r\n  });\r\n```\r\n\u003e# Các sai lầm phổ biến khi sử dụng axios\r\nDưới đây mình nêu ra các sai lầm khi mình sử dụng axios ,thực ra sai lầm nên cũng tương tự như khi sử dụng promise nếu bạn nào đã dùng rồi chắc sẽ biết\r\n**Thứ 1:**\r\n``` javascript\r\nfunction TestAxios(){\r\n  const data=axios.get('/user', {\r\n      params: {\r\n        id: 1\r\n      }\r\n    })\r\n    .then(function (response) {\r\n  //response là biến chứa toàn bộ thông tin user\r\n      console.log(response);\r\n    })\r\n    .catch(function (error) {\r\n      console.log(error);\r\n    });\r\n  return data;\r\n}\r\n```\r\nOk ở đây hàm này sẽ chả trả về cho bạn cái mịa gì hết vì axios.get là hàm bất động bộ. Nó chưa load data về thì đã gán cho thằng data và return con mịa nó rồi. Vậy ở đây để gán cho data. Thì ta sử lại code đoạn này chút : ))).\r\n``` javascript\r\nasync function TestAxios(){\r\n  const data=await axios.get('/user', {\r\n      params: {\r\n        id: 1\r\n      }\r\n    })\r\n    .then(function (response) {\r\n  //response là biến chứa toàn bộ thông tin user\r\n      console.log(response);\r\n    })\r\n    .catch(function (error) {\r\n      console.log(error);\r\n    });\r\n  return data;\r\n}\r\n```\r\nNếu không muốn sử dụng await/async thì ta có thể return ngay trong then\r\n\r\n``` javascript\r\n function TestAxios(){\r\n axios.get('/user', {\r\n      params: {\r\n        id: 1\r\n      }\r\n    })\r\n    .then(function (response) {\r\n  //response là biến chứa toàn bộ thông tin user\r\n      console.log(response);\r\n      return response;\r\n    })\r\n    .catch(function (error) {\r\n      console.log(error);\r\n    });\r\n\r\n}\r\n```\r\nNói chung bài viết chỉ thế thôi. Bác nào có lỗi gì gặp mà chưa có ở trên thì cmt ở dưới cho em ý kiến.\r\n\r\n\r\n"
                }, {
                "id": "D4N7XM9gjEPsIodFUDzLEA",
                "title": "Elixir - Sử dụng ETS làm bộ nhớ cache để tăng tốc web Phoenix",
                "content": "Xem bài viết gốc trên [http://bluzky.github.io](http://bluzky.github.io/post/2018-05-17-ets-as-cache-phoenix/)\r\n\r\n\r\n\u003e Bài viết này sẽ hướng dẫn các bạn sử dụng ETS như là bộ nhớ cache để tăng tốc các ứng dụng web Phoenix\r\n\r\n\r\n\r\nDành cho các bạn chưa biết: \r\n\r\n- ETS (Erlang Term Storage) là cơ sở dữ liệu dạng `key-value` lưu trữ trên RAM, tương tự như **Memcache** và **Redis**, với ưu điểm là tốc độ truy xuất cực nhanh. Đọc thêm về [ETS](http://bluzky.github.io/post/2018-05-12-erlang-term-storage/)\r\n- Cache là việc lưu lại các kết quả xử lý của request vào bộ nhớ và trả về cho các request sau mà không cần phải tính toán lại -\u003e giảm response time.\r\n\r\n\r\n\r\n### 1. Setup project\r\n\r\n- Tạo 1 project mới\r\n  ```shell\r\n  mix phx.new phoenix_cache\r\n  mix deps.get\r\n  ```\r\n\r\n- Thêm chức năng tạo/xoá/sửa bài viết\r\n  ```shell\r\n  mix phx.gen.html Posts Post posts title:string summary:text content:text\r\n  mix ecto.create\r\n  mix ecto.migrate\r\n  ```\r\n\r\n- Vào [http://0.0.0.0:4000/posts](http://0.0.0.0:4000/posts) để xem chức năng bài viết. Thêm vài bài viết để có dữ liệu test\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/yh4bbqdrku_ets-phoenix.png)\r\n\r\n### 2. Tạo một module để quản lý cache\r\n\r\nDo table trong ETS sẽ bị huỷ khi process khởi tạo table kết thúc, nên cần phải có 1 process luôn luôn chạy để table không bị xoá. Sử dụng `GenServer` để quản lý Cache là tiện nhất vì nó được cung cấp sẵn bởi Elixir.\r\nĐọc thêm về [GenServer](https://hexdocs.pm/elixir/GenServer.html)\r\n\r\n#### 2.1 Tạo module\r\n\r\nTạo một file mới `phoenix_cache/lib/phoenix_cache/bucket.ex`\r\n```elixir\r\ndefmodule PhoenixCache.Bucket do\r\n  use GenServer\r\n  alias :ets, as: Ets\r\n\r\n  # thời gian sống của 1 entry mặc định là 6 phút\r\n  @expired_after 6 * 60\r\n\r\n  def start_link(args \\\\ []) do\r\n    GenServer.start_link(__MODULE__, args, name: __MODULE__)\r\n  end\r\nend\r\n```\r\n\r\n\r\n#### 2.2 Khởi tạo cache table khi bắt đầu chạy `GenServer`\r\n\r\n```elixir\r\ndef init(state) do\r\n    Ets.new(:simple_cache, [:set, :protected, :named_table, read_concurrency: true])\r\n    {:ok, state}\r\nend\r\n```\r\n**Module cache sẽ hỗ trợ 3 thao tác:**\r\n\r\n- `set`: lưu data vào bộ nhớ cache\r\n- `get`: lấy data từ bộ nhớ cache\r\n- `delete`: xoá data khỏi cache (cái này có vẻ không cần lắm thì phải)\r\n\r\n\r\n\r\n#### 2.3 Thêm data vào cache\r\n\r\n```elixir\r\n\r\n  def set(key, value) do\r\n    GenServer.cast(__MODULE__, {:set, key, value})\r\n  end\r\n\r\n  @doc \"\"\"\r\n  Default TTL \r\n  \"\"\"\r\n  def handle_cast({:set, key, val}, state) do\r\n    expired_at =\r\n      NaiveDateTime.utc_now()\r\n      |\u003e NaiveDateTime.add(@expired_after, :second)\r\n\r\n    Ets.insert(:simple_cache, {key, val, expired_at})\r\n    {:noreply, state}\r\n  end\r\n```\r\n\r\nỞ đây chúng ta sẽ tạo tính toán thời điểm expire/hết hạn của giá trị cache, tính từ thời điểm hiện tại, sử dụng giá trị `TTL`(thời gian sống) mặc định là 6phút. Bạn có thể cấu hình lưu `TTL` mặc định vào config hoặc biến môi trường. Mình lưu vào thuộc tính module cho tiện.\r\n\r\n\r\n\r\n#### 2.4 Thêm data vào cache và thiết lập thời gian sống của data\r\n\r\nĐể có thể thoải mái thiết lập `TTL`, ta thêm 1 hàm cho phép truyền vào tham số `TTL`\r\n\r\n```elixir\r\n@doc \"\"\"\r\n  Custom TTL for cache entry\r\n  ttl: Time to live in second\r\n  \"\"\"\r\n  def set(key, value, ttl) do\r\n    GenServer.cast(__MODULE__, {:set, key, value, ttl})\r\n  end\r\n  \r\n  @doc \"\"\"\r\n  Custom TTL\r\n  \"\"\"\r\n  def handle_cast({:set, key, val, ttl}, state) do\r\n    inserted_at =\r\n      NaiveDateTime.utc_now()\r\n      |\u003e NaiveDateTime.add(ttl, :second)\r\n\r\n    Ets.insert(:simple_cache, {key, val, inserted_at})\r\n    {:noreply, state}\r\n  end\r\n```\r\n\r\nCũng tương tự như trên nhưng hàm `set` sẽ nhận thêm tham số thứ 3 là `TTL` thay vì xài giá trị mặc định.\r\n\r\n\r\n\r\n#### 2.5 Truy xuất dữ liệu từ cache\r\n\r\nCó vào thì phải có lấy ra chứ nhỉ, bây giờ ta sẽ thêm code để truy xuất data từ cache.\r\n\r\n```elixir\r\n  def get(key) do\r\n\t# lấy giá trị đầu tiên tìm đuợc\r\n    rs = Ets.lookup(:simple_cache, key) |\u003e List.first()\r\n\r\n\t\t# Nếu không tìm thấy thì trả về lỗi\r\n    if rs == nil do\r\n      {:error, :not_found}\r\n    else\r\n      expired_at = elem(rs, 2)\r\n\t\t\t\r\n\t\t\t# So sánh thời điểm hết hạn với hiện tại, nếu hết hạn thì trả về lỗi\r\n      cond do\r\n        NaiveDateTime.diff(NaiveDateTime.utc_now(), expired_at) \u003e 0 -\u003e\r\n          {:error, :expired}\r\n\r\n        true -\u003e\r\n          {:ok, elem(rs, 1)}\r\n      end\r\n    end\r\n  end\r\n```\r\n\r\n**Note**: Nhờ feedback của bác @HQC, chỗ này mình đọc trực tiếp từ table, thay vì dùng `GenServer.call` như trước vì khi send request vào GenServer thì code sẽ được chạy `sync`/đồng bộ. Do vậy sẽ tạo nên ngẽn cổ chai. Mình sửa lại ở phần tạo table thêm `read_concurrency: true` và đưa phần code query dữ liệu ra ngoài GenServer\r\n\r\n\r\n\r\n#### 2.6 Xoá dữ liệu khỏi cache\r\n\r\n```elixir\r\n  def delete(key) do\r\n    GenServer.cast(__MODULE__, {:delete, key})\r\n  end\r\n  \r\n  def handle_cast({:delete, key}, state) do\r\n    Ets.delete(:simple_cache, key)\r\n    {:noreply, state}\r\n  end\r\n```\r\n\r\n### 3. Setup cache\r\n\r\nTa đã tạo xong module cache rồi, nhưng làm sao để cache tự động chạy khi chạy server? \r\n\r\nThêm worker vào file `phoenix_cache/lib/phoenix_cache/application.ex`\r\n\r\n```elixir\r\nchildren = [\r\n      ...\r\n      worker(PhoenixCache.Bucket, [])\r\n    ]\r\n```\r\n\r\nKhi `Supervisor` khởi chạy, nó sẽ start các `children` và quản lý chúng. Để hiểu rõ hơn, đọc thêm tại [https://hexdocs.pm/elixir/Supervisor.html](https://hexdocs.pm/elixir/Supervisor.html)\r\n\r\n\r\n\r\n### 4. Xài cache\r\n\r\nOlala, ta đã tạo module cache và thiết lập để chạy cùng với server, bây giờ tới lúc xài nó rồi.\r\n\r\nThử dùng cache cho chức năng xem bài viết:\r\n\r\n```elixir\r\ndef show(conn, %{\"id\" =\u003e id}) do\r\n    post =\r\n      # lấy nội dung post từ cache\r\n      case PhoenixCache.Bucket.get(\"posts-#{id}\") do\r\n      \t# Nếu có ròi thì khỏi cần đọc DB\r\n        {:ok, post} -\u003e\r\n          IO.puts(\"HIT\")\r\n          post\r\n\r\n        {:error, _} -\u003e\r\n          IO.puts(\"MISS\")\r\n          # Chưa cache thì đọc từ DB\r\n          post = Posts.get_post!(id)\r\n\r\n          # cache bài viết 60s\r\n          PhoenixCache.Bucket.set(\"posts-#{id}\", post, 60)\r\n          post\r\n      end\r\n\r\n    render(conn, \"show.html\", post: post)\r\n  end\r\n\r\n```\r\n\r\n\r\n\r\nKết quả request:\r\n\r\n```shell\r\n[info] GET /posts/1\r\nMISS\r\n...\r\n[info] GET /posts/1\r\nHIT\r\n...\r\n```\r\n\r\nLần request đầu tiên, bài viết chưa được cache nên phải truy xuất database và cache lại, lần thứ 2 thì đã có trong cache nên không cần phải đọc từ database nữa.\r\n\r\nỞ ví dụ này có thể bạn sẽ chưa thấy sự khác biệt lắm về tốc độ response, nhưng nếu như thay vì load 1 bài viết bằng việc xử lý thống kê dữ liệu thì sự khác biệt sẽ rất lớn.\r\n\r\n\r\n\r\n### 5. Plug cache\r\n\r\nNếu cứ mỗi chức năng đều phải thêm code để kiểm tra cache  thì sẽ lặp lại rất nhiều. Để phát huy cái sự lười biếng thì ta sẽ tạo một plug đơn giản để khỏi phải code nhiều lần.\r\n\r\n```elixir\r\ndefmodule PhoenixCache.Plug.Cache do\r\n  import Plug.Conn\r\n\r\n  # 6 minute\r\n  @default_ttl 6 * 60\r\n\r\n  def init(ttl \\\\ nil), do: ttl\r\n\r\n  def call(conn, ttl \\\\ nil) do\r\n    ttl = ttl || @default_ttl\r\n\r\n    # Chỉ cache với GET request\r\n    if conn.method == \"GET\" do\r\n      # tạo key từ request path và query param, thông thường\r\n      # thì cùng path và cùng param thì kết quả là giống nhau\r\n      key = \"#{conn.request_path}-#{conn.query_string}\"\r\n\r\n      case PhoenixCache.Bucket.get(key) do\r\n        {:ok, body} -\u003e\r\n          IO.puts(\"PLUG HIT\")\r\n\t\t  \r\n\t\t  # nếu đã cache thì trả về ngay\r\n          conn\r\n          |\u003e send_resp(200, body)\r\n          |\u003e halt\r\n\r\n        _ -\u003e\r\n          IO.puts(\"PLUG MISS\")\r\n\t\t  # nếu chưa cache thì xử lý như bình thường\r\n          conn\r\n          |\u003e assign(:ttl, ttl)\r\n          |\u003e register_before_send(\u0026cache_before_send/1) # gọi hàm này trước khi trả về\r\n      end\r\n    else\r\n      conn\r\n    end\r\n  end\r\n\r\n  def cache_before_send(conn) do\r\n    # nếu request đuợc xử lý thành công thì cache\r\n    if conn.status == 200 do\r\n      key = \"#{conn.request_path}-#{conn.query_string}\"\r\n      data = conn.resp_body\r\n      PhoenixCache.Bucket.set(key, data, conn.assigns[:ttl] || @default_ttl)\r\n      conn\r\n      \r\n    else\r\n      # không thì kệ chúng mày\r\n      conn\r\n    end\r\n  end\r\nend\r\n\r\n```\r\n\r\nĐây chỉ là một plug đơn giản, bạn có thể viết lại theo nhu cầu.\r\n\r\nSử dụng Plug: `plug(PhoenixCache.Plug.Cache, TTL )`\r\n\r\n```elixir\r\npipeline :browser do\r\n    ...\r\n    plug(PhoenixCache.Plug.Cache, 100) # cache 100s\r\n end\r\n```\r\n\r\n### 6. Kết luận\r\n\r\nVậy là bạn đã có thể sử dụng ETS như là bộ nhớ cache cho ứng dụng Phoenix của mình mà không cần phải cài thêm phần mềm/dịch vụ khác.\r\n\r\nHi vọng sẽ giúp ích cho các bạn\r\n\r\nSource code project [https://github.com/bluzky/phoenix_ets_cache_example](https://github.com/bluzky/phoenix_ets_cache_example)\r\n"
                }, {
                "id": "CU33rNAMU29GTcESsgjtcw",
                "title": "[Design Pattern] Command Pattern",
                "content": "Design pattern luôn là một lĩnh vực khá khó nhằn và hơi trừu tượng. Trong bài viết này, mình sẽ giới thiệu về một pattern có tên là Command, với ví dụ trong bài viết hi vọng giúp các bạn dễ hiểu hơn về pattern này.\r\n\r\n---\r\n\r\n#### Giới thiệu\r\n\r\n**Command** là một trong 23 design pattern Gang of Four nổi tiếng. Command  thuộc nhóm các pattern hành vi. \r\n\r\nGang of Four chỉ ra mục đích sử dụng của pattern Command như sau:\r\n\r\n\u003e Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.\r\n\r\nĐoạn trên xem ra có vẻ hơi trừu tượng. Nhưng chúng ta có thể hiểu đơn giản như thế này: request từ phía người dùng sẽ được đóng gói dưới dạng một đối tượng *command* và đối tượng *command* này sẽ được chuyển cho một thành phần riêng biệt để thực thi. Pattern Command sẽ phân tách quá trình tiếp nhận request với quá trình thực thi request. Chính vì vậy, công việc xử lý request sẽ trở nên linh hoạt và dễ nâng cấp hơn. Điều này cũng giống như trong thực tế, người phục vụ sẽ chỉ quan tâm đến món ăn mà thực khách yêu cầu, còn việc chế biến món ăn ấy ra sao thì đã có đầu bếp của nhà hàng lo rồi.\r\n\r\nBên cạnh đó, trong pattern Command, chúng ta có thể lưu vết các command đã thực hiện. Nhờ điều này mà pattern Command còn được áp dụng cho tác vụ undo/redo trong các ứng dụng thực tế.\r\n\r\n---\r\n\r\n#### Cấu trúc\r\n\r\nUML của pattern Command:\r\n\r\n![Command Pattern UML](https://yuen26.github.io/img/20180517/1.png)\r\n\r\nPattern Command gồm 5 thành phần chính:\r\n\r\n- **Command**: đây có thể là một interface hoặc abstract class, chứa một abstract method `execute()`. Request sẽ được đóng gói dưới dạng Command.\r\n- **Concrete Command**: là các implementation của Command, mỗi một Concrete Command sẽ phục vụ cho một case request riêng.\r\n- **Receiver**: đây mới là thành phần thực sự xử lý business logic cho case request. Trong method `execute()` của Concrete Command, chúng ta sẽ gọi method thích hợp trong Receiver.\r\n- **Client**: tiếp nhận request từ phía người dùng và đóng gói request thành Concrete Command thích hợp.\r\n- **Invoker**: tiếp nhận Concrete Command từ Client và gọi `execute()` của Concrete Command để thực thi request. Việc lưu vết command sẽ được thực hiện ở trong Invoker.\r\n\r\nNhư vậy, Client và Invoker sẽ thực hiện việc tiếp nhận request. Còn việc thực thi request sẽ do Command, Concrete Command và Receiver đảm nhận.\r\n\r\n---\r\n\r\n#### Ví dụ\r\n\r\nTrong ví dụ này, chúng ta sẽ thử áp dụng pattern Command vào bài toán order món ăn tại một nhà hàng. Đầu tiên, khách hàng (customer) sẽ order món ăn. Với từng món ăn (steak hoặc pizza) thì người phục vụ (waiter) sẽ chuyển order cho đầu bếp (chef) chuyên chế biến món đó. Với bài toán này, chúng ta có thể thấy:\r\n- Order sẽ đóng vai trò Command.\r\n- Steak và Pizza chính là các Concrete Command.\r\n- Steak Chef và Pizza Chef đóng vai trò Receiver.\r\n- Customer đóng vai trò Client.\r\n- Waiter sẽ là cầu nối giữa Customer và Chef: Invoker.\r\n\r\nDưới đây là chi tiết cài đặt cho bài toán này:\r\n\r\n**Order.java**\r\n\r\n```java\r\npublic interface Order {\r\n    \r\n    void execute();\r\n    \r\n}\r\n```\r\n\r\n**Pizza.java**\r\n\r\n```java\r\npublic class Pizza implements Order {\r\n\r\n    private PizzaChef chef;\r\n\r\n    public Pizza(PizzaChef chef) {\r\n        this.chef = chef;\r\n    }\r\n\r\n    @Override\r\n    public void execute() {\r\n        chef.makePizza();\r\n    }\r\n\r\n\t@Override\r\n    public String toString() {\r\n        return \"pizza\";\r\n    }\r\n\r\n}\r\n```\r\n\r\n**Steak.java**\r\n\r\n```java\r\npublic class Steak implements Order {\r\n\r\n    private SteakChef chef;\r\n\r\n    public Steak(SteakChef chef) {\r\n        this.chef = chef;\r\n    }\r\n\r\n    @Override\r\n    public void execute() {\r\n        chef.makeSteak();\r\n    }\r\n\r\n\t@Override\r\n    public String toString() {\r\n        return \"steak\";\r\n    }\r\n\r\n}\r\n```\r\n\r\n**PizzaChef.java**\r\n\r\n```java\r\npublic class PizzaChef {\r\n\r\n  public void makePizza() {\r\n    System.out.println(\"I'm making pizza\");\r\n  }\r\n  \r\n}\r\n```\r\n\r\n**SteakChef.java**\r\n\r\n```java\r\npublic class SteakChef {\r\n\r\n  public void makeSteak() {\r\n    System.out.println(\"I'm making steak\");\r\n  }\r\n  \r\n}\r\n```\r\n\r\n**Waiter.java**\r\n\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class Waiter {\r\n\r\n  // Track orders\r\n  private List\u003cOrder\u003e orders = new ArrayList\u003c\u003e();\r\n  \r\n  public void takeOrder(Order order) {\r\n    System.out.println(\"Waiter taked new order \" + order.toString());\r\n    orders.add(order);\r\n    order.execute();\r\n  }\r\n  \r\n}\r\n```\r\n\r\n**Customer.java**\r\n\r\n```java\r\npublic class Customer {\r\n\r\n    public static void main(String[] args) {\r\n      // Invoker\r\n      Waiter waiter = new Waiter();\r\n      \r\n      // Receivers\r\n      PizzaChef pizzaChef = new PizzaChef();\r\n      SteakChef steakChef = new SteakChef();\r\n      \r\n      // Commands\r\n      Order pizza = new Pizza(pizzaChef);\r\n      Steak steak = new Steak(steakChef);\r\n      \r\n      // Test\r\n      waiter.takeOrder(pizza);\r\n      waiter.takeOrder(steak);\r\n    }\r\n    \r\n}\r\n```\r\n\r\nChạy file **Customer.java**, chúng ta sẽ có kết quả như sau:\r\n\r\n\u003cpre\u003e\r\nWaiter taked new order pizza\r\nI'm making pizza\r\nWaiter taked new order steak\r\nI'm making steak\r\n\u003c/pre\u003e\r\n\r\nLink soure code: [https://github.com/yuen26/tutorial-design-pattern/tree/master/command/order](https://github.com/yuen26/tutorial-design-pattern/tree/master/command/order)"
                }, {
                "id": "kZWdaDbK6p9laAFVcE_7nQ",
                "title": "[Series Dart Lang] Phần 2: Anonymous function, scope, operators trong Dart",
                "content": "## Functions as first-class objects\r\nBạn có thể truyền 1 function như 1 parameter của 1 function khác:\r\n```\r\nvoid printElement(int element) {\r\n  print(element);\r\n}\r\n\r\nvar list = [1, 2, 3];\r\n\r\n// Pass printElement as a parameter.\r\nlist.forEach(printElement);\r\n```\r\nBạn cũng có thể gán 1 function cho 1 variable:\r\n```\r\nvar loudify = (msg) =\u003e '!!! ${msg.toUpperCase()} !!!';\r\nassert(loudify('hello') == '!!! HELLO !!!');\r\n```\r\nỞ ví dụ trên, chúng ta đã sử dụng anonymous function. Chúng ta cùng tìm hiểu xem nó là gì nhé.\r\n\r\n## Anonymous functions\r\nHầu hết các function đều có tên, như `main()` hoặc `printElement()`. Bạn cũng có thể tạo những function \"vô danh\" hay còn gọi là _anonymous function_, hoặc _lambda_ (với anh em Java hay Kotlin có vẻ sẽ hay dùng từ này) hoặc _closure_ (anh em Swift thì có thể sẽ quen với từ này). Bạn có thể gán nó cho 1 variable hay có thể add hay remove khỏi một collection như một element bình thường.\r\n\r\nAnonymous function nhìn có vẻ giống như một function bình thường, chỉ khác là nó không có tên:\r\n```\r\n([[Type] param1[, …]]) {\r\n  codeBlock;\r\n};\r\n```\r\nVí dụ ở dưới, chúng ta sẽ tạo một anonymous function với parameter là `item` và không xác định type cho nó. Chúng ta truyền anonymous function cho function `forEach`, và anonymous function được gọi bên trong function `forEach`:\r\n```\r\nvar list = ['apples', 'bananas', 'oranges'];\r\nlist.forEach((item) {\r\n  print('${list.indexOf(item)}: $item');\r\n});\r\n```\r\nKết quả:\r\n```\r\n0: apples\r\n1: bananas\r\n2: oranges\r\n```\r\nNếu như function body chỉ chứa 1 statement, bạn có thể sử dụng `=\u003e` để rút ngắn code:\r\n```\r\nlist.forEach(\r\n    (item) =\u003e print('${list.indexOf(item)}: $item'));\r\n```\r\n\r\n## Lexical scope\r\n\u003eDart is a lexically scoped language\r\n\r\nNghĩa là \"scope\" phạm vi của một variable được xác định tĩnh, dựa trên \"layout\" cấu trúc của code.\r\n```\r\nbool topLevel = true;\r\n\r\nvoid main() {\r\n  var insideMain = true;\r\n\r\n  void myFunction() {\r\n    var insideFunction = true;\r\n\r\n    void nestedFunction() {\r\n      var insideNestedFunction = true;\r\n\r\n      assert(topLevel);\r\n      assert(insideMain);\r\n      assert(insideFunction);\r\n      assert(insideNestedFunction);\r\n    }\r\n  }\r\n}\r\n```\r\nFunction `nestedFunction()` có thể sử dụng những variable ở các level trên và ngoài nó.\r\n\r\n## Lexical closures\r\n```\r\n/// Returns a function that adds [addBy] to the\r\n/// function's argument.\r\nFunction makeAdder(num addBy) {\r\n  return (num i) =\u003e addBy + i;\r\n}\r\n\r\nvoid main() {\r\n  // Create a function that adds 2.\r\n  var add2 = makeAdder(2);\r\n\r\n  // Create a function that adds 4.\r\n  var add4 = makeAdder(4);\r\n\r\n  assert(add2(3) == 5);\r\n  assert(add4(3) == 7);\r\n}\r\n```\r\nFunction `makeAdder` giữ lại variable `addby`. Kể cả khi function kết thúc, nó vẫn giữ lại variable `addBy`.\r\n\r\n## Return values\r\n```\r\nfoo() {}\r\n\r\nassert(foo() == null);\r\n```\r\n\r\nTất cả các function đều trả ra giá trị. Nếu bạn không xác định giá trị return, hoặc không return ra giá trị nào trong body. Giá trị mặc định trả ra mặc định của function là `null`.\r\n\r\n## Operators\r\nDart hỗ trợ rất nhiều operator từ cơ bản đến một số operator mới. Bạn có thể override lại khá nhiều operator tùy vào mục đích của bạn. Dưới đây là bảng operator được hỗ trợ bởi Dart: [Operators Table](https://www.dartlang.org/guides/language/language-tour#operators)\r\n\r\n## Arithmetic operators\r\nDart hỗ trợ một số operator toán học:[Arithmetic operators table](https://www.dartlang.org/guides/language/language-tour#arithmetic-operators)\r\n\r\nMình sẽ giải trích dẫn một số operator có thể mới mẻ với mọi người:\r\n* `~/`: Chia 2 số và trả về kết quả là số nguyên. `assert(5 ~/ 2 == 2); // Result is an int`\r\n\r\n## Equality and relational operators\r\nMột số operator so sánh hơn, bằng: [Equality and relational operators table](https://www.dartlang.org/guides/language/language-tour#equality-and-relational-operators).\r\n\r\n## Type test operators\r\nChúng ta sử `as`, `is`, và `is!` operator để kiểm tra type lúc runtime.\r\n\r\n| Operator| Ý nghĩa       |\r\n| --------|-------------|\r\n| as      | Operator dùng để ép kiểu |\r\n| is      | Return True nếu type checking là đúng     |\r\n| is!     | Return False nếu type checking là sai      |\r\nHãy cùng nhìn đoạn code ở dưới đây:\r\n```\r\nif (emp is Person) {\r\n  // Type check\r\n  emp.firstName = 'Bob';\r\n}\r\n```\r\nỞ trong Kotlin họ gọi đây là _smart cast_ vì variable `emp` được kiểm tra bằng operator `is` với `Person`, nếu True thì statement ở dưới, variable `emp` tự động được hiểu là `Person` luôn.\r\n\r\nBạn có thể dùng operator `as` như sau:\r\n```\r\n(emp as Person).firstName = 'Bob';\r\n```\r\n\u003e**Note:** 2 đoạn code trên không tương đương nhé. Nếu trong trường hợp `emp` là `null` hoặc không phải là `Person`, example đầu tiên sẽ không có vấn đề gì xảy ra vì nó trả ra False, còn với example 2 sẽ throw ra exception.\r\n\r\n## Assignment operators\r\n```\r\n// Assign value to a\r\na = value;\r\n// Assign value to b if b is null; otherwise, b stays the same\r\nb ??= value;\r\n```\r\nBình thường bạn có thể dùng operator `=` để gán 1 giá trị, vậy chuyện gì sẽ ra khi giá trị gán là null và bạn không muốn điều đó xảy ra. Đoạn code trên giải quyết vấn đề đó một cách ngắn gọn với operator `??=`. Chỉ khi `value` không `null`, thì `value` mới được gán cho `b`.\r\n\r\nAnh em tham khảo thêm một số assignment operator ở đây: [Assignment operators table](https://www.dartlang.org/guides/language/language-tour#assignment-operators).\r\n\r\n## Conditional expressions\r\nDart hỗ trợ 2 operator giúp bạn thực hiện code nhanh hơn tương tự với `if-else`:\r\n```\r\ncondition ? expr1 : expr2\r\n```\r\nCái này có vẻ quá quen thuộc rồi nên mình sẽ không nói nữa.\r\n\r\n```\r\nexpr1 ?? expr2\r\n```\r\nVới operator này, nếu _expr1_ không null, sẽ return giá trị của nó, nếu không sẽ return giá trị của _expr2_\r\n\r\nVí dụ:\r\n```\r\nvar visibility = isPublic ? 'public' : 'private';\r\n\r\nString playerName(String name) =\u003e name ?? 'Guest';\r\n```\r\n\r\n## Cascade notation (..)\r\n`..` cho phép bạn thực hiện một loạt các operation trên cùng 1 object.\r\nNếu không dùng cascade:\r\n```\r\nvar button = querySelector('#confirm');\r\nbutton.text = 'Confirm';\r\nbutton.classes.add('important');\r\nbutton.onClick.listen((e) =\u003e window.alert('Confirmed!'));\r\n```\r\nSau khi dùng cascade:\r\n```\r\nquerySelector('#confirm') // Get an object.\r\n  ..text = 'Confirm' // Use its members.\r\n  ..classes.add('important')\r\n  ..onClick.listen((e) =\u003e window.alert('Confirmed!'));\r\n```\r\n\u003e**Note:** \"double dot\" `..` không phải là operator. Nó là một syntax của Dart.\r\n\r\n## Safe call\r\nLý do mình gọi nó là \"safe call\" vì  hẳn trong chúng ta đã đối mặt rất nhiều với `NullPointerException`. Lý do là chúng ta không check `null` trước khi gọi một object, thực sự thì nó rất rườm rà `if not nul...`. Do đó Dart cung cấp cho chúng ta một operator để làm việc đó dễ dàng hơn: `?.`\r\n```\r\nvar a = foo?.bar()\r\n```\r\nNếu `foo` là null, function `bar()` sẽ không được gọi và `a` sẽ bằng `null`.\r\n"
                }, {
                "id": "4ADL9ipfc0d1pYOiAu5-1w",
                "title": "Bài toán phân quyền vấn đề muôn thuở và rất khó hiểu.",
                "content": "(* Trong bài viết này mình chỉ nêu quan điểm và những thứ mình đã từng làm với việc phân quyền trên thực tế, chỉ mang tính tham khảo cho mọi người. Nếu có bất kỳ ý kiến góp ý nào hãy bình luận ở dưới để chúng ta cùng thảo luận thêm.)\r\n\r\nPhân quyền công việc mang đầy tính năng nề đối với dev nhưng lại đầy sáng tạo cho người dùng. Như bạn biết khi phần mềm được dựng lên là có vô vàn rắc rối xoay quanh quyền hạn người sử dụng, Vì thế lập trình viên đã tạo ra một thứ mang tên phân quyền để tránh tình trạng mọi người đều là vua trong chương trình đó đơn giản với việc \"Bạn được quyền làm việc đó hay không?\".\r\n### 1. Phân quyền là gì?\r\nTưởng tượng đơn giản như này nhé. \r\n\r\n- Bạn là sếp bạn có toàn quyền với nhân viên của mình\r\n- Bạn là trưởng phòng bạn chỉ có quyền với nhân viên trong phòng của mình\r\n- Bạn là trưởng nhóm dự án bạn chỉ có quyền với các thành viên trong nhóm\r\n- Và Nhóm \u003c Phòng \u003c công ty.\r\n- Như vậy bạn có thể thấy trong công ty này có 3 loại quyền hạn và chúng ta cần phân quyền theo nó\r\n\r\n### 2. Bạn thường dùng loại phân quyền như thế nào?\r\n- Câu hỏi này mình đặt ra ban đầu là \"Có các loại phân quyền nào?\" nhưng thật sự việc phân quyền này rất ít được public do nó mang tính chất riêng tư của những dự án. Nên nếu bạn search thì chủ yếu sẽ chỉ tìm được cách tạo tài khoản sử dụng cho user trong các HQTCSDL.\r\n- Ở bài viết này mình sẽ nói về việc phân quyền bằng nhóm quyền (Group) Và đưa ra 1 số cách dựng CSDL (db).\r\n\r\n### 3. Phân quyền theo group là gì và làm như thế nào ?\r\n- Phân quyền theo group là cách gọi chung của mình cho việc bạn nhóm nhiều thành viên trong 1 tổ chức có cùng một quyền hạn thực thi công việc. Lúc đó ta có thể nhóm họ vào 1 group để dễ dàng trao quyền hạn.\r\n- Như vậy từ cách phân quyền theo group này ta có thể sử dụng với \"3 nấc\" khác nhau.\r\n\r\nVí dụ đơn giản về 3 cách này nhé :D\r\n\r\n#### 1. Phân quyền theo cấp bậc\r\n- Loại hình này chúng ta thường thiết kế db đơn giản như sau\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/c6i21irvwu_image.png)\r\n\r\n- Khi đó dữ liệu bạn dùng sẽ có dạng như thế này.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/qvim1d53xl_image.png)\r\n\r\n- role ở đây là 1, 2, 3 tức là có 3 mức quyền hạn và lớn nhất hay bé nhất còn tùy thuộc vào quy định của mỗi công ty. Ví dụ\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/3bh7ltgo2p_image.png)\r\n\r\n##### - Ưu điểm\r\nViệc sử dụng kiểu phân quyền này dễ dàng cho những người mới bắt đầu. Những nhóm quyền được lập lên nhanh chóng có thể sử dụng luôn, Và việc phải check cũng tương đối là đơn giản, bạn chỉ cần 1 cần \r\n````\r\nselect count(*) from tbl_... where id = ? and role = ?\r\nhoặc\r\nselect role from tbl_... where id = ?\r\n````\r\nRất dễ dàng để sử dụng đúng không. :D\r\n##### - Nhược điểm\r\nBạn biết đó việc sử dụng dữ liệu như này tồn tại 1 số nhược điểm rất lớn sau\r\n- Rất khó có thể mở rộng dự án\r\n- Trong thực tế không phải lúc nào cũng có 3 role. Nó có thể phát sinh nhiều role kì dị. Ví dụ: **Thư ký giám đốc ngoài quyền đuổi việc ra còn lại nó sẽ có quyền của giám đốc** vậy trường hợp này thuộc role 1 hay 2 ?.\r\n- Rất khó để phân quyền chi tiết.\r\n\r\n#### 2. Phân quyền theo chức năng\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/96k4geh52a_image.png)\r\n\r\nLoại phân quyền này được sử dụng rất nhiều trong thực tế. Nó rất hiệu quả và dễ thao tác đối với người cấp quyền.\r\n\r\nTa thiết kế db đơn giản trong ví dụ này như sau:\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/vp345fhxdr_image.png)\r\nNhưng để Demo mình sẽ tóm gọn 2 bảng **tbl_action** và **tbl_per_action** thành bảng **tbl_per_detail** để dễ thao tác. Và ta có một Database như sau.\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ugp2lz5646_image.png)\r\nChi tiết của việc thiết kế DB như sau:\r\n\r\n* **tbl_user**: bảng lưu người dùng bao gồm các thuộc tính như ID, Name,.... Bảng không có khóa ngoại.\r\n* **tbl_permision**: bảng chứa nhóm quyền hạn. bao gồm các thuộc tính, ID nhóm quyền hạn, tên nhóm quyền hạn.\r\n* **tbl_permision_detail**: là bảng sẽ chứa những quyền hạn cụ thể dành cho nhóm quyền hạn. Trường **action_name** không cần thiết bạn có thể bỏ. Trường **action_code** là để khi lập trình mình định nghĩa một thao tác nhất định trong bằng code này ví dụ quyền sửa thì code nó là **EDIT** chẳng hạn.\r\n* **tbl_per_relationship**: là bảng lưu mối liên hệ giữa người dùng và nhóm quyền hạn. Mục đích của bảng này không phải là để một người dùng có nhiều nhóm quyền mà để không phải truy vấn lại bảng user chứa thông tin nhạy cảm như username và password. Bạn cũng có thể **bỏ qua** bảng này và liên hệ trực tiếp giữa bảng user và permision luôn, nhưng mình khuyên bạn nên sử dụng thêm bảng này vì có nhiều trường hợp **user có nhiều quyền hạn**.\r\n\r\n**1. Kiểm tra dữ liệu trong các bảng**\r\n\r\n- **tbl_user**\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/vdb3rspaej_image.png)\r\n\r\n- **tbl_permision**\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/949j9mp1r5_image.png)\r\n\r\n- **tbl_per_detail**\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/yvo02saoht_image.png)\r\n\r\n- **tbl_user_per**\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/6al33komme_image.png)\r\n\r\n**2. Làm một số ví dụ**\r\n\r\n- Kiểm tra quyền của người dùng ví dụ: Hãy kiểm tra quyền của user có id là 1:\r\n\r\n```\r\nDECLARE @result NVARCHAR(1000)\r\nSET @result = N'Những quyền hiện tại của user ('\r\n\r\nselect @result = @result + name_user + ') là: ' from tbl_user where id_user = 1\r\nselect @result = @result + action_name + ', ' from tbl_user as u\r\n\tjoin tbl_user_per as up on u.id_user = up.id_user\r\n\tjoin tbl_permision as p on up.id_per = p.id_per\r\n\tjoin tbl_per_detail as pd on p.id_per = pd.id_per\r\n\twhere u.id_user = 1 and up.licensed = 1 and pd.check_action = 1\r\nselect @result = substring(@result, 0, len(@result))\r\n\r\nprint @result\r\n```\r\n- kết quả\r\n\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/x8xbv0eitj_image.png)\r\n\r\n- Kiểm tra xem user 2 có quyền xóa bài viết không ?\r\n\r\n\r\n```\r\nDECLARE @result bit\r\nselect @result = check_action from tbl_user as u\r\n\tjoin tbl_user_per as up on u.id_user = up.id_user\r\n\tjoin tbl_permision as p on up.id_per = p.id_per\r\n\tjoin tbl_per_detail as pd on p.id_per = pd.id_per\r\n\twhere u.id_user = 2 and up.licensed = 1 and action_code = 'DELETE'\r\n\r\nbegin\r\n\tif @result = 1\r\n\t\tprint N'Bạn CÓ quyền xóa post'\r\n\telse\r\n\t\tprint N'Bạn KHÔNG có quyền xóa post'\r\nend\r\n```\r\n- kết quả\r\n\r\n![alt text](https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gf719a8e3c_image.png)\r\n\r\n- Đó là một số ví dụ đơn giản tron tình huống này khi sử dụng phân quyền theo nhóm (group)\r\n\r\n**3. Kết luận**\r\n##### - Ưu điểm\r\n- Việc phân quyền này như mình có nêu ngay từ ban đầu rất dễ thao tác đối với những admin khi họ muốn chuyển nhóm quyền hoặc thỏa sức sáng tạo trong việc tạo ra những quyền mới từ những quyền ban đầu. Ví dụ như người dùng vừa có thể **EDIT** và **DELETE**,....\r\n- Ngoài ra việc thực hiện những câu querry cũng rất dễ dàng cho những lập trình viên.\r\n\r\n\r\n##### - Nhược điểm\r\n- Vấn đề sử dụng quyền hành động rất dễ khi chúng ta làm việc trên 1 group, nhưng nếu trong chương trình của bạn có nhiều group và phân cấp nhiều tầng thì nó lại là một vấn đề nan giải khác, khi bạn không chỉ phải check quyền hành động mà bạn còn phải check xem quyền hành động này của người dùng có thể áp dùng được trong group khác hay không?.\r\n\r\n\r\n#### 3. Phân quyền theo *Hành động* của các *nhóm Group* theo những *cấp bậc* khác nhau\r\n- Đây là loại phân quyền lằng ngằng nhất nhưng lại là quan trọng nhất, bởi các lý do sau đây:\r\n- Các tổ chức sử dụng phần mềm để thực hiện thao tác của họ đều có phân cấp rõ ràng\r\n- Trong những tổ chức có những người nắm full quyền của nhiều nhóm\r\n- Có những thành viên thuộc nhiều nhóm\r\n- Có những thành viên tuy chỉ là nhân viên nhưng lại có quyền của các sếp (thư ký)\r\n- Chính vì có nhiều trường hợp như vậy những lập trình viên sinh ra được rất nhiều case trong code.\r\n\r\nGiải quyết vấn đề này bạn có thể tìm hiểu cách thự hiện phân quyền trong odoo.\r\n- Phân quyền theo model: Có nghĩ là người dùng được thao tác thực hiện với những bảng dữ liệu nào\r\n       \r\n       Ví dụ: Admin có thể thực hiện với thao tác với bảng user của họ\r\n- phân quyền theo raw: Người dùng được thực hiện việc thao tác với các raw được chỉ định\r\n\r\n\r\n        Ví dụ: Leader A chỉ có thể thực hiện thao tác với những thành viên của mình trong bảng user\r\n- phân quyền theo column: Người dùng sẽ được quyền thao tac với nhưng column đó\r\n\r\n        Ví dụ: Chỉ giám đốc mới có thể đuổi việc nhân viên, ở đây ta sẽ có 1 column tên là is_working để biết việc nhân viên đó còn đi làm hay không :D\r\n\r\n### 4. Kết luận\r\n- Việc bạn sử dụng cách nào hay thứ tự ra sao tưởng rằng không quan trọng nhưng nếu nhìn xa hơn trong việc mở rộng cũng như update phần mềm thì đó có thể là cực hình cho người sau.\r\n- Nếu bạn được quyền tham gia vào thiết kế database (thường là review và góp ý) thì hãy xem xét đến các vấn đề về việc những trường hợp phát sinh đề phòng những người tạo ra DB thiếu sót.\r\n\r\nLoại phân quyền thứ 3 có rất nhiều kiểu biến hóa trong từng phần mềm của từng công ty, Và mình sẽ cố gắng tìm hiểu thêm để viết một bài nói về kiểu này ngoài ra mình cũng sẽ cố gắng viết 1 bài nói về kiểu phân quyền của odoo. Thực chất nó cũng gần giống kiểu phân quyền trong group thôi :D.\r\nCảm ơn các bạn đã đọc bài viết của mình. Văn phong hơi lủng củng nên mong các bạn thông cảm!."
                }],
    "status": 200,
    "cause": ""
}
